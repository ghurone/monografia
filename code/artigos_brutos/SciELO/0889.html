<!DOCTYPE html>
<div class="articleTxt">
 <div class="articleBadge-editionMeta-doi-copyLink">
  <span class="_articleBadge">
   Artigos Gerais
  </span>
  <span class="_separator">
   •
  </span>
  <span class="_editionMeta">
   Rev. Bras. Ensino Fís. 35 
                (1)
   <span class="_separator">
    •
   </span>
   Mar 2013
  </span>
  <span class="_separator">
   •
  </span>
  <span class="group-doi">
   <a class="_doi" href="https://doi.org/10.1590/S1806-11172013000100006" target="_blank">
    https://doi.org/10.1590/S1806-11172013000100006
   </a>
   <a class="copyLink" data-clipboard-text="https://doi.org/10.1590/S1806-11172013000100006">
    <span class="sci-ico-link">
    </span>
    copiar
   </a>
  </span>
 </div>
 <h1 class="article-title">
  <span class="sci-ico-openAccess showTooltip" data-original-title="by-nc 4.0 " data-toggle="tooltip">
  </span>
  Introdução à programação quântica
  <a class="short-link" href="#" id="shorten">
   <span class="sci-ico-link">
   </span>
  </a>
 </h1>
 <h2 class="article-title">
  Introduction to quantum programming
 </h2>
 <div class="articleMeta">
 </div>
 <div class="contribGroup">
  <span class="dropdown">
   <a class="dropdown-toggle" data-toggle="dropdown" id="contribGroupTutor1">
    <span>
     Marcelo Archanjo José
    </span>
   </a>
   <ul aria-labelledby="contribGrupoTutor1" class="dropdown-menu" role="menu">
    <strong>
    </strong>
    ,  São Paulo,  
          ,  SP,  
        ,  Universidade de São Paulo,  Escola Politécnica ,  Brasil
   </ul>
  </span>
  <span class="dropdown">
   <a class="dropdown-toggle" data-toggle="dropdown" id="contribGroupTutor2">
    <span>
     José Roberto Castilho Piqueira
    </span>
   </a>
   <ul aria-labelledby="contribGrupoTutor2" class="dropdown-menu" role="menu">
    <strong>
    </strong>
    ,  São Paulo,  
          ,  SP,  
        ,  Universidade de São Paulo,  Escola Politécnica ,  Brasil
   </ul>
  </span>
  <span class="dropdown">
   <a class="dropdown-toggle" data-toggle="dropdown" id="contribGroupTutor3">
    <span>
     Roseli de Deus Lopes
    </span>
   </a>
   <ul aria-labelledby="contribGrupoTutor3" class="dropdown-menu" role="menu">
    <strong>
    </strong>
    ,  São Paulo,  
          ,  SP,  
        ,  Universidade de São Paulo,  Escola Politécnica ,  Brasil
   </ul>
  </span>
  <a class="outlineFadeLink" data-target="#ModalTutors" data-toggle="modal" href="">
   Sobre os autores
  </a>
 </div>
 <div class="row">
  <ul class="col-md-2 hidden-sm articleMenu">
  </ul>
  <article class="col-md-10 col-md-offset-2 col-sm-12 col-sm-offset-0" id="articleText">
   <div class="articleSection" data-anchor="Resumos">
    <h1 class="articleSectionTitle">
     Resumos
    </h1>
   </div>
   <div>
    <p>
     Este trabalho apresenta uma visão geral sobre a programação quântica, de maneira acessível a alunos de graduação em Física. Inicia-se com um breve histórico sobre a computação quântica. São tratados os modelos que servem de base para a programação quântica, seguidos de descritivo resumido sobre as principais linguagens de programação quântica. Completando a apresentação, o funcionamento de um programa quântico é discutido, contextualizando-se a importância da programação, no âmbito da computação quântica.
    </p>
    <p>
     programação quântica; computação quântica; teoria quântica da informação
    </p>
   </div>
   <hr/>
   <div>
    <p>
     This work presents a general view about quantum programming, in an accessible way to undergraduate Physics students. It starts with a historical briefing about quantum computing. The basic mo deIs for quantum programming are treated, followed by the descriptions of the main quantum programming languages. Completing the presentation, it is discussed how a quantum program works, contextualizing how programming is important, concerning to quantum computation.
    </p>
    <p>
     quantum programming; quantum computation; quantum information theory
    </p>
   </div>
   <hr/>
   <div class="articleSection" data-anchor="Text">
    <p>
    </p>
    <p>
     <b>
      ARTIGOS GERAIS
     </b>
    </p>
    <p>
    </p>
    <p>
     <b>
      Introdução à programação quântica
     </b>
    </p>
    <p>
    </p>
    <p>
     <b>
      Introduction to quantum programming
     </b>
    </p>
    <p>
    </p>
    <p>
     Marcelo Archanjo José; José Roberto Castilho Piqueira
     <span class="ref footnote">
      <sup class="xref">
       <b>
        1
       </b>
      </sup>
      <span class="refCtt closed">
       <span class="refCttPadding">
        <strong class="fn-title">
         1
        </strong>
        E-mail: 
        piqueira@lac.usp.br.
       </span>
      </span>
     </span>
     ; Roseli de Deus Lopes
    </p>
    <p>
    </p>
    <p>
     Escola Politécnica, Universidade de São Paulo, São Paulo, SP, Brasil
    </p>
    <p>
    </p>
    <p>
     <b>
      RESUMO
     </b>
    </p>
    <p>
    </p>
    <p>
     Este trabalho apresenta uma visão geral sobre a programação quântica, de maneira acessível a alunos de graduação em Física. Inicia-se com um breve histórico sobre a computação quântica. São tratados os modelos que servem de base para a programação quântica, seguidos de descritivo resumido sobre as principais linguagens de programação quântica. Completando a apresentação, o funcionamento de um programa quântico é discutido, contextualizando-se a importância da programação, no âmbito da computação quântica.
    </p>
    <p>
    </p>
    <p>
     <b>
      Palavras-chave:
     </b>
     programação quântica, computação quântica, teoria quântica da informação.
    </p>
    <p>
    </p>
    <p>
     <b>
      ABSTRACT
     </b>
    </p>
    <p>
    </p>
    <p>
     This work presents a general view about quantum programming, in an accessible way to undergraduate Physics students. It starts with a historical briefing about quantum computing. The basic mo deIs for quantum programming are treated, followed by the descriptions of the main quantum programming languages. Completing the presentation, it is discussed how a quantum program works, contextualizing how programming is important, concerning to quantum computation.
    </p>
    <p>
    </p>
    <p>
     <b>
      Keywords:
     </b>
     quantum programming, quantum computation, quantum information theory.
    </p>
    <p>
    </p>
    <p>
     <b>
      1. Introdução
     </b>
    </p>
    <p>
    </p>
    <p>
     A programação de computadores é a base para explorar a capacidade disponibilizada pelo hardware. Quando se fala de computadores quânticos, logo se imagina como explorar suas capacidades, mas para isso é necessário programá-los.
    </p>
    <p>
    </p>
    <p>
     No computador clássico, os programadores não precisam compreender os fenômenos físicos que permeiam o funcionamento do mesmo, mas precisam compreender a lógica de utilização dos seus recursos, como memória, operações e comumcação.
    </p>
    <p>
    </p>
    <p>
     Diferentemente do computador clássico, no qual um bit pode assumir somente um de dois valores (O e 1), no computador quântico, o qubit possui os dois valores (O e 1) superpostos. Se o qubit for medido, seu valor irá colapsar para um dos dois valores. Sendo assim, não se pode medir o valor do qubit durante as operações, mas somente ao final dos processos.
    </p>
    <p>
    </p>
    <p>
     Com o computador quântico, um programador também não precisa compreender os fenômenos da física quântica para poder utilizar todo o seu poder, mas precisa compreender a lógica desse novo paradigma da computação. Esta nova lógica possui três etapas fundamentais:
    </p>
    <p>
    </p>
    <p>
     - preparação dos estados iniciais;
    </p>
    <p>
    </p>
    <p>
     - realização das transformações unitárias;
    </p>
    <p>
    </p>
    <p>
     - execução das medições.
    </p>
    <p>
    </p>
    <p>
     A preparação dos estados InICIaIS pode ser entendida como a carga dos valores de entrada. Qualquer operação necessita de algum tipo de carga de dados e, uma vez que os estados iniciais estão preparados, as transformações unitárias realizam o verdadeiro processamento do computador quântico. Ao final de todas as transformações, pode ser executada a medição.
    </p>
    <p>
    </p>
    <p>
     Essas três etapas são a base para a concepção dos computadores quânticos. Nielsen e Chuang [1] acrescentam que o computador quântico deve representar, de maneira robusta, a informação quântica. Essa característica traz uma grande dificuldade para a construção do computador quântico, um paradoxo entre duas restrições: o qubit deve ser suficientemente isolado para preservar a informação quântica e, ao mesmo tempo, deve permitir sua preparação e medição.
    </p>
    <p>
    </p>
    <p>
     Nielsen e Chuang [1] enunciam: "uma implementação (do computador quântico) deve resolver esse delicado balanço entre as duas restrições. Sendo assim, a questão relevante não é como fazer o computador quântico, mas sim, quão bom o computador quântico pode ser feito".
    </p>
    <p>
    </p>
    <p>
     Apesar dos computadores quânticos não estarem disponíveis para o público em geral, devido às dificuldades na sua implementação, avança-se no estudo de sua programação. Para isso, são necessanos modelos que representem seu funcionamento, servindo de base para a concepção das linguagens de programação, que visam explorar as potencialidades do computador quântico.
    </p>
    <p>
    </p>
    <p>
     <b>
      2. Histórico
     </b>
    </p>
    <p>
    </p>
    <p>
     Para entender a programação quântica, primeiramente é preciso conhecer como a mecânica quântica e a computação se relacionam e as suas consequências: a teoria quântica da informação e a computação quântica. Estes conceitos são encontrados em diversos artigos, [2-5].
    </p>
    <p>
    </p>
    <p>
     Em 1982 Richard Feynman [6] e Paul Benioff [7], independentemente, apresentaram o conceito da computação quântica. Feynman foi motivado pela simulação de sistemas quânticos, que é computacionalmente dispendiosa em computadores clássicos, teorizando que um sistema quântico deve ser simulado mais eficiente e naturalmente em um computador quântico. Benioff, por sua vez, apontou que a miniaturização dos circuitos integrados já apresentava efeitos espúrios relacionados à mecânica quântica, afetando assim o comportamento dos circuitos. Ele argumentou que aproveitar intencionalmente desses efeitos da mecânica quântica ajudaria a superar a barreira de miniaturização de circuitos integrados e estabeleceria novos patamares na computação.
    </p>
    <p>
    </p>
    <p>
     A ideia do computador quântico começou a tomar forma com David Deutsch em 1985 [8], que definiu a versão quântica da Máquina de Turing e de circuitos, demonstrando que o computador quântico seria capaz de realizar algumas tarefas de maneira mais eficiente que o computador clássico. Entretanto, os exemplos apresentados por ele, na ocasião, tinham aplicação limitada.
    </p>
    <p>
    </p>
    <p>
     Quase dez anos depois, Peter Shor [9] em 1994, apresentou provavelmente o mais conhecido exemplo da eficiência do computador quântico, no qual são descritos algoritmos para logaritmos discretos e fatoração. Demonstrou que a fatoração em computadores quânticos seria realizada de maneira muito mais eficiente do que no computador clássico, devido ao paralelismo quântico. Depois desse artigo, o interesse pela computação quântica aumentou muito, a fatoração, custosa em computadores clássicos, é utilizada como base para muitos algoritmos criptográficos (mais detalhes sobre a criptografia RSA são apresentados no artigo de Rivest, Shamir e Adleman de 1978 [10]). A comunidade científica passou, desde então, a se esforçar ainda mais para desenvolver o computador quântico, mas ainda não há versões funcionais fora de ambientes de pesquisa.
    </p>
    <p>
    </p>
    <p>
     <b>
      3. Conceitos básicos
     </b>
    </p>
    <p>
    </p>
    <p>
     Essa nova abordagem computacional que a mecânica quântica apresenta não é intuitiva e, muitas vezes parece estranha. Por exemplo, na mecânica quântica, a polarização de um fóton, ao ser medida, pode colapsar para uma de duas diferentes polarizações (com probabilidades α
     <sup>
      2
     </sup>
     e β
     <sup>
      2
     </sup>
     , respectivamente) [1]. A polarização do fóton é considerada como um estado quântico, pois os dois possíveis resultados, de fato, convivem simultaneamente até ser realizada a medida. Esse fato é representado matematicamente por meio da notação de Dirac, utilizando |
     <i>
      x
     </i>
     &gt; e |
     <i>
      y
     </i>
     &gt; (lê-se ket x e ket y) como representativos das polarizações do fóton.
    </p>
    <p>
    </p>
    <p>
     Isto é
    </p>
    <p>
    </p>
    <p>
     |ψ &gt;α|
     <i>
      x
     </i>
     &gt; + β|
     <i>
      y
     </i>
     &gt;, sendo |ψ &gt; o estado quântico do fáton.
    </p>
    <p>
    </p>
    <p>
     Essa forma da mecânica quântica tratar uma solução binária, considerando a superposição, oferece uma nova abordagem na computação. Em vez de termos o bit estático (computador clássico) temos o qubit (bit quântico) como a superposição dos dois estados (O e 1).
    </p>
    <p>
    </p>
    <p>
     Essa também é a base do paralelismo quântico, uma operação com um qubit de saída possui intrinsecamente os dois resultados. É claro que isso pode fazer parte de um programa em um computador clássico, mas a diferença é que, no computador quântico, os dois estados já estão naturalmente superpostos, o que, em principio, não parece muito importante, para um único qubit, porém quando a situação muda para múltiplos qubits, o benefício é exponencial.
    </p>
    <p>
    </p>
    <p>
     Outra implicação é que α e
     <i>
      β
     </i>
     podem assumir quaisquer valores complexos, desde que: |α|
     <sup>
      2
     </sup>
     +|
     <i>
      β
     </i>
     |
     <sup>
      2
     </sup>
     . Para ilustrar esse fato, pergunta-se: para duas variáveis de ponto flutuante, quantas informações estariam embutidas dentro de um único qubit?
    </p>
    <p>
    </p>
    <p>
     Percebe-se, entretanto, que no computador quântico essas "variáveis" de fato não ocupam espaço de memória (bytes), pois α e
     <i>
      β
     </i>
     são intrínsecos ao próprio qubit. Por outro lado, quando ocorre a medição, o qubit irá colapsar para um dos estados. Isso é um problema, uma vez que o grande valor da superposição e do paralelismo quântico é praticamente anulado na medição.
    </p>
    <p>
    </p>
    <p>
     A solução dessa questão [8, 11, 12] é realizar transformações unitárias que levem a uma seleção de resultados antes de realizar a medida. A ideia expressa nesse procedimento é explicável pelo fenômeno da interferência [13-16].
    </p>
    <p>
    </p>
    <p>
     Para compreender como a interferência quântica funciona [17], é importante notar que os estados quânticos não são meramente distribuições de probabilidade de valores binários, mas sim vetores complexos. Dessa forma, podemos utilizar a interferência quântica para destacar estados de interesse ou para anular estados desinteressantes.
    </p>
    <p>
    </p>
    <p>
     A implementação física do computador quântico apresenta, também, o entrelaçamento
     <i>
      (enianglemeni).
     </i>
     Segundo Omer [18] o registrador quântico que contém mais de um qubit não pode ser descrito como simples
    </p>
    <p>
    </p>
    <p>
     mente uma lista de estados de cada qubit. De fato, esse registrador quântico (um conjunto de qubits) não é separável. Essa característica é bem diferente do que ocorre no computador clássico, nos quais 2 bits em um computador têm o mesmo comportamento de 1 bit em 2 computadores compondo a mesma informação (com o devido tratamento para isso).
    </p>
    <p>
    </p>
    <p>
     Para esse mesmo exemplo, 2 qubits em um computador têm um comportamento diferente de 1 qubit em 2 computadores, tentando compor a mesma informação. Isso ocorre devido ao fato de que os qubits no mesmo computador quântico sofrem o efeito de entrelaçamento, isto é, o estado de um qubit interfere no estado do outro.
    </p>
    <p>
    </p>
    <p>
     Dois qubits individuais são representados matematicamente da seguinte forma
    </p>
    <p>
    </p>
    <p>
     |ψ
     <sub>
      1
     </sub>
     &gt;= α|0 &gt; +
     <i>
      b
     </i>
     |1 &gt;, |α|
     <sup>
      2
     </sup>
     + |
     <i>
      b
     </i>
     |
     <sup>
      2
     </sup>
     = 1;
    </p>
    <p>
    </p>
    <p>
     |ψ
     <sub>
      1
     </sub>
     &gt;=
     <i>
      c
     </i>
     |0 &gt; +
     <i>
      d
     </i>
     |1 &gt;, |
     <i>
      c
     </i>
     |
     <sup>
      2
     </sup>
     + |
     <i>
      d
     </i>
     |
     <sup>
      2
     </sup>
     = 1;
    </p>
    <p>
    </p>
    <p>
     Pode-se considerar que os qubits descritos por |ψ
     <sub>
      1
     </sub>
     &gt; e |ψ
     <sub>
      2
     </sub>
     &gt; estão localizados em computadores diferentes.
    </p>
    <p>
    </p>
    <p>
     Dois qubits juntos são representados da seguinte forma
    </p>
    <p>
    </p>
    <p>
     |ψ
     <sub>
      3
     </sub>
     &gt;= e |0,0 &gt; +ƒ|1,0 &gt;
     <i>
      + g|O,1
     </i>
     &gt; +
     <i>
      g
     </i>
     |0,1 &gt; +
     <i>
      h
     </i>
     |1,1 &gt;, com |e|
     <sup>
      2
     </sup>
     + |f|
     <sup>
      2
     </sup>
     + |g|
     <sup>
      2
     </sup>
     + |h|
     <sup>
      2
     </sup>
     = 1.
    </p>
    <p>
    </p>
    <p>
     Esses dois qubits estão sob o efeito de entrelaçamento podendo ser considerarados como localizados no mesmo computador.
    </p>
    <p>
    </p>
    <p>
     Por exemplo, se |h|
     <sup>
      2
     </sup>
     é muito pequeno (probabilidade de ocorrer |1,1 &gt;), isto não define as outras probabilidades (|e|
     <sup>
      2
     </sup>
     , |f|
     <sup>
      2
     </sup>
     , |g|
     <sup>
      2
     </sup>
     ). Porém, se |b|
     <sup>
      2
     </sup>
     e |d|
     <sup>
      2
     </sup>
     também são pequenos (probabilidades de ocorrer |1 &gt; e |1 &gt;) |a|
     <sup>
      2
     </sup>
     e |c|
     <sup>
      2
     </sup>
     deverão ser necessariamente grandes. Isto é, ao definir b e d são automaticamente definidos a e c. Sendo assim, fica claro que a, b, c, d não são respectivamente iguais e, f, g, h (para este exemplo), demonstrando que dois qubits no mesmo computador quântico não podem ser representados por dois qubits em dois computadores diferentes.
    </p>
    <p>
    </p>
    <p>
     Outra característica importante na computação quântica é o teorema da impossibilidade de cópia
     <i>
      (noncloning theorem).
     </i>
     Num computador clássico, um bit pode ser copiado, mas no computador quântico, isso não é possível. De uma forma simplificada, é necessário ter acesso ao dado para copiá-lo, mas, ao medir um qubit ele irá colapsar para um dos possíveis resultados, o que inviabiliza sua cópia. O enunciado e a demonstração detalhada da impossibilidade de cópia podem ser encontrados nas Refs. [19-23]
    </p>
    <p>
    </p>
    <p>
     Um componente essencial dos computadores clássicos são as portas lógicas, "em um computador quântico o processo é similar, ou seja, pode-se construir (teoricamente) circuitos quânticos, que são agrupamentos de dispositivos mais simples chamados portas quânticas" [12]. Uma porta quântica que possui uma importância especial é a porta NOT-controlada (ou simplesmente CNOT),
     <a class="open-asset-modal" data-target="#ModalFigfig1" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      Fig. 1
     </a>
     , pois ela permite a criação de estados quânticos entrelaçados, uteis nos programas quânticos [4, 24].
    </p>
    <div class="row fig" id="fig1">
     <a name="fig1">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigfig1" data-toggle="modal" href="">
       <div class="thumbOff">
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <br/>
     </div>
    </div>
    <p>
    </p>
    <p>
     Enquanto não há computadores quânticos de uso geral, para avaliar seus potenciais pode-se conhecer e estudar a programação quântica e constatar a eficiência que determinados algoritmos teriam ao serem implementados em computadores quânticos [9, 25, 26].
    </p>
    <p>
    </p>
    <p>
     Da mesma forma que antes da computação clássica ser estabelecida, foi possível simular seu funcionamento pelo modelo matemático da máquina de Turing, de maneira análoga, uma "máquina de Turing" quântica [8, 25] pode ser concebida. Isto é, uma simulação do que seria o comportamento de um computador quântico.
    </p>
    <p>
    </p>
    <p>
     Nesse sentido, os computadores clássicos podem simular o computador quântico e, dessa forma, estabelecer o ambiente básico para o desenvolvimento de linguagens de programação e algoritmos próprios para o computador quântico, fomentando assim a programação quântica.
    </p>
    <p>
    </p>
    <p>
     <b>
      4. Programação quântica em computadores clássicos
     </b>
    </p>
    <p>
    </p>
    <p>
     A programação quântica em computadores clássicos é uma área bastante ativa e existe muita informação disponível a respeito. Três artigos relevantes são referência nos estudos dessa área: Sofge em 2008 [5], Gay em 2006 [2] e Selinger em 2004 [3]. Também a tese de Grattage em 2006 [4] apresenta descrições claras e objetivas.
    </p>
    <p>
    </p>
    <p>
     A programação de computadores precisa ser realizada com o conhecimento da plataforma. Isto é, um programa clássico concebido para um processador Intel Pentium não funcionará diretamente em um processador ARM. Porém, é possível emular uma plataforma em outra. Por exemplo, é comum o desenvolvimento de programas para celulares utilizando PCs com emuladores correspondentes. É claro que o desempenho de um emulador tende a ser menor do que o próprio processador (com exceção do processador emulado ser muitas vezes inferior que o processador utilizado para emular). Especialmente no caso da emulação do computador quântico, três modelos de hardware virtual [3] que podem ser considerados equivalentes (pelo menos em teoria) merecem destaque:
    </p>
    <div>
     <blockquote>
      <p>
        Modelo de Circuito Quântico -feito com portas quânticas da mesma maneira que um circuito lógico clássico. A diferença é que as portas quânticas, ao contrário das clássicas, são sempre reversíveis.
      </p>
      <p>
        Modelo da Máquina de Thring Quântica [8] -as medidas nunca são realizadas e a operação inteira da máquina é assumida como unitária.
      </p>
      <p>
        Modelo QRAM
       <i>
        (Quantum Random Access M achine)
       </i>
       [27] -diferentemente do modelo de circuito quântico, o modelo QRAM permite transformações unitárias e medidas serem livremente intercaladaE. No modelo QRAM, um dispositivo quântico é controlado por um computador clássico. Esse dispositivo possui um enorme (mas finito) número de qubits individuais e endereçáveis, muito parecido com a memória RAM
       <i>
        (Random Access Memory).
       </i>
       O computador clássico envia uma sequência de instruções, às quais pode-se "aplicar uma transformação unitária U com os qubits i e j" ou "medir o qubit i". O dispositivo quântico executa essas instruções e disponibiliza os resultados. Esse modelo foi construído com a premissa de que o computador quântico real será, de fato, um computador clássico com acesso a componentes da computação quântica [5]. DiversaE linguagens de programação quânticas usam o modelo QRAM.
      </p>
     </blockquote>
    </div>
    <p>
    </p>
    <p>
     As linguagens de programação quântica são classificadaE pela literatura [2, 3, 5] como: linguagens imperativas, linguagens funcionais e outros paradigmas.
    </p>
    <p>
    </p>
    <p>
     <b>
      4.1. Linguagens imperativas
     </b>
    </p>
    <p>
    </p>
    <p>
     As linguagens imperativas também são conhecidas como linguagens procedurais. Elas são constituídas pelo uso de declarações que mudam o estado global do programa ou variáveis do sistema [5]. Exemplos de linguagens imperativaE clá.ssicaE são FORTRAN, PaEcal, C e Java. As linguagens imperativas são as mais utilizadas atualmente.
    </p>
    <p>
    </p>
    <p>
     As linguagens imperativas de programação quântica são derivadaE do trabalho de Knill [27], que, em 1996, apresentou as convenções para a escrita de algoritmos quânticos em pseudocódigo.
    </p>
    <p>
    </p>
    <p>
     QCL de Bernhard Omer [17, 18, 28 , 29] foi a primeira linguagem de programação quântica real, apresentada em 1998, utilizando uma sintaxe derivada da linguagem C e provendo um simulador para o desenvolvimento e teste do código em um computador clássico. Suporta a visão do modelo de hardware virtual QRAM, no qual o computador clássico convive com o quântico (
     <a class="open-asset-modal" data-target="#ModalFigfig2" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      Fig. 2
     </a>
     ). Contém uma completa linguagem de programação clássica como uma sub-linguagem e provê um conjunto útil de funções de programação quântica de alto nível, como o gerenciamento de memória [2].
    </p>
    <div class="row fig" id="fig2">
     <a name="fig2">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigfig2" data-toggle="modal" href="">
       <div class="thumbOff">
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <br/>
     </div>
    </div>
    <p>
    </p>
    <p>
     Sanders e Zuliani [29], em 2000, e posteriormente Zuliani [30-32] apresentaram a qGCL, que é baEeada na linguagem de comandos de Dijkstra. A qGCL é muito mais uma especificação de linguagem do que uma linguagem de programação.
    </p>
    <p>
    </p>
    <p>
     Betteli, Calarco e Serafini [33], em 2003, apresentaram uma linguagem baEeada em
     <i>
      C++
     </i>
     chamada Q (existe outra linguagem Q -eQuation mais conhecida e não correlata), que possui classes importantes como QHadamard, QFourier, QNot, Qswap e Qop. Como recurso adicional, a linguagem possui parâmetros para a simulação de ruído.
    </p>
    <p>
    </p>
    <p>
     Em 2004, Tafliovich [34] definiu uma linguagem de programação quântica que possui uma forte conexão entre os programas e as especificações. É focada na metodologia de programação, na qual o desenvolvimento dos programas é feito em pequenas etapas, e somente avança quando a etapa provar eficiência
    </p>
    <p>
    </p>
    <p>
     Em 2007, Mlnarik [35] apresentou uma linguagem chamada LanQ que possui uma sintaxe similar à linguagem C, tratando tanto de operações clássicas como quânticas, oferecendo também ferramentas para a comunicação e execução de programas em paralelo.
    </p>
    <p>
    </p>
    <p>
     <b>
      4.2. Linguagens funcionais
     </b>
    </p>
    <p>
    </p>
    <p>
     Linguagens funcionais utilizam um tipo de paradigma para programação de computadores em que o foco das funções é puramente nas entradas e saídas, tal qual ocorre na Matemática, em oposição às linguagens imperativas que alteram estados e dados. APL e Lisp são exemplos de linguagens funcionais clássicas.
    </p>
    <p>
    </p>
    <p>
     Maymin [36] apresentou, em 1996, um cálculo lambda com um foco probabilístico e outro quântico. Em 1997 [37], ele destaca que o cálculo lambda quântico pode simular de maneira eficiente um autômato celular quântico, particionado em uma dimensão.
    </p>
    <p>
    </p>
    <p>
     Como Selinger descreve no artigo [3] de 2004, a linguagem QFC
     <i>
      (Quantum Flow Chans)
     </i>
     foi a primeira proposta de uma linguagem funcional quântica. Ela foi apresentada em detalhes no artigo [38], também em 2004. Na QFC, os programas são feitos por meio de uma versão funcional de
     <i>
      fiowcharts,
     </i>
     mas também possui uma versão alternativa baseada em texto: a QPL
     <i>
      (Quantum Programming Language).
     </i>
    </p>
    <p>
    </p>
    <p>
     Tanto medidas quanto operações unitárias são realizadas diretamente pela linguagem de uma maneira que evita erros de escrita. Foram integradas com o mesmo formalismo, tanto as características clássicas quanto as quânticas. A linguagem é compilada dentro do modelo QRAM.
    </p>
    <p>
    </p>
    <p>
     Van Tonder [39], em 2004, apresentou um cálculo lambda quântico, cuja linguagem é puramente quântica e não trata medidas.
    </p>
    <p>
    </p>
    <p>
     Altenkirch e Grattage [4, 40, 41], em 2005, apresentaram uma linguagem chamada QML, que trata tanto controles quânticos quanto dados quânticos. A QML é baseada em lógica linear e, ao invés de realizar cópia dos estados quânticos (que não é possível, pela impossibilidade de cópia), realiza operações com portas CNOT, visando o compartilhamento. A QML também apresenta um
     <i>
      if
     </i>
     que analisa o dado quântico sem medi-lo.
    </p>
    <p>
    </p>
    <p>
     Em 2011, Ying e Feng [42] demonstraram a relação entre programas quânticos escritos em linguagens de programação de baixo e alto nível. A linguagem
     <i>
      fiowchari
     </i>
     de baixo nível apresentada trata dados quânticos, mas os controles são clássicos, o que é compatível com o modelo QRAM.
    </p>
    <p>
    </p>
    <p>
     Outros trabalhos relacionados à linguagem de programação quântica funcional, destacados por [5] foram apresentados por:
    </p>
    <div>
     <blockquote>
      <p>
        Danos e cols. [43] em 2005 - Apresentaram estudo de um modelo de computação quântica não reversível que também apresenta notação para entrelaçamento, medidas e correções locais;
      </p>
      <p>
        Perdrix [44] em 2005 -Definiu um tipo de sistema que reflete o entrelaçamento de estados quântico, baseado em cálculo lambda;
      </p>
      <p>
        Mu e Bird [45] em 2001 -Programação quântica modelada em Haskell (mais informações em
       <a href="http://www.haskell.org/" target="_blank">
        http://www.haskell.org/
       </a>
       ), por meio da definição de um tipo de dado para registradores quânticos.
      </p>
      <p>
        Sabryem [46] 2003 -Sabry ampliou o modelo de Mu e Brid incluindo a representação de estados em entrelaçamento. Outros esforços relacionados a esta linha foram realizados por Vizzotto e Da Rocha Costa [47] em 2005, Karczmarczuk [48] em 2003 e Skibinski [49] em 2001.
      </p>
     </blockquote>
    </div>
    <p>
    </p>
    <p>
     <b>
      4.3. Outros paradigmas de programação
     </b>
    </p>
    <p>
    </p>
    <p>
     Segundo Sofge [5], há outras abordagens que agem de uma forma bastante diferente no sentido de realizar a programação quântica. Freedman, Kitaev e Wong [50], em 2000, apresentaram a simulação de
     <i>
      iopological quantum field theories
     </i>
     (TQFT's) para computação quântica. TQFT é um modelo mais robusto na computação quântica, por representar estados quânticos como sistemas físicos resistentes a perturbações.
    </p>
    <p>
    </p>
    <p>
     Operações quânticas são determinadas a partir de propriedades topológicas globais, como por exemplo, os caminhos seguidos por partículas. Essa abordagem, bem diferente para a computação quântica pode promover novas ideias e fomentar a criação de novos algoritmos quânticos.
    </p>
    <p>
    </p>
    <p>
     Em contrapartida, da maneira que está formulada, somente trata a evolução do estado e não trata o processo de medida. Atualmente, vários trabalhos foram desenvolvidos com o intuito de definir linguagens para suportar protocolos de criptografia quântica e, especialmente, tratar a inclusão da comunicação entre processos quânticos, sendo que esses processos podem ser locais ou remotos, originando a especificação da programação quântica distribuída. Os trabalhos que seguem merecem destaque nesta linha:
    </p>
    <div>
     <blockquote>
      <p>
        Mauerer [51] em 2005 cQPL -Linguagen baseada na QPL, mas com extensões envolvendo comunicação entre processos distribuídos;
      </p>
      <p>
        Jorrand e Lalire [52] em 2005 QPAlg
       <i>
        (Quantum Process Algebra)
       </i>
       -Descreve interações entre processos quânticos e clássicos;
      </p>
      <p>
        Gay e Nagarajan [53] em 2005 CQP
       <i>
        (Communicaiing Quanium Processes)
       </i>
       -Linguagem para modelagem da comunicação de sistemas clássicos e quânticos com enfase na criptografia quântica;
      </p>
      <p>
        Adão e Mateus [54] em 2005 -Desenvolveram o processo de cálculo para protocolos seguros feito sobre o modelo computacional QRAM;
      </p>
      <p>
        Udrescu, Prodan e Vlâdutiu [55] em 2004 -Criaram uma linguagem descritiva de hardware para o desenvolvimento de circuitos quânticos (similar ao VLSI).
      </p>
     </blockquote>
    </div>
    <p>
    </p>
    <p>
     A
     <a class="open-asset-modal" data-target="#ModalTabletab1" data-toggle="modal" href="">
      <span class="sci-ico-fileTable">
      </span>
      Tabela 1
     </a>
     apresenta de maneira concisa as principais linguagens de programação quântica.
    </p>
    <div class="row table" id="tab1">
     <a name="tab1">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalTabletab1" data-toggle="modal">
       <div class="thumbOff">
        Thumbnail
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <br/>
     </div>
    </div>
    <p>
    </p>
    <p>
     <b>
      5. Exemplo de programa quântico para execução em computadores clássicos
     </b>
    </p>
    <p>
    </p>
    <p>
     É importante apresentar as características de um programa quântico. Para isso, foi escolhida a linguagem QCL, que é uma linguagem imperativa (procedural) porque hoje (nos computadores clássicos), as principais linguagens de programação são imperativas, como
     <i>
      CjC++,
     </i>
     Java. É claro que não há garantias de que este paradigma será o mais eficiente no computador quântico, mas ao considerarmos o modelo QRAM, que pressupõe a convivência do computador clássico e do quântico, há uma indicação lógica da importância das linguagens imperativas. Nessa linha, a linguagem QCL é uma referência na literatura, inclusive para novas linguagens como a LanQ.
    </p>
    <p>
    </p>
    <p>
     Um programa em QCL segue o tipo de fluxo apresentado na
     <a class="open-asset-modal" data-target="#ModalFigfig3" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      Fig. 3
     </a>
     .
    </p>
    <div class="row fig" id="fig3">
     <a name="fig3">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigfig3" data-toggle="modal" href="">
       <div class="thumbOff">
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <br/>
     </div>
    </div>
    <p>
    </p>
    <p>
     O algoritmo de Deutsch, descrito detalhadamente na Ref. [8], implementado em QCL, está descrito abaixo (deutsch.qcl):
    </p>
    <p>
    </p>
    <p>
    </p>
    <div class="row fig" id="8ff1ba70ee4364ec9bbd4c1bcf7675ac16bc2fd8">
     <a name="8ff1ba70ee4364ec9bbd4c1bcf7675ac16bc2fd8">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalImg8ff1ba70ee4364ec9bbd4c1bcf7675ac16bc2fd8" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/fXHgBXQHqmzf7kJ6CskyjYx/8ff1ba70ee4364ec9bbd4c1bcf7675ac16bc2fd8.jpg" style="max-width:100%"/>
       </div>
      </a>
     </div>
    </div>
    <p>
    </p>
    <p>
     Para analisar o código acima, deve-se ter em conta os seguintes pontos:
    </p>
    <p>
    </p>
    <p>
     // : trata-se de comentário: o texto à direita das duas barras não tem efeito no funcionamento do código;
    </p>
    <p>
    </p>
    <p>
     /* */: trata-se também de comentário; o texto entre /* e * / não tem efeito no funcionamento do código.
    </p>
    <p>
    </p>
    <p>
     Para explicar o funcionamento do programa quântico, realizar-se-á uma comparação com a descrição matemática do algoritmo de Deutsch [8] descrito por Omer [171:
    </p>
    <p>
    </p>
    <p>
     1. O ponto inicial do programa é na
     <i>
      procedure deutsch()
     </i>
    </p>
    <p>
    </p>
    <p>
     2 Preparação do estado inicial vazio
    </p>
    <p>
    </p>
    <p>
    </p>
    <div class="row fig" id="378ee02db51893b33d5846518bc3d2033c21053f">
     <a name="378ee02db51893b33d5846518bc3d2033c21053f">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalImg378ee02db51893b33d5846518bc3d2033c21053f" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/fXHgBXQHqmzf7kJ6CskyjYx/378ee02db51893b33d5846518bc3d2033c21053f.jpg" style="max-width:100%"/>
       </div>
      </a>
     </div>
    </div>
    <p>
    </p>
    <p>
     Alocação do qubit x:
     <i>
      qureg x[1};
     </i>
    </p>
    <p>
    </p>
    <p>
     Alocação do qubit y:
     <i>
      qureg y[1};
     </i>
    </p>
    <p>
    </p>
    <p>
     Preparação dos estados iniciais vazios:
     <i>
      reseií
     </i>
    </p>
    <p>
    </p>
    <p>
     3 Aplica-se a transformação de Hadamard H(x)
    </p>
    <p>
    </p>
    <p>
    </p>
    <div class="row fig" id="cdded1e548a62600336ee6d1fd00e3ecfd09cbf5">
     <a name="cdded1e548a62600336ee6d1fd00e3ecfd09cbf5">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalImgcdded1e548a62600336ee6d1fd00e3ecfd09cbf5" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/fXHgBXQHqmzf7kJ6CskyjYx/cdded1e548a62600336ee6d1fd00e3ecfd09cbf5.jpg" style="max-width:100%"/>
       </div>
      </a>
     </div>
    </div>
    <p>
    </p>
    <p>
     Dentro da sequência de execução quântica do programa, é chamado o operador
     <i>
      U(x,y);que
     </i>
     é responsável pelas operações unitárias, sendo que a primeira delas é
     <i>
      H(x);
     </i>
     aplicando a transformação de Hadamard no qubit x.
    </p>
    <p>
    </p>
    <p>
     4 Aplica o operador Oráculo G
    </p>
    <p>
    </p>
    <p>
    </p>
    <div class="row fig" id="164570eccd5a8d930b9ff60a8d1a40b0f8c468e5">
     <a name="164570eccd5a8d930b9ff60a8d1a40b0f8c468e5">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalImg164570eccd5a8d930b9ff60a8d1a40b0f8c468e5" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/fXHgBXQHqmzf7kJ6CskyjYx/164570eccd5a8d930b9ff60a8d1a40b0f8c468e5.jpg" style="max-width:100%"/>
       </div>
      </a>
     </div>
    </div>
    <p>
    </p>
    <p>
     Ainda dentro do operador
     <i>
      U(x,y);
     </i>
     há a chamada da função quântica
     <i>
      G(x, y);
     </i>
    </p>
    <p>
    </p>
    <p>
     5 Aplica H(x o y), resultando em
    </p>
    <p>
    </p>
    <p>
    </p>
    <div class="row fig" id="4f0982e072679a10ac680d450921615b8eb92f3d">
     <a name="4f0982e072679a10ac680d450921615b8eb92f3d">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalImg4f0982e072679a10ac680d450921615b8eb92f3d" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/fXHgBXQHqmzf7kJ6CskyjYx/4f0982e072679a10ac680d450921615b8eb92f3d.jpg" style="max-width:100%"/>
       </div>
      </a>
     </div>
    </div>
    <p>
    </p>
    <p>
     Ainda dentro do operador
     <i>
      U(x,y);
     </i>
     obtém-se H(x
     <img src="https://minio.scielo.br/documentstore/1806-9126/fXHgBXQHqmzf7kJ6CskyjYx/acdce27e76d0d0624525c114f239602bf3fa1ed6.jpg" style="max-width:100%"/>
     y);
    </p>
    <p>
    </p>
    <p>
     6 Uma vez terminado o processamento do operador
     <i>
      U(x, y);
     </i>
     a execução do programa volta para a
     <i>
      procedure deutsch()
     </i>
     na qual é realizada a Medida de "x" e "y" pela ação de
     <i>
      measure y,
     </i>
     m; e
     <i>
      measure x,m;
     </i>
    </p>
    <p>
    </p>
    <p>
     Para chamar a
     <i>
      procedure deuisch()
     </i>
     é necessário criar um programa simples, para isso cria-se um arquivo chamado my.qcl com o seguinte conteúdo:
    </p>
    <p>
    </p>
    <p>
     <i>
      include "deuisch";
     </i>
    </p>
    <p>
    </p>
    <p>
     <i>
      deutsch();
     </i>
    </p>
    <p>
    </p>
    <p>
     E para que este programa apresente seus resultados, a partir do Terminal (no diretório onde está my.qcl), deve-se executar:
    </p>
    <p>
    </p>
    <p>
     qcl my.qcl
    </p>
    <p>
    </p>
    <p>
     O resultado apresentado pode ser, aleatoriamente, um destes:
    </p>
    <p>
    </p>
    <p>
     <i>
      QCL Quantum Computation Language
     </i>
     (64
     <i>
      qubits, seed 1289349674) :
     </i>
    </p>
    <p>
    </p>
    <p>
     <i>
      g(0) xor g(1)
     </i>
     =0
    </p>
    <p>
    </p>
    <p>
     <i>
      QCL Quantum Computation Language
     </i>
     (64
     <i>
      qubits, seed 1289349831) :
     </i>
    </p>
    <p>
    </p>
    <p>
     <i>
      g(0) xor g(l)
     </i>
     ~ 1
    </p>
    <p>
    </p>
    <p>
     "0" e "1" são os dois possíveis resultados do algoritmo de Deutsch.
    </p>
    <p>
    </p>
    <p>
     <b>
      6. Instalação do QCL
     </b>
    </p>
    <p>
    </p>
    <p>
     Para a execução de qualquer o programa na linguagem QCL, é preciso primeiramente instalar os binários do QCL. Sua distribuição pode ser encontrada em
     <a href="http://tph.tuwien.ac.at/-oemer/qcl.html" target="_blank">
      http://tph.tuwien.ac.at/-oemer/qcl.html
     </a>
     .
    </p>
    <p>
    </p>
    <p>
     Especificamente, no caso aqui descrito, foi utilizada a Binary Distribution (64 bit): qcl-0.6.3-x86_64-linux (AMD64, Linux 2.6, glibc2.4) que foi instalada em um Linux Ubuntu 10.04 de 64 bits. Caso seja necessário repetir este processo, seguem algumas recomendações importantes:
    </p>
    <div>
     <blockquote>
      <p>
        ler o arquivo README da distribuição do QCL que for utilizar;
      </p>
      <p>
        especificamente no Linux Ubuntu 10.04 de 64 bits, instalar, por meio do Synaptics, os seguintes pacotes, antes de instalar o QCL:
      </p>
      <p>
        libplot
      </p>
      <p>
        flex
      </p>
      <p>
        bison
      </p>
      <p>
        readline5
      </p>
     </blockquote>
    </div>
    <p>
    </p>
    <p>
     Após a instalação com sucesso do QCL, já é possível executar os exemplos contidos no diretório: /usr/local/lib/qcl/
    </p>
    <p>
    </p>
    <p>
     Para executar um teste da instalação, basta executar o comando:
    </p>
    <p>
    </p>
    <p>
     qcl tesl.qcl
    </p>
    <p>
    </p>
    <p>
     Aparecendo resultados semelhantes aos seguintes:
    </p>
    <p>
    </p>
    <p>
    </p>
    <div class="row fig" id="aa3ab7251576e75d06e76468c6adc0907c1b1695">
     <a name="aa3ab7251576e75d06e76468c6adc0907c1b1695">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalImgaa3ab7251576e75d06e76468c6adc0907c1b1695" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/fXHgBXQHqmzf7kJ6CskyjYx/aa3ab7251576e75d06e76468c6adc0907c1b1695.jpg" style="max-width:100%"/>
       </div>
      </a>
     </div>
    </div>
    <p>
    </p>
    <p>
     <b>
      7. Conclusões
     </b>
    </p>
    <p>
    </p>
    <p>
     Conceitos da programação quântica foram apresentados, especialmente ilustrando como um programa quântico pode ser emulado em um computador clássico. Este é um campo bastante amplo e com muita informação. Entre as referências que foram utilizadas, algumas merecem um destaque especial. Orner [17] tem um trabalho bastante completo e apresenta descrições muito didáticas sobre questões importantes da programação quântica. Cabral e cols. [12] apresentam o algoritmo de Deutsch de maneira bastante didática.
    </p>
    <p>
    </p>
    <p>
     É importante ter em mente que a mecânica quântica apresenta conceitos não intuitivos e surpreendentes, mas é necessário compreender que a utilização desses conceitos nas diversas áreas do conhecimento pode trazer benefícios igualmente surpreendentes.
    </p>
    <p>
    </p>
    <p>
     Recebido em 19/5/2012
    </p>
    <p>
    </p>
    <p>
     Aceito em 23/6/2012
    </p>
    <p>
    </p>
    <p>
     Publicado em 18/2/2013
    </p>
    <p>
    </p>
    <p>
    </p>
    <li>
     <span class="xref big">
      1
     </span>
     <div>
      E-mail:
     </div>
     <div>
      <a href="mailto:piqueira@lac.usp.br">
       piqueira@lac.usp.br
      </a>
      .
     </div>
    </li>
   </div>
   <div>
    <h1>
    </h1>
    <div class="ref-list">
     <ul class="refList">
      <li>
       <div>
        [1] M.A. Nielsen and LL. Chuang,
        <i>
         Quantum Computation and Quantum Information
        </i>
        (Cambridge University Press, New York, 20(0).
       </div>
      </li>
      <li>
       <div>
        [2] S. J. Gay, Mathematical Structures in Computer Science,
        <b>
         16
        </b>
        , 581 (2006).
       </div>
      </li>
      <li>
       <div>
        [3] P. Selinger, in:
        <i>
         Proceedings of the 7th International Symposium
        </i>
        on
        <i>
         Functional and Logic Programming,
        </i>
        v. 2998 of Lecture Notes in Computer Science (Springer, Berlin, 2004a).
       </div>
      </li>
      <li>
       <div>
        [4] J.J. Grattage,
        <i>
         A Functional Quantum Programming Language.
        </i>
        PhD thesis, The University of Nottingham 2006, disponível em http://etheses.nottingham.ac.uk/250/1/thesis.pdf, consultado em 14/10/2012.
       </div>
      </li>
      <li>
       <div>
        [5] D.A. Sofge, in
        <i>
         Second International Conference
        </i>
        on
        <i>
         Quantum, Nano and Micro Technologies
        </i>
        (IEEE Computer Society Press, Sainte Luce, Martinique 2(08).
       </div>
      </li>
      <li>
       <div>
        [6] R.P. Feynman, International Journal of Theoretical Physics
        <b>
         21
        </b>
        ,467 (1982).
       </div>
      </li>
      <li>
       <div>
        [7] P. Benioff, Physics Review Letters
        <b>
         48
        </b>
        ,1581 (1982).
       </div>
      </li>
      <li>
       <div>
        [8] D. Deutsch, Proceedings of the Royal Society of London A
        <b>
         400
        </b>
        ,97 (1985).
       </div>
      </li>
      <li>
       <div>
        [9] P. Shor, in
        <i>
         Proceedings of the 35th IEEE FOCS
        </i>
        (IEEE Computer Society Press, Santa Fé, México, 1994), p. 124-134, disponível em http://ieeexplore.ieee.org/xpl/tocresult.j sp?isnumber=8384, consultado em 14/10/2012.
       </div>
      </li>
      <li>
       <div>
        [10] R.L. Rivest, Communications of the ACM
        <b>
         21
        </b>
        ,120 (1978).
       </div>
      </li>
      <li>
       <div>
        [11] D. Deutsch and R. Jozsa, Proc. Roy. Soco London, Ser. A
        <b>
         439
        </b>
        ,553 (1992).
       </div>
      </li>
      <li>
       <div>
        [12] G.E.M. Cabral, A.F. Lima and B. Lula Jr.. Junior, Revista Brasileira de Ensino de Física
        <b>
         26
        </b>
        ,109 (2004).
       </div>
      </li>
      <li>
       <div>
        [13] O. Pessoa Jr., Cadernos de História e Filosofia da Ciência Série 3
        <b>
         2
        </b>
        ,177 (1992).
       </div>
      </li>
      <li>
       <div>
        [14] O. Pessoa Jr., Revista Brasileira de Ensino de Física
        <b>
         19
        </b>
        ,27 (1997).
       </div>
      </li>
      <li>
       <div>
        [15] O. Pessoa Jr.,
        <i>
         Conceitos de Física Quântica
        </i>
        (Livraria da Física, São Paulo, 2003).
       </div>
      </li>
      <li>
       <div>
        [16] F. Ostermann, Revista Brasileira de Ensino de Física
        <b>
         27
        </b>
        ,193 (2005).
       </div>
      </li>
      <li>
       <div>
        [17] B. Omer,
        <i>
         Structured QuantumProgmmming.
        </i>
        PhD thesis, Technical University of Vienna, 2003.
       </div>
      </li>
      <li>
       <div>
        [18] B. Omer,
        <i>
         A Proceduml Formalism for Quantum Computing.
        </i>
        Master thesis, Technical University of Vienna, 1998.
       </div>
      </li>
      <li>
       <div>
        [19] J.R.C. Piqueira, Revista Brasileira de Ensino de Física
        <b>
         33
        </b>
        , 4303 (2011).
       </div>
      </li>
      <li>
       <div>
        [20] M. Hirvensalo,
        <i>
         Quantum Computing
        </i>
        (Springer, Berlin, 2001).
       </div>
      </li>
      <li>
       <div>
        [21] G. Jaeger,
        <i>
         Quantum Information: An Overview
        </i>
        (Springer, New York, 2007).
       </div>
      </li>
      <li>
       <div>
        [22] V. Vedral,
        <i>
         Introduction to Quantum Information
        </i>
        (Oxford University Press, Oxford, 2006).
       </div>
      </li>
      <li>
       <div>
        [23] E. Desurvire,
        <i>
         Classical and Quantum Information Theory: An Introduction for the Telecom Scientist
        </i>
        (Cambridge University Press, Cambridge, 2(09).
       </div>
      </li>
      <li>
       <div>
        [24] P. Arrighi and G. Dowek,
        <i>
         Proceedings of the International Workshop
        </i>
        on
        <i>
         Quantum Programming Languages
        </i>
        (IEEE Computer Society Press, Turku, Finland, 2004), p.21-38.
       </div>
      </li>
      <li>
       <div>
        [25] C.A. Lungarzo, Cienc. Culto
        <b>
         55
        </b>
        ,4 (2003).
       </div>
      </li>
      <li>
       <div>
        [26] W.V. Dam and G. Seroussi, Report Number: HPL2002-208 (University of California at Berkley, 2002).
       </div>
      </li>
      <li>
       <div>
        [27] E. Knill, Technical Report LAUR-95-2724 (Los Alamos National Laboratory, Los Alamos, 1996).
       </div>
      </li>
      <li>
       <div>
        [28] B. Omer,
        <i>
         Quantum Programming
        </i>
        in
        <i>
         QCL.
        </i>
        Master's thesis, Technical University of Vienna, 2000.
       </div>
      </li>
      <li>
       <div>
        [29] J.W.Sanders and P. Zuliani, in
        <i>
         Mathematics of Program Construction,
        </i>
        volume 1837 of Lecture Notes in Computer Science (Springer, Berlin, 2000).
       </div>
      </li>
      <li>
       <div>
        [30] P. Zuliani, IBM J. Research and Development
        <b>
         45
        </b>
        ,807 (2001).
       </div>
      </li>
      <li>
       <div>
        [31] P. Zuliani, in
        <i>
         Proceedings of the 2nd International Workshop on Quantum Programming Languages,
        </i>
        (IEEE Computer Society Press, Turku, Finland, 2004), p. 179-195.
       </div>
      </li>
      <li>
       <div>
        [32] P. Zuliani, in
        <i>
         Proceedings of the 3rd International Workshop on Quantum Programming Languages
        </i>
        (IEEE Computer Society Press, Chicago, Illinois, 2005), p. 169-179.
       </div>
      </li>
      <li>
       <div>
        [33] S. Bettelli, T. Calarco and L. Serafini, The European Physical Journal D
        <b>
         25
        </b>
        ,181 (2003).
       </div>
      </li>
      <li>
       <div>
        [34] A. Tafliovich,
        <i>
         Quantum Programming.
        </i>
        Master's thesis, University of Toronto, 2004.
       </div>
      </li>
      <li>
       <div>
        [35] H. Mlnarik, Operational semantics and type soundness of quantum programming language LanQ (arXiv:quant-ph/0708.0890vl, 2007).
       </div>
      </li>
      <li>
       <div>
        [36] P. Maymin, Extending the lambda calculus to express randomized and quantumized algorithms (arXiv:quantph/9612052,1996).
       </div>
      </li>
      <li>
       <div>
        [37] P. Maymin, The lambda-q calculus can efficiently simulate quantum computers (arXiv:quant-phj9702057, 1997).
       </div>
      </li>
      <li>
       <div>
        [38] P. Selinger,
        <i>
         Mathematical Structures in Computer Science,
        </i>
        <b>
         14
        </b>
        ,527 (2004b).
       </div>
      </li>
      <li>
       <div>
        [39] A. Van Tonder, SIAM Journal on Computing
        <b>
         33
        </b>
        ,1109 (2004).
       </div>
      </li>
      <li>
       <div>
        [40] T. Altenkirch and J. Grattage, in
        <i>
         Proceedings of the 20th Annual IEEE Symposium on Logic in Computer Science
        </i>
        (IEEE Computer Society, Washington, D.C., 2005a).
       </div>
      </li>
      <li>
       <div>
        [41] T.Allenkirch and J. Crallage,
        <i>
         QML: Quantum Data and Control
        </i>
        http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.113.9509, 2005b.
       </div>
      </li>
      <li>
       <div>
        [42] M. Ying and Y. Feng, IEEE Transactions on Software Engineering
        <b>
         37
        </b>
        ,485 (2011).
       </div>
      </li>
      <li>
       <div>
        [43] V. Danos, E. Kashefi and P. Panangaden, Physical Review A
        <b>
         72
        </b>
        ,064301 (2005).
       </div>
      </li>
      <li>
       <div>
        [44] 4 S. Perdrix, in
        <i>
         Proceedings of the 3rd International Workshop on Quantum Programming Languages,
        </i>
        Electronic Notes in Theoretical Computer Science (EIsevier Science, Chicago, Illinois, 2(05).
       </div>
      </li>
      <li>
       <div>
        [45] S. Mu and R. Bird, in
        <i>
         Proceedings of the 2nd Asian Workshop on Programming Languages and Systems
        </i>
        (Korea Advanced Institute of Science and Technology, Daejeo, Korea, 2001).
       </div>
      </li>
      <li>
       <div>
        [46] A. Sabry, in
        <i>
         Proceedings of
        </i>
        lhe
        <i>
         ACM SIGPLAN Workshop on Haskel!
        </i>
        (ACM Press, Bloomington, Indiana, 2003).
       </div>
      </li>
      <li>
       <div>
        [47] J.K Vizzotto and A.C. da Rocha Costa, in
        <i>
         VII Congresso Brasileiro de Redes Neurais,
        </i>
        Sessão de Computação Quântica (Sociedade Brasileira de Redes Neurais, Natal-RN, 2005).
       </div>
      </li>
      <li>
       <div>
        [48] J. Karczmarczuk, in
        <i>
         Proceedings of the ACM SIGP LAN,
        </i>
        Workshop on Haskell (ACM Press, Bloomington, Indiana, 2003).
       </div>
      </li>
      <li>
       <div>
        [49] J. Skibinski,
        <i>
         Haskel! Simulator of Quantum Computer,
        </i>
        disponível em http://web.archive.org/web/20010520121707/www.numeric-quest.com/haskell
       </div>
      </li>
      <li>
       <div>
        [50] M. Freedman, A. Kitaev and Z. Wong, arXiv:quantph/0001071/v3, 2000.
       </div>
      </li>
      <li>
       <div>
        [51] W. Mauerer,
        <i>
         Semantics and Simulation of Communication in Quantum Computing.
        </i>
        Master's thesis, University Erlangen-Nuremberg, 2005.
       </div>
      </li>
      <li>
       <div>
        [52] P. Jorrand and M. Lalire,
        <i>
         Unconventional Programming Paradigms,
        </i>
        LNCS Series, v. 3566 (Springer, Le Mont Saint Michel, França, 2(05).
       </div>
      </li>
      <li>
       <div>
        [53] S. Gay and R. Nagarajan, in
        <i>
         Proceedings of the 32nd ACM Annual Symposium on Principies of Programming Languages,
        </i>
        (ACM Press, New York, USA, 2005), p. 145-157.
       </div>
      </li>
      <li>
       <div>
        [54] P. Adão and P. Mateus, in
        <i>
         Proceedings of the 3rd International Workshop on Quantum Programming Languages,
        </i>
        Electronic Notes in Theoretical Computer Science (EIsevier Science, Chicago, Illinois, 2005).
       </div>
      </li>
      <li>
       <div>
        [55] M. Udrescu, L. Prodan, and M. Vlâdutiu, in
        <i>
         Proceedings of the 1st ACM Conference on Computing Frontiers
        </i>
        (ACM Press, Ischia, ltaly, 2004).
       </div>
      </li>
     </ul>
    </div>
   </div>
   <div class="articleSection">
    <h2>
    </h2>
    <div class="ref-list">
     1
         E-mail: 
        piqueira@lac.usp.br.
    </div>
   </div>
   <div class="articleSection" data-anchor="Datas de Publicação ">
    <h1 class="articleSectionTitle">
     Datas de Publicação
    </h1>
    <div class="row">
     <div class="col-md-12 col-sm-12">
      <ul class="articleTimeline">
       <li>
        <strong>
         Publicação nesta coleção
        </strong>
        <br/>
        07 Maio 2013
       </li>
       <li>
        <strong>
         Data do Fascículo
        </strong>
        <br/>
        Mar 2013
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="articleSection" data-anchor="Histórico">
    <h1 class="articleSectionTitle">
     Histórico
    </h1>
    <div class="row">
     <div class="col-md-12 col-sm-12">
      <ul class="articleTimeline">
       <li>
        <strong>
         Recebido
        </strong>
        <br/>
        19 Maio 2012
       </li>
       <li>
        <strong>
         Aceito
        </strong>
        <br/>
        23 Jun 2012
       </li>
      </ul>
     </div>
    </div>
   </div>
   <section class="documentLicense">
    <div class="container-license">
     <div class="row">
      <div class="col-sm-3 col-md-2">
       <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" title="">
        <img alt="Creative Common - by-nc 4.0 " src="https://licensebuttons.net/l/by-nc/4.0//88x31.png"/>
       </a>
      </div>
      <div class="col-sm-9 col-md-10">
       <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" title="">
        This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.
       </a>
      </div>
     </div>
    </div>
   </section>
  </article>
 </div>
</div>