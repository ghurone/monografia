<!DOCTYPE html>
<div class="articleTxt">
 <div class="articleBadge-editionMeta-doi-copyLink">
  <span class="_articleBadge">
   Seção Especial
  </span>
  <span class="_separator">
   •
  </span>
  <span class="_editionMeta">
   Rev. Bras. Ensino Fís. 43 
                (Suppl 1)
   <span class="_separator">
    •
   </span>
   2021
  </span>
  <span class="_separator">
   •
  </span>
  <span class="group-doi">
   <a class="_doi" href="https://doi.org/10.1590/1806-9126-RBEF-2020-0407" target="_blank">
    https://doi.org/10.1590/1806-9126-RBEF-2020-0407
   </a>
   <a class="copyLink" data-clipboard-text="https://doi.org/10.1590/1806-9126-RBEF-2020-0407">
    <span class="sci-ico-link">
    </span>
    copiar
   </a>
  </span>
 </div>
 <h1 class="article-title">
  <span class="sci-ico-openAccess showTooltip" data-original-title="by 4.0 deed.en" data-toggle="tooltip">
  </span>
  Machine Learning na Física, Química, e Ciência de Materiais: Descoberta e Design de Materiais
  <a class="short-link" href="#" id="shorten">
   <span class="sci-ico-link">
   </span>
  </a>
 </h1>
 <h2 class="article-title">
  Machine Learning in Physics, Chemistry, and Materials Science: Materials Discovery and Design
 </h2>
 <div class="articleMeta">
 </div>
 <div class="contribGroup">
  <span class="dropdown">
   <a class="dropdown-toggle" data-toggle="dropdown" id="contribGroupTutor1">
    <span>
     Gabriel R. Schleder
    </span>
   </a>
   <ul aria-labelledby="contribGrupoTutor1" class="dropdown-menu" role="menu">
    <strong>
    </strong>
    Laboratório Nacional de Nanotecnologia, Centro Nacional de Pesquisa em Energia e Materiais, Campinas, SP, Brasil.Universidade Federal do ABC, Santo André, SP, Brasil
    <a class="btnContribLinks orcid" href="http://orcid.org/0000-0003-3129-8682">
     http://orcid.org/0000-0003-3129-8682
    </a>
   </ul>
  </span>
  <span class="dropdown">
   <a class="dropdown-toggle" data-toggle="dropdown" id="contribGroupTutor2">
    <span>
     Adalberto Fazzio
    </span>
   </a>
   <ul aria-labelledby="contribGrupoTutor2" class="dropdown-menu" role="menu">
    <strong>
    </strong>
    <div class="corresp">
     * Endereço de correspondência:
     <a href="mailto:adalberto.fazzio@lnnano.cnpem.br">
      adalberto.fazzio@lnnano.cnpem.br
     </a>
    </div>
    Laboratório Nacional de Nanotecnologia, Centro Nacional de Pesquisa em Energia e Materiais, Campinas, SP, Brasil.Universidade Federal do ABC, Santo André, SP, Brasil
   </ul>
  </span>
  <a class="outlineFadeLink" data-target="#ModalTutors" data-toggle="modal" href="">
   Sobre os autores
  </a>
 </div>
 <div class="row">
  <ul class="col-md-2 hidden-sm articleMenu">
  </ul>
  <article class="col-md-10 col-md-offset-2 col-sm-12 col-sm-offset-0" id="articleText">
   <div class="articleSection" data-anchor="Resumos">
    <h1 class="articleSectionTitle">
     Resumos
    </h1>
   </div>
   <div>
    <p>
     Avanços recentes nas técnicas experimentais e desenvolvimentos teóricos e computacionais resultaram em um aumento crescente na geração de dados. Essa disponibilidade de dados, associada à novas ferramentas e tecnologias capazes de armazenar e processar esses dados, culminaram na chamada ciência de dados. Uma das áreas de maior destaque recente são os algoritmos de aprendizado de máquina (
     <i>
      machine learning
     </i>
     ), que têm como objetivo a identificação de correlações e padrões nos conjuntos de dados. Esses algoritmos vêm sendo usados há décadas, por exemplo nas áreas da saúde. Apenas recentemente a comunidade introduziu a sua aplicação para materiais, devido à criação, padronização e consolidação de bancos de dados consistentes. O uso dessas metodologias permite extrair conhecimento e
     <i>
      insights
     </i>
     da enorme quantidade de dados brutos e informações agora disponíveis. A área apresenta diversas oportunidades para a solução de desafios na física, química e ciência de materiais. Especificamente, os métodos de machine learning são uma poderosa ferramenta para a descoberta e design de novos materiais com propriedades e funcionalidades desejadas e otimizadas. Neste artigo apresentamos o contexto do surgimento do machine learning, seus fundamentos e aplicações para a descoberta e design de materiais.
    </p>
    <p>
     <strong>
      Palavras-chave
     </strong>
     <br/>
     Inteligência artificial; ciência de dados; ciência baseada em ferramentas; informática de materiais
    </p>
   </div>
   <hr/>
   <div>
    <p>
     Nowadays, we are witnessing a tremendous increase in data generation enabled by advances in experimental techniques and theoretical and computational developments. This availability of data, associated with new tools and technologies capable of storing and processing that data, culminated in the so-called data science. One of the most prominent areas (
     <i>
      machine learning
     </i>
     ), which aims to identify correlations and patterns in the data sets. These algorithms have been used for decades in different areas. Only recently the community introduced its application for materials, due to the creation, standardization, and consolidation of consistent databases. The use of these methodologies allows to extract knowledge and
     <i>
      insights
     </i>
     from the huge amount of raw data and information now available. The area presents several opportunities for solving challenges in physics, chemistry, and materials science. Specifically, machine learning methods are a powerful tool for discovering and designing new materials with desired and optimized properties and functionalities. In this article, we present the context of the emergence of machine learning, its foundations, and applications for the discovery and design of materials.
    </p>
    <p>
     <strong>
      Keywords
     </strong>
     <br/>
     Artificial intelligence; data-driven science; tool-driven science; materials informatics
    </p>
   </div>
   <hr/>
   <div class="articleSection" data-anchor="Text">
    <h1 class="articleSectionTitle">
     1. Introdução
    </h1>
    <p>
     Um dos objetivos da ciência é descrever, explicar e predizer o comportamento de fenômenos físicos, químicos e biológicos. A natureza é complexa, e descrevê-la exige a busca de aproximações ou simplificações. Ao longo da história, as ciências fizeram uso de aproximações para separar e extrair o que é fundamental do que é supérfluo, para a compreensão das diversas manifestações da natureza. Com isso, a tarefa complexa se torna um problema de algumas variáveis tangíveis, e assim se estuda o problema de interesse. Isso levou a física e a química a um desenvolvimento mais rápido se comparado com o campo da biologia.
    </p>
    <p>
     Filósofos argumentam que historicamente a ciência evolui pela chamada “concept-driven science”, com estabelecimento e quebra de paradigmas, que são pressupostos fundamentais compartilhados pela comunidade de cada área científica; visão expressa por Thomas Kuhn [
     <span class="ref">
      <sup class="xref xrefblue">
       1
      </sup>
      <span class="refCtt closed">
       <span>
        1. T. Kuhn, The Structure of Scientific Revolutions (University of Chicago Press, Chicago, 1962).
       </span>
      </span>
     </span>
     ]. Um contraponto complementar à essa visão, especialmente aplicado às ciências naturais, é que as ciências sejam “tool-driven” [
     <span class="ref">
      <sup class="xref xrefblue">
       2
      </sup>
      <span class="refCtt closed">
       <span>
        2. F.J. Dyson, Science 338, 1426 (2012).
       </span>
      </span>
     </span>
     ], ou seja, que novas ferramentas (de qualquer natureza) avançam as ciências tanto quanto novos conceitos [
     <span class="ref">
      <sup class="xref xrefblue">
       3
      </sup>
      <span class="refCtt closed">
       <span>
        3. P. Galison, Image and logic: A material culture of microphysics (University of Chicago Press, Chicago, 1997).
       </span>
      </span>
     </span>
     ]. Essa visão defendida por Peter Galison tem vários exemplos mais recentes, tal como o desenvolvimento de aceleradores de partículas, microscópios, telescópios e técnicas computacionais. O físico Freeman Dyson expressa essa visão
     <span class="ref footnote">
      <sup class="xref">
       1
      </sup>
      <span class="refCtt closed">
       <span class="refCttPadding">
        <strong class="fn-title">
         1
        </strong>
        Tradução livre do original: “New directions in science are launched by new tools much more often than by new concepts. The effect of a concept-driven revolution is to explain old things in new ways. The effect of a tool-driven revolution is to discover new things that have to be explained.”[4].
       </span>
      </span>
     </span>
     :
    </p>
    <p>
     <i>
      “Novas direções na ciência são criadas por novas ferramentas com muito mais frequência do que por novos conceitos. O efeito de uma revolução impulsionada por conceitos é explicar coisas antigas de novas maneiras. O efeito de uma revolução impulsionada por ferramentas é descobrir coisas novas que precisam ser explicadas”
     </i>
     [
     <span class="ref">
      <sup class="xref xrefblue">
       4
      </sup>
      <span class="refCtt closed">
       <span>
        4. F.J. Dyson, Imagined worlds (Harvard University Press, Massachusetts, 1997).
       </span>
      </span>
     </span>
     ].
    </p>
    <p>
     O aprendizado de máquina (
     <i>
      machine learning, ML
     </i>
     ) surge nesse contexto como uma nova classe de ferramentas estatísticas para identificar padrões de forma automatizada em diferentes conjuntos de dados, e assim auxiliar na construção de novo conhecimento científico. Com o crescimento cada vez maior da geração e diversidade dos dados experimentais, teóricos e de simulação, a forma e técnicas de análise e processamento da informação está mudando de tal forma que distingue-se a ciência baseada em dados (do inglês
     <i>
      data-driven science
     </i>
     ) como um novo “paradigma” ferramental da ciência [
     <span class="ref">
      <sup class="xref xrefblue">
       5
      </sup>
      <span class="refCtt closed">
       <span>
        5. T. Hey, S. Tansley e K. Tolle, em: The Fourth Paradigm: Data-Intensive Scientific Discovery , editado por T. Hey (Microsoft Research, Redmond, 2009).
       </span>
      </span>
     </span>
     ]. Esse paradigma naturalmente se utiliza e complementa os paradigmas anteriores de experimentos, teoria e computação/simulação, conforme mostrado na Figura
     <a class="open-asset-modal" data-target="#ModalFigS1_F1" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      1
     </a>
     . Embora essas técnicas sejam amplamente utilizadas há tempos em áreas de grande complexidade como biologia, medicina e astronomia, apenas recentemente elas vêm se consolidando na física, química e ciência de materiais. Os avanços obtidos nessas áreas se mostram disruptivos na complexidade de descobrir novos materiais com propriedades desejáveis e otimizadas.
    </p>
    <div class="row fig" id="S1_F1">
     <a name="S1_F1">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigS1_F1" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/395ca618b6d7706cf47dabe5552fa0cd263f9668.jpg"/>
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <strong>
       Figura 1
      </strong>
      <br/>
      Os quatro paradigmas da ciência: experimental, teórica, computacional e baseada em dados. Cada paradigma se beneficia e contribui para os outros, sendo complementares. Adaptado de [
      <span class="ref">
       <sup class="xref xrefblue">
        6
       </sup>
       <span class="refCtt closed">
        <span>
         6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
        </span>
       </span>
      </span>
      ,
      <span class="ref">
       <sup class="xref xrefblue">
        7
       </sup>
       <span class="refCtt closed">
        <span>
         7. A. Agrawal e A. Choudhary, APL Materials 4, 053208 (2016).
        </span>
       </span>
      </span>
      ]
      <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">
       CC BY 3.0
      </a>
      .
      <br/>
     </div>
    </div>
    <h1 class="articleSectionTitle">
     2. Machine Learning
    </h1>
    <p>
     Esta seção é majoritariamente adaptada de [
     <span class="ref">
      <sup class="xref xrefblue">
       6
      </sup>
      <span class="refCtt closed">
       <span>
        6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
       </span>
      </span>
     </span>
     ].
    </p>
    <h2>
     2.1. Contexto: quando e por quê?
    </h2>
    <p>
     A descoberta de novos materiais e/ou sua funcionalização possibilita a criação de aplicações tecnológicas fundamentais para superar muitos dos desafios da sociedade moderna. O impacto do uso de materiais ao longo da história é difícil de quantificar, desde a idade da pedra, passando pela idade do bronze e ferro [
     <span class="ref">
      <sup class="xref xrefblue">
       8
      </sup>
      <span class="refCtt closed">
       <span>
        8. S. Curtarolo, G.L.W. Hart, M.B. Nardelli, N. Mingo, S. Sanvito e O. Levy, Nature Materials 12, 191 (2013).
       </span>
      </span>
     </span>
     ]. Entretanto, o impacto baseado na tecnologia do silício e a revolução dos plásticos são bem palpáveis [
     <span class="ref">
      <sup class="xref xrefblue">
       9
      </sup>
      <span class="refCtt closed">
       <span>
        9. A. Jain, K.A. Persson e G. Ceder, APL Materials 4, 053102 (2016).
       </span>
      </span>
     </span>
     ]. Estima-se que o desenvolvimento de materiais permitiu dois terços dos avanços na área da computação e transformou também outras indústrias como armazenamento de energia [
     <span class="ref">
      <sup class="xref xrefblue">
       10
      </sup>
      <span class="refCtt closed">
       <span>
        10. C.L. Magee, Complexity 18, 10 (2012).
       </span>
      </span>
     </span>
     ].
    </p>
    <p>
     Dada a demanda crescente por novos materiais e o desenvolvimento relativamente lento deles, ao mesmo tempo em que os recursos computacionais e algoritmos enfrentam grandes avanços, é natural perguntar: como a ciência computacional pode melhorar a eficiência da descoberta de materiais? Outras áreas, como a indústria farmacêutica e de biotecnologia, sugerem caminhos possíveis [
     <span class="ref">
      <sup class="xref xrefblue">
       11
      </sup>
      <span class="refCtt closed">
       <span>
        11. P. Gribbon e S. Andreas, Drug Discovery Today 10, 17 (2005).
       </span>
      </span>
     </span>
     ,
     <span class="ref">
      <sup class="xref xrefblue">
       12
      </sup>
      <span class="refCtt closed">
       <span>
        12. D.A. Pereira e J.A. Williams, British Journal of Pharmacology 152, 53 (2009).
       </span>
      </span>
     </span>
     ]. No entanto, dentro do quarto paradigma da ciência baseada em dados, a comunidade de materiais está aparentemente atrasada em comparação com esses campos. Essa chegada tardia está relacionada a gargalos na capacidade computacional e de geração e armazenamento de dados, mas desde que as primeiras simulações computacionais de materiais foram realizadas, uma quantidade cada vez maior de estudos faz uso deste paradigma [
     <span class="ref">
      <sup class="xref xrefblue">
       6
      </sup>
      <span class="refCtt closed">
       <span>
        6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
       </span>
      </span>
     </span>
     ].
    </p>
    <p>
     A teoria do funcional da densidade (
     <i>
      density functional theory
     </i>
     , DFT) se estabeleceu como a ferramenta padrão para simulação de materiais após seu sucesso na descrição de muitas propriedades físicas importantes, como geometrias nos estados fundamentais, energias totais e relativas e estruturas eletrônicas. Posteriormente, diversos marcos foram alcançados, como a descrição de propriedades estruturais, eletrônicas, ópticas, magnéticas, catalíticas e quânticas, tanto para materiais bulk quanto na nanoescala [
     <span class="ref">
      <sup class="xref xrefblue">
       13
      </sup>
      <span class="refCtt closed">
       <span>
        13. F. Giustino, M. Bibes, J.H. Lee, F. Trier, R. Valentí, S.M. Winter, Y.W. Son, L. Taillefer, C. Heil, A.I. Figueroa et al., Journal of Physics: Materials, 10.1088/2515-7639/abb74e (2020).
       </span>
       <br/>
       <a href="https://doi.org/10.1088/2515-7639/abb74ehttps://doi.org/10.1088/2515-7639/abb74e" target="_blank">
        https://doi.org/10.1088/2515-7639/abb74e...
       </a>
      </span>
     </span>
     ].
    </p>
    <p>
     Conforme os desenvolvimentos computacionais aumentaram seu desempenho, o armazenamento de dados tornou-se mais barato e novos algoritmos foram desenvolvidos, uma mudança gradual na forma usual de trabalho de cientistas de materiais, especialmente computacionais, ocorreu na última década. Surgiu uma nova forma de estudar os materiais: antes, a ideia era escolher um ou alguns candidatos e investigá-los minuciosamente para obter um conhecimento mais profundo sobre suas propriedades e possíveis aplicações. Agora é possível simular facilmente um grande número de compostos – técnica conhecida como
     <i>
      high-throughput (HT)
     </i>
     – e buscar uma propriedade particular em um catálogo de candidatos [
     <span class="ref">
      <sup class="xref xrefblue">
       14
      </sup>
      <span class="refCtt closed">
       <span>
        14. G.R. Schleder, A.C.M. Padilha, A.R. Rocha, G.M. Dalpian e A. Fazzio, Journal of Chemical Information and Modeling 60, 452 (2020).
       </span>
      </span>
     </span>
     ]. Isso marcou o nascimento dessa nova filosofia na área de materiais, dentro do contexto da ciência baseada em dados e descrita na Figura
     <a class="open-asset-modal" data-target="#ModalFigS2_F2" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      2
     </a>
     .
    </p>
    <div class="row fig" id="S2_F2">
     <a name="S2_F2">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigS2_F2" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/8efaa1924ce76758059167388b89963b6e6ab1c3.jpg"/>
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <strong>
       Figura 2
      </strong>
      <br/>
      Diferenças das abordagens tradicional e baseadas em dados para a descoberta e design de moléculas e materiais. Na abordagem tradicional um candidato é avaliado por estratégias de tentativa e erro (esquerda), já na abordagem de dados, é substituída por estratégias de design inverso (direita), capaz de buscar materiais que maximizam as funcionalidades-alvo por meio de high-throughput, aprendizado de máquina ou técnicas evolutivas. Adaptado com permissão de [
      <span class="ref">
       <sup class="xref xrefblue">
        14
       </sup>
       <span class="refCtt closed">
        <span>
         14. G.R. Schleder, A.C.M. Padilha, A.R. Rocha, G.M. Dalpian e A. Fazzio, Journal of Chemical Information and Modeling 60, 452 (2020).
        </span>
       </span>
      </span>
      ]. Copyright 2019 American Chemical Society.
      <br/>
     </div>
    </div>
    <p>
     A simples geração massiva de dados não é garantia de convertê-los em informação e, posteriormente, em conhecimento. Converter o conhecimento em avanços para a sociedade é um desafio ainda maior. Existem lacunas entre a criação, o armazenamento de dados e a capacidade de obter conhecimento e tecnologias utilizáveis a partir deles. A tendência dessa lacuna é aumentar com o tempo [
     <span class="ref">
      <sup class="xref xrefblue">
       15
      </sup>
      <span class="refCtt closed">
       <span>
        15. J. Glick, em: Ontologies and Databases—Knowledge Engineering for Materials Informatics , editado por K. Rajan (Elsevier, Amsterdã, 2013).
       </span>
      </span>
     </span>
     ]. Portanto, dado esse cenário, o uso de abordagens orientadas a dados é fundamental para reduzir essa lacuna e avançar nas pesquisas. Avanços recentes em técnicas experimentais e computacionais resultaram em um aumento exponencial nas quantidades de dados gerados, apresentando também complexidade crescente, levando ao conceito de
     <i>
      big-data
     </i>
     . Nesse sentido, as técnicas de machine learning visam extrair conhecimento e
     <i>
      insights
     </i>
     desses dados, identificando suas correlações e padrões [
     <span class="ref">
      <sup class="xref xrefblue">
       6
      </sup>
      <span class="refCtt closed">
       <span>
        6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
       </span>
      </span>
     </span>
     ].
    </p>
    <h2>
     2.2. O que é e quando utilizar?
    </h2>
    <p>
     Explorando a evolução do quarto paradigma da ciência, um paralelo pode ser feito entre o artigo de Eugene Wigner de 1960 “A eficácia irracional da matemática nas ciências naturais” [
     <span class="ref">
      <sup class="xref xrefblue">
       16
      </sup>
      <span class="refCtt closed">
       <span>
        16. E.P. Wigner, Communications on Pure and Applied Mathematics 13, 1 (1960).
       </span>
      </span>
     </span>
     ] para o caso atual da “A eficácia irracional dos dados” [
     <span class="ref">
      <sup class="xref xrefblue">
       17
      </sup>
      <span class="refCtt closed">
       <span>
        17. A. Halevy, P. Norvig e F. Pereira, IEEE Intelligent Systems 24, 8 (2009).
       </span>
      </span>
     </span>
     ]. O que leva à essa eficácia irracional dos dados recentemente? Principalmente a extração de conhecimento dessa grande quantidade de dados acumulados. Isso é feito por meio de técnicas de aprendizado de máquina que podem identificar padrões e relações nos dados, por mais complexas que sejam, mesmo para espaços de dimensionalidade arbitrariamente altas, inacessíveis à compreensão humana [
     <span class="ref">
      <sup class="xref xrefblue">
       6
      </sup>
      <span class="refCtt closed">
       <span>
        6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
       </span>
      </span>
     </span>
     ].
    </p>
    <p>
     O machine learning (ML) pode ser definido como uma classe de métodos para análise automatizada de dados, que são capazes de detectar padrões nos dados. Esses padrões extraídos podem ser usados para prever informações desconhecidas ou para auxiliar nos processos de tomada de decisão sob incerteza [
     <span class="ref">
      <sup class="xref xrefblue">
       18
      </sup>
      <span class="refCtt closed">
       <span>
        18. K.P. Murphy, Machine Learning: A Probabilistic Perspective (MIT Press, Cambridge, 2012).
       </span>
      </span>
     </span>
     ]. A definição tradicional diz que o aprendizado da máquina melhora progressivamente com a experiência (dados) em tarefas determinadas, de acordo com uma métrica de sucesso definida, mas sem ser explicitamente programada para isso [
     <span class="ref">
      <sup class="xref xrefblue">
       19
      </sup>
      <span class="refCtt closed">
       <span>
        19. A.L. Samuel, IBM Journal of Research and Development 3, 210 (1959).
       </span>
      </span>
     </span>
     ,
     <span class="ref">
      <sup class="xref xrefblue">
       20
      </sup>
      <span class="refCtt closed">
       <span>
        20. T. Hastie, R. Tibshirani e J. Friedman, The Elements of Statistical Learning (Springer, New York, 2001).
       </span>
      </span>
     </span>
     ]. Este campo de pesquisa evoluiu a partir da área mais geral de inteligência artificial (IA), inspirada pelos avanços na década de 1950 em estatística, ciência e tecnologia da computação e neurociência. A Figura
     <a class="open-asset-modal" data-target="#ModalFigS2_F3" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      3
     </a>
     b mostra a relação entre a área de IA e o ML. Em contraste, uma definição menos rigorosa de IA é qualquer técnica que permite aos computadores imitar a inteligência humana. Isso pode ser alcançado não apenas por ML, mas também por estratégias programadas “menos inteligentes”, como árvores de decisão, regras “se-então”, bases de conhecimento e lógica computacional. Recentemente, um subcampo do ML que está ganhando cada vez mais atenção devido ao seu sucesso em várias áreas é o aprendizado profundo (
     <i>
      deep learning
     </i>
     ) [
     <span class="ref">
      <sup class="xref xrefblue">
       21
      </sup>
      <span class="refCtt closed">
       <span>
        21. I. Goodfellow, Y. Bengio e A. Courville, Deep Learning , disponível em: http://www.deeplearningbook.org.
       </span>
       <br/>
       <a href="http://www.deeplearningbook.org" target="_blank">
        http://www.deeplearningbook.org...
       </a>
      </span>
     </span>
     ]. É um tipo de aprendizagem de representações vagamente inspirado por redes neurais biológicas, tendo um número grande de camadas entre suas entradas (
     <i>
      inputs
     </i>
     ) e saídas (
     <i>
      outputs
     </i>
     ). Um campo intimamente relacionado e componente muito importante do ML é a fonte de dados que permitirá aos algoritmos aprender. Este é o campo da ciência de dados, apresentado na Figura
     <a class="open-asset-modal" data-target="#ModalFigS2_F3" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      3
     </a>
     a.
    </p>
    <div class="row fig" id="S2_F3">
     <a name="S2_F3">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigS2_F3" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/3e4fd7a11c7bce35bf929cce0f3e56064a116386.jpg"/>
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <strong>
       Figura 3
      </strong>
      <br/>
      (a) Ciência de dados como disciplina integrativa, pela convergência da matemática e estatística, ciência e tecnologia da computação e conhecimento específico de área [
      <span class="ref">
       <sup class="xref xrefblue">
        22
       </sup>
       <span class="refCtt closed">
        <span>
         22. B. Sun, M. Fernandez e A.S. Barnard, Nanoscale Horizons 1, 89 (2016).
        </span>
       </span>
      </span>
      ]. (b) Descrição hierárquica e exemplos de técnicas de inteligência artificial e suas subáreas aprendizado de máquina (
      <i>
       machine learning
      </i>
      ) e aprendizado profundo (
      <i>
       deep learning
      </i>
      ). Adaptado de [
      <span class="ref">
       <sup class="xref xrefblue">
        6
       </sup>
       <span class="refCtt closed">
        <span>
         6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
        </span>
       </span>
      </span>
      ]
      <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">
       CC BY 3.0
      </a>
      e [
      <span class="ref">
       <sup class="xref xrefblue">
        22
       </sup>
       <span class="refCtt closed">
        <span>
         22. B. Sun, M. Fernandez e A.S. Barnard, Nanoscale Horizons 1, 89 (2016).
        </span>
       </span>
      </span>
      ], com permissão da
      <i>
       The Royal Society of Chemistry
      </i>
      .
      <br/>
     </div>
    </div>
    <p>
     Finalmente, quando o ML deve ou não ser empregado. De maneira geral, podemos usar o ML para 2 tipos de problemas:
     <i>
      (i)
     </i>
     para tratar problemas que métodos tradicionais não conseguem, de maneira aproximada; e
     <i>
      (ii)
     </i>
     para otimizar a solução de problemas já tratáveis, porém ou de maneira melhor e mais robusta, ou mais rápida, ou mais econômica, de preferência os três simultaneamente. O pré-requisito crucial é a disponibilidade de dados, que devem ser consistentes, suficientes, validados e representativos do comportamento de interesse a ser descrito. Além disso, é preciso considerar os pontos fortes dos métodos de aprendizado de máquina, que podem lidar com espaços de alta dimensão na busca de padrões nos dados. Os padrões descobertos são então codificados explicitamente, levando à modelos computacionais que podem ser manipulados. Os métodos de ML são mais adequados para problemas em que as abordagens tradicionais apresentam dificuldades. Embora nem sempre seja claro especificar, se um problema pode ser identificado em um dos tipos gerais de problemas de ML descritos na seção
     <span class="ref footnote">
      <sup class="xref">
       2.3
      </sup>
      <span class="refCtt closed">
       <span class="refCttPadding">
        2.3. Como usar?
        De maneira geral, podemos organizar o problema de machine learning em 4 passos fundamentais como ilustrado na Fig. 4 que são detalhados a seguir: i) definição do problema; ii) dados; iii) representação; e iv) algoritmos, validação, e aplicação.
        
          Figura 4
          
            Os quatro componentes básicos do processo de machine learning. Adaptado de [13] CC BY 3.0.
          
          
            
            
          
        
        
          
            Definição do problema: primeiramente vamos discutir quais os tipos de problemas mais comuns a serem tratados com machine learning. Formalmente, o problema de aprendizagem pode ser descrito [25] por: dado um conjunto de dados conhecido X – onde a notação X indica que é um vetor com uma ou várias variáveis –, prever ou aproximar a função de interesse desconhecida y = f(X), em função desses dados conhecidos. O conjunto X é denominado espaço de features de input (também conhecido como atributos ou características) e um elemento x dele é chamado de vetor de features, ou simplesmente uma entrada. Com a função aproximada aprendiday^=f^⁢(X), o modelo pode então prever a saída para exemplos desconhecidos fora dos dados usados para o treinamento, e sua capacidade de fazer isso é chamada de generalização do modelo. Existem algumas categorias de problemas de ML de acordo com os tipos de entradas e saídas tratadas, sendo as duas principais as aprendizagens supervisionada e não supervisionada.
            Na aprendizagem não supervisionada, também conhecida como descritiva, o objetivo é encontrar estruturas nos dados brutos xi ∈ X fornecidos sem rótulos, ou seja, não se usa ou não existem dados de saída y conhecidos. Se f(X) é finito, o aprendizado é denominado agrupamento (clustering), que agrupa dados em um número (conhecido ou desconhecido) de grupos pela similaridade em suas características. Por outro lado, se f(X) está em uma distribuição [0,∞), a aprendizagem é chamada de estimativa de densidade, que aprende a distribuição marginal das características. Outro tipo importante de aprendizagem não supervisionada é a redução de dimensionalidade, que comprime o número de variáveis de entrada para representar os dados, útil quando f(X) tem alta dimensionalidade e, portanto, uma estrutura de dados complexa para ser visualizada e usada na detecção de padrões.
            Por outro lado, na aprendizagem supervisionada ou preditiva, o objetivo é aprender a função que leva as entradas às saídas alvo (target), tendo um conjunto de dados rotulados (xi,yi) ∈ (X,f(X)), conhecido como conjunto de treinamento (ao contrário do conjunto de teste desconhecido), com i = N número de exemplos. Se a saída y_i é um conjunto finito categórico ou nominal (por exemplo, se um material é um metal ou isolante), o problema é chamado de classificação, que prevê o rótulo de classe para amostras desconhecidas. Caso contrário, se as saídas são escalares contínuos de valor real yi ∈ ℝ, o problema é então chamado de regressão, que irá prever os valores de saída para os exemplos desconhecidos. Veremos os algoritmos relacionados na seção iv) adiante.
            Outros tipos de problemas de ML são a aprendizagem semi-supervisionada, em que um grande número de dados não rotulados é combinado com um pequeno número de dados rotulados; a aprendizagem multi-tarefa; a transferência de aprendizagem, onde informações de problemas relacionados são exploradas para melhorar a tarefa de aprendizagem (geralmente uma com poucos dados disponíveis [26]); e o chamado aprendizado por reforço, no qual nenhuma entrada/saída é fornecida, mas sim feedbacks sobre as decisões como um meio de maximizar um sinal de recompensa, levando ao aprendizado de ações desejadas em determinados ambientes.
          
          
            Dados (inputs): a disponibilidade de dados é componente fundamental para qualquer processo de machine learning. Os resultados a serem obtidos no processo serão tão bons quanto a quantidade e qualidade dos dados que serão utilizados. Qualidade nesse contexto se refere que os dados sejam representativos do problema a ser estudado, consistentes, e que possuam informação relacionada à tarefa ser realizada [14]. Portanto, o processo para chegar num conjunto de dados de qualidade leva algumas etapas. Inicialmente, a etapa de coleta e/ou curadoria dos dados para geração e seleção de um subconjunto relevante e útil de dados disponíveis para a resolução dos problemas. Posteriormente, o pré-processamento de dados, que busca uma formatação adequada dos dados, limpeza de dados corrompidos e ausentes, transformação dos dados conforme necessário por operações como normalização, discretização, cálculo da média, suavizar ou diferenciar, conversão uniforme para inteiros, double ou strings e amostragem adequada para otimizar a representatividade do conjunto [6]. Tendo os dados brutos tecnicamente corretos, é possível a próxima etapa de escolha da representação adequada ao problema.
          
          
            Representação: também chamada de impressão digital (fingerprint) ou descritor [27], a representação determinará a capacidade e o desempenho do processo de machine learning. Somente se as variáveis necessárias forem representadas que o algoritmo será capaz de aprender a relação desejada. Essa etapa mapeia em um vetor as diferentes variáveis de entrada (features de input) disponíveis que descrevem e identificam as amostras (no presente contexto, os materiais). Alguns requisitos desejáveis universais são propostos [28, 6, 14], tais como: a representação deve ser a) completa (suficiente para diferenciar os exemplos), b) única (dois exemplos terão a mesma representação apenas se forem de fato iguais), c) discriminativos (sistemas similares ou diferentes serão caracterizados por representações similares ou diferentes), e d) eficiente e simples de ser obtido (o cálculo da representação em si deve ser rápido). Esses requisitos apresentados servem para garantir que os modelos sejam eficientes usando apenas informações essenciais. Para qualquer novo problema de machine learning, o processo de engenharia de features, que engloba a seleção, combinação, e transformação destas, é responsável pela maior parte dos esforços e do tempo usado no projeto [29].
          
          
            Algoritmos, validação, e aplicação: A tarefa de construir e utilizar algoritmos é um estudo caso a caso. Nenhum algoritmo de ML é universalmente superior [30, 31]. Em particular, a escolha do algoritmo de aprendizagem é uma etapa fundamental na construção de um pipeline de ML, e muitas opções estão disponíveis, cada uma adequada para um determinado problema e/ou conjunto de dados. Esse conjunto de dados pode ser de dois tipos: rotulado ou não rotulado. Como vimos, no primeiro caso, a tarefa é encontrar o mapeamento entre os pontos dos dados e os rótulos correspondentes {x(i)}→{y(i)} por meio de um algoritmo de aprendizagem supervisionada. Por outro lado, se não há rótulos no conjunto de dados, a tarefa é encontrar uma estrutura dentro dos dados, utilizando o aprendizado não supervisionado. A seguir apresentamos de maneira breve um exemplo simples e os principais algoritmos para cada um dos tipos de problemas de ML que apresentamos na seção 2.3. i. Esses tipos de problemas e os algoritmos relacionados são resumidos na Figura 5. Figura 5Algoritmos de machine learning e diagrama de uso, divididos nos principais tipos de problemas: aprendizado não supervisionado (redução de dimensionalidade e clustering) e supervisionado (classificação e regressão). Adaptado de [6] CC BY 3.0. 
            Redução de dimensionalidade. Devido à grande abundância de dados, pode-se facilmente obter vetores de features de tamanho incrivelmente grandes, levando ao que é conhecido como “maldição da dimensionalidade”. Por exemplo, imagine um algoritmo de ML que recebe como entrada imagens de n×n pixels em escala de cinza, cada um representado como um valor numérico. Nesse caso, a matriz que contém esses números é achatada em um vetor de comprimento n2, o vetor de características, descrevendo esse ponto (amostra) em um espaço de alta dimensionalidade. Devido à dependência exponencial, um número grande de dimensões é facilmente atingido para imagens de tamanho médio. A memória ou o poder de processamento computacional tornam-se fatores limitantes neste caso. Um ponto chave é que dentro da nuvem de dados de alta dimensão abrangida pelo conjunto de dados, pode-se encontrar uma estrutura de dimensão inferior. O conjunto de pontos pode ser projetado em um hiperplano ou variedade, reduzindo sua dimensionalidade enquanto preserva a maior parte das informações contidas na nuvem de dados original. Uma série de procedimentos com esse objetivo, como análise de componentes principais (PCA) são rotineiramente empregados em algoritmos de ML [32]. Em poucas palavras, a PCA é uma rotação de cada eixo do sistema de coordenadas do espaço onde residem os pontos de dados, levando à maximização da variância ao longo desses eixos. A maneira de descobrir para onde o novo eixo deve apontar é obtendo o autovetor correspondente ao maior autovalor de XTX, onde X é a matriz de dados. Uma vez que o maior autovetor de variância, também conhecido como o componente principal, é encontrado, os pontos são projetados nele, resultando em uma compressão dos dados. Usualmente escolhe-se um número de componentes principais que irão descrever a maior parte da variância do conjunto de dados. A generalização dos algoritmos de redução de dimensionalidade para estruturas não-lineares é chamada de manifold learning, dos quais exemplos conhecidos são o multi-dimensional scaling (MDS), isometric mapping (Isomap) e t-distributed stochastic neighbor embedding (t-SNE).
            Clustering. O clustering hierárquico é um método empregado na aprendizagem não supervisionada, podendo ser de dois tipos, aglomerativo ou divisivo. O primeiro pode ser descrito por um algoritmo simples: começando com n classes, ou clusters, cada um deles contendo um único exemplo x(i) do conjunto de treinamento, e então é medida a dissimilaridade d(A,B) entre pares de clusters rotulados A e B. Os dois clusters com a menor dissimilaridade, ou seja, mais semelhantes, são mesclados em um novo cluster. O processo é então repetido recursivamente até que apenas um cluster, contendo todos os elementos do conjunto de treinamento, permaneça. O processo pode ser melhor visualizado traçando um dendrograma, tal como mostrado na Figura 6. Para agrupar os dados em k clusters, 1 &lt; k &lt; n, o usuário deve cortar a estrutura hierárquica obtida em alguma etapa intermediária do agrupamento. Há certa liberdade na escolha da medida de dissimilaridade d(A,B), e três medidas principais são populares. Primeiro, a ligação única leva em consideração o par mais próximo de membros do cluster, Figura 6(a) Dendrograma demonstrando o clustering hierárquico. O código de cores é um guia para visualizar os clusters, representados pelas linhas verticais. As linhas horizontais indicam a fusão de dois clusters. O número de cruzamentos entre a linha horizontal e as linhas dos clusters corresponde ao número de clusters em uma determinada altura selecionada, no exemplo da linha tracejada cinza, são cinco clusters. (b) Exemplo da função sigmóide e a classificação de exemplos negativos em vermelho e positivos em azul na regressão logística. A seta cinza aponta para os dados classificados incorretamente no conjunto de dados. Adaptado de [6] CC BY 3.0. (c) Exemplo de uma rede neural com N camadas ocultas e um único neurônio na camada de output. (1)dS⁢L⁢(A,B)=mini∈A,j∈B⁡di⁢j 
            onde dij é uma medida de dissimilaridade de membros do par. Em segundo lugar, a ligação completa considera o par mais distante ou mais diferente de cada cluster, (2)dC⁢L⁢(A,B)=maxi∈A,j∈B⁡di⁢j 
            e, finalmente, o agrupamento da média do grupo considera a dissimilaridade média, representando um balanço entre as duas medidas anteriores, (3)dG⁢A⁢(A,B)=1|A|⁢|B|⁢∑i∈A∑j∈Bdi⁢j. 
            A forma particular de dij também pode ser escolhida, geralmente sendo considerada a distância euclidiana para dados numéricos. A menos que os dados disponíveis sejam altamente agrupados, a escolha da medida de dissimilaridade pode resultar em dendrogramas distintos e, portanto, clusters distintos. Como o nome sugere, o clustering divisivo executa a operação oposta, começando com um único cluster contendo todos os exemplos do conjunto de dados e o divide recursivamente de forma que a dissimilaridade do cluster seja maximizada. O processo termina quando cada cluster possuir uma entrada. Da mesma forma, requer que o usuário determine a linha de corte para agrupar os dados. Outros algoritmos de clustering bastante utilizados são o K-médias (K-means) e o DBSCAN.
            Supervisionado: Regressão e Classificação. No caso dos algoritmos supervisionados, a ideia geral é aprender a função que aproxime da melhor forma possível a distribuição dos dados disponíveis para treinamento do modelo. No caso da regressão, o modelo retorna um valor contínuo, e no caso da classificação, um valor (rótulo) discreto. Seja qual for o algoritmo, o objetivo é minimizar o erro entre o valor predito pelo modelo aproximado e os valores de referência usados para o treinamento. Isso é feito ao se definir uma função de custo que será minimizada. Portanto, a infinidade de diferentes modelos possíveis pode ser resumida na escolha desses 2 componentes: qual a forma da função usada para a aproximação, e qual a função de custo para a minimização. Diferentes algoritmos empregam diferentes estratégias na solução desse objetivo. Vamos apresentar os exemplos mais simples pra cada uma dessas tarefas, como forma de exemplificar essa ideia geral.
            No caso da regressão, o algoritmo mais simples e usado é conhecido como regressão Linear. Sua suposição básica é que os dados são normalmente distribuídos em relação a uma expressão ajustada, (4)y^(i)=θT⁢x(i) 
            onde o sobrescrito T denota o vetor transposto, y^(i) é o valor previsto e θ é o vetor de parâmetros (coeficientes) a serem aprendidos. A fim de obter os parâmetros θ, insere-se uma função de custo no modelo, que é dada por uma soma dos termos de erro usando mínimos quadrados, (5)J⁢(θ)=∑i=1nL⁢[y^(i)⁢(x(i),θ),y(i)]=12⁢∑i=1n(θT⁢x(i)-y(i))2+λ⁢∥θ∥p. 
            Ao minimizar a função acima com relação a seus parâmetros, encontra-se o melhor conjunto de θ para o problema em questão, levando assim a um modelo de ML treinado. O último termo inserido na função de custo é opcional, conhecido como parâmetro de regularização λ, sendo diferentes extensões da regressão linear, tal como a regressão ridge ou LASSO. O valor de p denota a métrica, p = 0 é simplesmente o número de coeficientes diferentes de zero (normalmente não considerados uma métrica formalmente) em θ enquanto p = 1 é referido como a métrica de Manhattan ou táxi, e p = 2 é a métrica euclidiana usual. Quando se usa p = 1, o modelo de regressão é LASSO (Least Absolute Shrinkage and Selection Operator), onde devido à restrição imposta ao problema de minimização, nem todas as features presentes nos descritores são consideradas para o ajuste. Por outro lado, a regressão ridge corresponde a p = 2, e o resultado neste caso é apenas a redução dos valores absolutos das features, ou seja, features com valores muito grandes são penalizados, somando à função de custo. Tanto no LASSO quanto na regressão ridge, o parâmetro λ controla a complexidade do modelo, diminuindo e/ou selecionando as features. Assim, em ambos os casos, é recomendável começar com um modelo mais complexo e usar λ para diminuir sua complexidade. O parâmetro λ, entretanto, não pode ser aprendido da mesma maneira que θ, sendo referido como um hiperparâmetro que deve ser ajustado por, por exemplo, uma busca em grid para encontrar aquele que maximiza o poder de previsão sem introduzir muito viés (bias).
            A classificação é usada para prever rótulos discretos. Um algoritmo de classificação muito popular é a regressão logística [20], que pode ser interpretado como um mapeamento das previsões feitas por regressão linear no intervalo [0, 1]. Vamos supor que a tarefa de classificação em questão é decidir se um dado ponto x(i) pertence a uma classe particular (y(i) = 1) ou não (y(i) = 0). A previsão binária desejada pode ser obtida a partir de (6)y^=σ⁢(θT⁢x)=11+e-θT⁢x 
            onde θ é novamente um vetor de parâmetros e σ é referido como a função logística ou sigmóide. Como exemplo, a função sigmóide junto com uma previsão de um conjunto de dados fictício é apresentada na Figura 6. Normalmente considera-se que a amostra x(i) pertence à classe rotulada por y(i) se y^(i)≥0.5 , mesmo que o rótulo previsto possa ser interpretado como uma probabilidade y^=P(y=1|x,θ). No caso da classificação, a função de custo é obtida a partir da log-probabilidade negativa. Assim, a obtenção dos melhores parâmetros θ requer a minimização dessa quantidade, dada por (7)J(θ)=-1n∑i=1n[y(i)log(y^(i))+(1-y(i))log(1-y^(i))] 
            onde y(i) e y^(i)=σ⁢(θT⁢x(i)) são os rótulos binários verdadeiros (de referência) e previstos. Um parâmetro de regularização λ pode ser inserido na equação (7) com a mesma intenção de selecionar as features, como visto na regressão linear anteriormente. Observe que a regressão logística também pode ser usada quando os dados apresentam várias classes. Neste caso, deve-se empregar a estratégia um-contra-todos, que consiste em treinar n modelos de regressão logística, um para cada classe, e prever os rótulos usando o classificador que apresentar maior probabilidade.
            Entre os métodos supervisionados, algoritmos populares de classificação são classificadores usando máquinas de vetores de suporte (support vector machines, SVM) [33] com uma variedade de funções kernel (linear, polinomial, Gaussiana, entre outras); o algoritmo não paramétrico k-nearest neighbors (k-NN); algoritmos probabilísticos como Naive Bayes; árvores de decisão [34, 35] e métodos relacionados de ensemble, como Random Forests [20] e gradient boosting. No caso de tarefas de regressão, regressão linear, Ridge e LASSO, bem como árvores de decisão e regressores de Random Forests são algoritmos simples e populares. Uma revisão recente sobre métodos de ML para ciência de materiais apresenta uma explicação abrangente do funcionamento interno de muitos desses algoritmos [6], e um vasto material também pode ser encontrado na literatura [18, 20, 21].
            Vale destacar separadamente, as redes neurais (neural networks, NN), particularmente profundas (deep learning) [21], que estão se tornando muito populares devido aos seus avanços recentes tal como para reconhecimento de imagens, bem como em tarefas de processamento de linguagem natural. Elas correspondem a uma classe de algoritmos que foram, pelo menos em seu início, inspiradas pela estrutura do cérebro. Uma NN pode ser descrita como um grafo direcionado ponderado, ou seja, uma estrutura composta por camadas contendo unidades de processamento chamadas neurônios, que por sua vez são conectadas a outras camadas, conforme ilustrado na Figura 6. Muitos tipos de NNs são usados para uma variedade de tarefas como regressão e classificação, e algumas das arquiteturas mais populares para tais redes são NNs feed-forward, recorrentes e convolucionais. As principais diferenças entre essas arquiteturas são basicamente os padrões de conexão e as operações que seus neurônios executam nos dados. Normalmente em uma NN, uma camada de entrada recebe os vetores de features do conjunto de treinamento, e uma série de operações não lineares é realizada enquanto os dados propagam através das subsequentes chamadas camadas ocultas. Finalmente, o resultado do processamento é coletado na camada de saída, que pode ser uma classificação binária ou multinária (probabilística), ou mesmo um mapeamento contínuo como em um modelo de regressão linear. Um ponto muito interessante nesse processo, é que a própria rede aprende representações otimizadas do conjunto de dados, normalmente ao custo de cojuntos de dados maiores, visto o número exponencialmente grande de coeficientes a serem determinados. Em uma NN, a entrada zi(k) do i-ésimo neurônio na k-ésima camada é uma função das saídas yj(k-1) da camada anterior
            
              
                (8)
                
                  
                    
                      z
                      i
                      
                        (
                        k
                        )
                      
                    
                    =
                    
                      
                        ω
                        
                          i
                          ⁢
                          0
                        
                        
                          (
                          k
                          )
                        
                      
                      +
                      
                        
                          ∑
                          j
                        
                        
                          
                            y
                            j
                            
                              (
                              
                                k
                                -
                                1
                              
                              )
                            
                          
                          ⁢
                          
                            ω
                            
                              i
                              ⁢
                              j
                            
                            
                              (
                              k
                              )
                            
                          
                        
                      
                    
                  
                
              
            
            onde ωi⁢j(k) é o elemento da matriz que conecta as camadas adjacentes. O elemento wi⁢0(k) é conhecido como viés (bias), porque não faz parte da combinação linear de entradas. A entrada é então transformada por meio de uma função não-linear ou de ativação, tal como a tangente hiperbólica,
            
              
                (9)
                
                  
                    
                      
                        y
                        i
                        
                          (
                          k
                          )
                        
                      
                      =
                      
                        
                          
                            e
                            
                              z
                              i
                              
                                (
                                k
                                )
                              
                            
                          
                          -
                          
                            e
                            
                              -
                              
                                z
                                i
                                
                                  (
                                  k
                                  )
                                
                              
                            
                          
                        
                        
                          
                            e
                            
                              z
                              i
                              
                                (
                                k
                                )
                              
                            
                          
                          +
                          
                            e
                            
                              -
                              
                                z
                                i
                                
                                  (
                                  k
                                  )
                                
                              
                            
                          
                        
                      
                    
                    ,
                  
                
              
            
            que resulta no mapeamento do vetor de entrada da camada anterior em um novo espaço vetorial, permitindo que a rede forneça predições para problemas altamente complexos.
            Por fim, vamos discutir como avaliar a qualidade dos modelos, métricas de desempenho e precauções a serem tomadas para gerar modelos coerentes. Um algoritmo de aprendizado supervisionado de ML é considerado treinado quando seus parâmetros ótimos dados as amostras de treinamento são encontrados, minimizando a função de custo. No entanto, os hiperparâmetros geralmente não podem ser aprendidos dessa maneira, e o estudo do desempenho do modelo em um conjunto separado, denominado conjunto de validação, em função de tais parâmetros é necessário. Este processo é conhecido como validação. A maneira usual de fazer isso é separar o conjunto de dados em 3 conjuntos separados: os conjuntos de treinamento, validação e teste. Espera-se que seus elementos sejam da mesma natureza, ou seja, venham da mesma distribuição estatística. O processo de aprendizagem é então realizado várias vezes para otimizar o modelo. Finalmente, usando o conjunto de teste, pode-se confrontar as previsões com os rótulos de referência e medir o quão bem o modelo está desempenhando. Particularmente em métodos supervisionados, dois problemas principais podem surgir então: (i) se os vetores de descritores apresentam um número insuficiente de features, ou seja, não é geral o suficiente para capturar as tendências nos dados e o modelo de regressão é considerado enviesado, e (ii) se o descritor apresenta muitas informações, o que faz com que o modelo de regressão se ajuste aos dados de treinamento excessivamente bem, mas sofre para generalizar para novos dados, então é dito que o modelo sofre sobre-ajuste (overfitting) ou variância. Esses são dois extremos da complexidade dos modelos, diretamente relacionado ao número de parâmetros, onde o equilíbrio ideal é representado na Figura 7. Normalmente se utiliza o parâmetro de regularização λ a fim de diminuir de forma sistemática a complexidade do modelo e encontrar o ponto ótimo. Figura 7Balanço entre viés (bias) × variância. A complexidade ideal do modelo é avaliada em relação ao erro das predições avaliadas no conjunto de teste. Adaptado de [6] CC BY 3.0. 
            Quando uma quantidade limitada de dados está disponível para treinamento, remover uma fração desse conjunto para criar o conjunto de teste pode impactar negativamente o processo de treinamento, e formas alternativas devem ser empregadas. Um dos métodos mais populares neste cenário é a validação cruzada, que consiste em particionar o conjunto de treinamento em k subconjuntos, treinar o modelo usando k-1 subconjuntos e validar o modelo treinado usando o conjunto que não foi usado para o treinamento. Este processo é executado k vezes e a média de cada etapa de validação é usada para calcular a média do desempenho,
            
              
                (10)
                
                  
                    
                      E
                      
                        c
                        ⁢
                        v
                      
                      K
                    
                    =
                    
                      
                        1
                        K
                      
                      ⁢
                      
                        
                          ∑
                          
                            k
                            =
                            1
                          
                          K
                        
                        
                          
                            ∑
                            
                              i
                              =
                              1
                            
                            
                              n
                              k
                            
                          
                          
                            L
                            ⁢
                            
                              (
                              
                                
                                  y
                                  ^
                                
                                k
                                
                                  (
                                  i
                                  )
                                
                              
                              ,
                              
                                y
                                
                                  (
                                  i
                                  )
                                
                              
                              )
                            
                          
                        
                      
                    
                  
                
              
            
            onde L é a função de perda e y^k(i) é o rótulo previsto do i-ésimo exemplo de treinamento do modelo treinado usando o subconjunto dos dados de treinamento, excluindo o subconjunto k, que tem o tamanho n_k.
            Existem muitas maneiras de avaliar o desempenho, sendo de suma importância particularmente para modelos supervisionados. Em tarefas de classificação binária ou multinária, é muito comum o uso de matrizes de confusão, onde o número de elementos preditos corretamente são apresentados nas entradas diagonais enquanto os elementos que foram preditos incorretamente são contados nas entradas fora da diagonal. Pode-se pensar no índice vertical como os rótulos reais e no índice horizontal como as previsões, e falsos (F) positivos (P) ou negativos (N) são previsões positivas para casos negativos e vice-versa, respectivamente. A curva de característica de operação do receptor (ROC curve) também é usada rotineiramente, sendo o gráfico da taxa de verdadeiros (V) positivos T⁢V⁢P=V⁢PV⁢P+F⁢N versus a taxa de falsos positivos T⁢F⁢P=F⁢PF⁢P+V⁢N variando o limiar inter-classes. Um exemplo é mostrado na Fig. 11a. Figura 11Resultados do modelo de ML e aplicação [24]. (a) Curva ROC e área sob a curva como métrica do modelo de classificação para cada classe: baixa (vermelho), média (laranja) e alta estabilidade (verde). (b) Importância das 20 features mais importantes do modelo de classificação. (c) Gráfico de paridade das energias de formação para a classe de alta estabilidade comparando os valores calculados por DFT com o modelo de regressão obtido via ML. O erro RMSE da validação cruzada é 0.205 eV/átomo. (d) Uso do modelo ML como critério de seleção de materiais para fotoeletrocatálise de água. Alinhamento de banda dos candidatos selecionados em relação ao vácuo. Os potenciais para as reações H+/H2 e O2/H2O estão destacados entre as linhas tracejadas. O candidato Sn2SeTe foi previsto pelo modelo de classificação. Adaptado com permissão de [24]. Copyright 2019 American Chemical Society. 
            No caso de tarefas de regressão, existem várias métricas da performance do ajuste. O erro médio absoluto M⁢A⁢E=1n⁢∑in|yi-y^i|, mede desvios na mesma unidade da variável e também não é sensível a outliers. Existe a versão normalizada expressa em porcentagem M⁢A⁢P⁢E=100%n⁢∑inyi-y^iyi. O erro quadrático médio M⁢S⁢E=1n⁢∑in(yi-y^i)2 combina medições de bias e variância da previsão. Do ponto de vista frequentista, a estimativa θ^m de um parâmetro de distribuição θ está intimamente relacionada com o MSE, através da fórmula M⁢S⁢E=𝔼⁢[(θ^m-θ)2]=B⁢i⁢a⁢s⁢(θ^m)2+V⁢a⁢r⁢(θ^m). O MSE, ou seja, a função de custo dada na equação (5) (quando se introduz ou não um parâmetro de regularização λ), idealmente seria zero para pontos de dados exatamente em cima da função obtida por meio da regressão. O MSE costuma ser utilizado tomando sua raiz (RMSE), que recupera a unidade original, facilitando a interpretação da precisão do modelo. Finalmente, também é utilizado o coeficiente de determinação estatístico R2, definido como R2=1-S⁢Sr⁢e⁢sS⁢St⁢o⁢t, onde a soma total dos quadrados é S⁢St⁢o⁢t=∑i(yi-y¯)2 e a soma residual dos quadrados é S⁢Sr⁢e⁢s=∑i(yi-y^i)2. O R2 é usualmente visualizado em gráficos de paridade, onde compara-se os valores preditos pelo modelo de ML com os valores de referência. Um exemplo é mostrado na Fig. 11c.
          
        
        Na prática, existem diversos softwares e programas computacionais que implementam os diferentes algoritmos de machine learning. Um dos mais acessíveis, completos e utilizados é o scikit-learn [36], implementado como uma biblioteca escrita em python. Uma implementação também acessível e com interface gráfica é o software Weka [37]. Duas das implementações mais utilizadas de deep learning são os códigos tensorflow [38] e pytorch [39]. Um tutorial prático introdutório de uso do machine learning com aplicações para materiais pode ser encontrado em [40].
        Finalmente, vale destacar que existe um balanço entre os diferentes componentes para cada determinado problema de ML. O tamanho do conjunto de dados, a representação usada e o algoritmo a ser empregado estão intimamente relacionados à construção de cada modelo e devem ser balanceados com cuidado, conforme discutido na Fig. 8. Em relação aos dados, na física, química e ciência de materiais, a natureza dos conjuntos de dados envolvidos é muito diferente daqueles com os quais o aprendizado de máquina foi historicamente projetado para trabalhar, que são, tamanhos grandes, espaços com poucas features de dimensionalidade fixa e baixa variância; sendo então caracterizado como “little-data” [46]. Para uma complexidade de descritor fixa, o número de pontos de dados necessários para o treinamento do modelo é uma quantidade chave. Poucos exemplos podem levar ao sobreajuste, isto é, o modelo se ajusta excessivamente bem aos dados, incluindo ruídos indesejáveis. Aumentando o número de pontos de treinamento, tal problema é minimizado ao custo de diminuir ligeiramente a precisão do conjunto de treinamento (curva azul Fig. 8a). Por outro lado, isso leva a uma melhor generalização do modelo, o que pode ser representado pelo aumento da precisão dos dados que não estavam presentes na etapa de treinamento (dados de validação, curva vermelha crescente na Fig. 8a). Para cada modelo, o tamanho do conjunto de dados necessário para convergência será diferente, e não pode ser determinadoa priori , mas avaliado por meio de curvas de aprendizado (Fig. 8a). Podemos pensar em uma escada de crescente complexidade na representação de materiais e moléculas (Fig. 8b), cada degrau fornecendo informações adicionais sobre os sistemas. No nível mais baixo, a informação depende apenas da fórmula química, ou seja, da composição elementar e estequiometria (escalares). No segundo nível, informações estruturais podem ser incluídas, como posições atômicas, conectividade e propriedades da rede. Nos níveis superiores, informações mais complexas, como estrutura eletrônica ou densidade local, podem ser introduzidas (vetores, tensores e outros). Para cada aplicação, é necessário incluir diferentes informações no descritor, de acordo com a natureza do problema. Portanto, para alguns problemas, features simples podem atingir a acurácia adequada, enquanto em outros problemas a acurácia é limitada. A tarefa da representação é otimizar o descritor, maximizando sua precisão ao mesmo tempo que mantém a maior simplicidade possível. Sempre que o grau de complexidade é aumentado, seja pela expansão do espaço de features ou pelo número de parâmetros a serem aprendidos no modelo de ML (Fig. 8c), a quantidade de dados de treinamento disponíveis deve aumentar de acordo. Finalmente, para qualquer algoritmo de ML, seu sucesso preditivo é determinado por um equilíbrio entre o conjunto de features disponíveis, a qualidade dos descritores, a otimização do algoritmo e, mais importante, a precisão dos dados usados para o treinamento [14]. Um primeiro passo para avaliação do sucesso do modelo de ML é verificar se o conjunto de features incluídas com o algoritmo utilizado é adequado para a descrição da propriedade-alvo de interesse. Isso pode ser verificado em relação às características estatísticas do próprio conjunto de dados, como o valor médio e desvio padrão da propriedade avaliada. Por exemplo, num problema de regressão, é possível comparar o erro médio obtido com um simples modelo de regressão linear usando as features iniciais com relação ao desvio padrão da propriedade. Se o resultado não for significativamente superior, pode ser um indicativo que um modelo linear não descreve bem a propriedade e/ou que as features incluídas não são suficientes para descrever o problema.
        
          Figura 8
          
            Detalhes dos componentes de Machine Learning: dados a., Descritores b. e algoritmos c.. a. Curva de aprendizado para um determinado modelo de ML, onde a precisão aumenta com o número de dados de treinamento até atingir o platô da capacidade (linha horizontal pontilhada). Por outro lado, a precisão do treinamento diminui como resultado da redução do overfitting inicial. b. Representações de ML para moléculas e de materiais. Em cada degrau, mais informações são adicionadas ao descritor, tornando o treinamento e a previsão mais custosos. O desafio é maximizar a acurácia ao mesmo tempo usando o descritor mais simples possível. c. Balanço entre de precisão e interpretabilidade dos algoritmos de aprendizado de máquina. Algoritmos complexos como Redes Neurais tendem a ser considerados caixas pretas no sentido que entender a importância de cada feature não é uma tarefa simples. A quantidade de dados de treinamento disponíveis deve ser compatível a complexidade do modelo. Adaptado com permissão de [14]. Copyright 2019 American Chemical Society.
       </span>
      </span>
     </span>
     <i>
      .i
     </i>
     , o ML pode ser uma ferramenta útil.
    </p>
    <p>
     Em ordem crescente de valor agregado e dificuldade, os problemas gerais enfrentados são: a substituição da coleta de propriedades/dados difíceis, complexos ou custosos; generalizar um padrão presente em um conjunto de dados para uma classe de dados semelhante; obter uma relação entre variáveis correlacionadas, mas com ligações desconhecidas ou indiretas, que está além da intuição ou do conhecimento de área; obtenção de um modelo geral aproximado para uma propriedade desconhecida complexa, ou fenômenos que não possuem teoria ou equações fundamentais [
     <span class="ref">
      <sup class="xref xrefblue">
       23
      </sup>
      <span class="refCtt closed">
       <span>
        23. R. Ramprasad, R. Batra, G. Pilania, A. Mannodi-Kanakkithodi e C. Kim, npj Computational Materials 3, 54 (2017).
       </span>
      </span>
     </span>
     ]. Historicamente, áreas que apresentam questões com essas características foram bem-sucedidas na aplicação dos métodos de ML, tal como nas áreas de automação, processamento de imagens e linguagem, ciências sociais, químicas e biológicas, e recentemente cada vez mais exemplos estão surgindo.
    </p>
    <p>
     Com base nessas características, especificamente aplicados à ciência de materiais, vislumbramos os tipos comuns de problemas que fazem uso de estratégias orientadas a dados, e que são exemplificados na Seção
     <span class="ref footnote">
      <sup class="xref">
       3
      </sup>
      <span class="refCtt closed">
       <span class="refCttPadding">
        3. Aplicações em Materiais: Descoberta e Design
      Como mostrado na seção anterior, o ML é uma ferramenta matemática e estatística, podendo então ser aplicada aos mais diferentes tipos de problemas. Nesse sentido, não apenas os problemas científicos em si podem ser estudados, como também tarefas que usualmente não são estudadas mas que existem dados disponíveis, tal como estimar o tempo que um processo computacional vai levar, permitindo sua otimização [47].
      No contexto específico de materais, o ML pode ser usado para a descoberta, design e otimização de propriedades tanto partindo de dados experimentais [48, 49, 50] como de simulação, e esta pode ser atomística (clássica) ou ab initio (quântica). Diferentes estratégias podem ser utilizadas, podendo ser amplamente classificadas [13] no aprendizado de propriedades (Fig. 9a): i) pré-equação de Schrödinger, como aprender a densidade eletrônica [41], para ser então usada como input para cálculos DFT ou próprio ML; ii) acelerar ou substituir a resolução da equação de Schrödinger, criando assim aproximações para resolver o problema quântico [42]; e iii) pós-equação de Schrödinger, aprendendo diretamente as saídas do problema, tal como as propriedades observáveis dos materiais. Especificamente na área de simulação de materiais, onde é possível gerar uma grande quantidade de dados consistentes para serem usados em tarefas de ML, atualmente existem três grandes áreas de pesquisas de acordo com o grau de complexidade e aproximações utilizadas (Fig. 9b): ML de hamiltonianos de muitos corpos; ML atomístico, gerando potenciais interatômicos e propriedades relacionadas, e ML de materiais a partir de resultados de simulações de DFT.
      
        Figura 9
        
          (a) Uso do machine learning em diferentes etapas de simulações de materiais: i) pré-equação de Schrödinger, por exemplo, aprendizado da densidade eletrônica obtida por DFT [41]; ii) substituindo [42] ou acelerando a equação de Schrödinger, tal como otimização bayesiana para relaxação da geometria, cálculos de barreiras energéticas [43] ou otimização global [44]; ou iii) pós-equação de Schrödinger, como o aprendizado direto das propriedades dos materiais [24]. (b) Áreas atuais de ML para ciência de materiais. O ML atomístico permite a exploração estrutural (otimização global) e propriedades, enquanto desconsidera os efeitos quânticos. O ML de hamiltonianos modelo permite a exploração de efeitos quânticos e de muitos corpos, embora é dificil a aplicação a sistemas de materiais reais. O ML de materiais ou DFT preenche a lacuna entre essas áreas [13], potenciais avanços são por exemplo a extração de hamiltonianos realistas a partir de cálculos DFT [45] e gerar funções de onda por ML de sistemas obtidos por simulações atomísticas [42]. Adaptado de [13] CC BY 3.0.
        
        
          
          
        
      
      Vamos apresentar dois exemplos representativos com diferentes níveis de aprendizado: 1) exploração do espaço de fase de materiais, tanto atômico como configuracional, na descoberta e design de novos materiais bidimensionais (2D); 2) descoberta de novas estruturas hipotéticas e/ou desconhecidas por otimização global no espaço configuracional, na busca e predição de estruturas de materiais usando potenciais atomísticos aprendidos por ML.
      
        3.1. Explorando o espaço atômico, composicional e configuracional
        Um dos grandes desafios da descoberta de materiais é descobrir o maior número possível de novos materiais, explorando simultaneamente os espaços atômico (elementos), composicional (estequiometrias) e configuracional (geometrias/estruturas) [13]. Portanto, o número de graus de liberdade é imenso, e a estratégia utilizada na busca (amostragem) neste espaço é de extrema importância. Quando se pensa em design inverso (Fig. 2), ou seja, a busca por materiais que apresentem certas funcionalidades desejadas, a exploração desse grande espaço de materiais é fundamental [51]. Portanto, técnicas de alta eficiência, evolutivas e de machine learning são cada vez mais importantes para amostrar com eficiência o espaço dos materiais, resultando em casos selecionados interessantes para investigação aprofundada.
        Na referência [24], os autores demonstraram como essa estratégia pode ser utilizada na descoberta de novos materiais 2D visando um posterior processo de filtragem e seleção de materiais para diversas aplicações. Um ponto fundamental que diferencia a aplicação de ML para a descoberta de materiais é que não há a informação a priori de qual será a geometria relaxada da estrutura a ser investigada, pois isso implicaria na necessidade de realização de simulações computacionais, justamente que espera-se que sejam substituídas pelo modelo preditivo. Dessa forma, a Fig. 10 apresenta a estratégia utilizada pelos autores. Tendo como ponto de partida apenas as propriedades atômicas e estequiométricas dos diferentes materiais, é possível prever em diferentes estruturas a estabilidade termodinâmica dos mesmos, que vai indicar a possibilidade de existência desse material de acordo com esse critério. Essa informação é o primeiro critério essencial num processo de filtragem e seleção de materiais. Tendo essa informação, é possível então investigar as diferentes propriedades dos materiais visando aplicações específicas.
        
          Figura 10
          
            Abordagem baseada em dados para descoberta, design e seleção de materiais. Do grande número de combinações possíveis entre elementos, estequiometrias e simetrias, o espaço de materiais é gerado. Usando dados termodinâmicos disponíveis em bancos de dados, com técnicas de aprendizado de máquina, é possível classificar os materiais quanto à sua estabilidade termodinâmica. Se necessário, um modelo de regressão pode prever as energias de formação em relação à fases rivais. Finalmente, os materiais estáveis podem ser selecionados para potenciais aplicações. Adaptado com permissão de [24]. Copyright 2019 American Chemical Society.
          
          
            
            
          
        
        Vamos descrever brevemente cada um dos quatro componentes do processo de machine learning (Fig. 4) para esse exemplo.
        
          
            Definição do problema: o objetivo do estudo é a predição e compreensão da estabilidade termodinâmica dos diferentes materiais bidimensionais. Portanto, os autores trataram como um problema de apredizado supervisionado, em dois graus de detalhamento. Um modelo de classificação inicial para determinar se um material tem baixa, média ou alta estabilidade, baseado nos critérios de energia de formação (em relação às fases elementais) e em relação às fases rivais (chamada de convex hull). Posteriormente, um segundo modelo de regressão pode obter os valores numéricos dessas quantidades, se desejado.
          
          
            Dados: Foi utilizado o banco de dados computacional de materiais 2D C2DB [52], que possui cálculos baseados na teoria do funcional da densidade (DFT) de materiais 2D distribuídos entre diferentes protótipos comuns. Essas diferentes estruturas prototípicas são decoradas de maneira combinatória com diferentes átomos de toda a tabela periódica, resultando em um total de 3712 materiais 2D na versão utilizada. Para cada um dos materiais calculados, são armazenados os dados da geometria de menor energia após relaxação estrutural, energias total, de formação, em relação à outras fases, e diversas propriedades tal como eletrônicas, mecânicas, magnéticas, entre outras. Os autores utilizaram as energia de formação e de convex hull como o alvo dos modelos de machine learning, definindo três classes para a classificação: baixa, para materiais com energia de formação positiva (se decompõe em seus elementos); média, para materiais com energia de formação negativa, porém metaestável em relação à outras fases por uma diferença maior que 0.2 eV/átomo (dificilmente podendo ser estabilizada por diferentes estratégias); e alta estabilidade, para materiais com energia de formação negativa, e estáveis ou metaestáveis em relação à outras fases por uma diferença de até 0.2 eV/átomo (valores de energia compatíveis com materiais já sintetizados em substratos, por exemplo) [24].
          
          
            Representação: como dito acima, um ponto crucial é evitar a utilização de dados das posições atômicas, que requereriam a execução de simulações computacionais custosas a serem feitas em larga escala. Dessa forma, para distinguir as estruturas, foi usado um rótulo categórico para denotar cada um dos prótótipos estruturais (por exemplo, estruturas idealizadas “tipo” grafeno, MoS2, também conhecida como fase 2H, e assim sucessivamente). Adicionalmente, os autores utilizaram como features apenas dados de estequiometria e propriedades atômicas dos elementos que constituem os materiais, como número atômico, eletronegatividade, valência, autovalores de Kohn-Sham, polarizabilidade e raios atômicos. Dessa forma, nenhuma informação adicional é necessária para predição de novos materiais. Para tratar materiais com diferentes estequiometrias e número de espécies atômicas, por exemplo, A, AB2, ABC3, etc, em uma representação de mesma dimensionalidade (ou seja, número de colunas de seu vetor de features), os autores utilizaram diferentes valores estatísticos das propriedades atômicas, tal como o valor mínimo, máximo, médio e desvio padrão, como sugerido na referência [53].
          
          
            Algoritmos, validação, e aplicação: Tal como discutido no final de seção 2, a combinação de features incluídas com o algoritmo escolhido deve ser capaz de descrever satisfatoriamente a propriedade-alvo de interesse. Para esse exemplo, foi avaliado que o conjunto inicial de features não garante bons resultados independentemente da classe de algoritmo utilizado (linear ou não, paramétrico ou não). Portanto, um primeiro passo foi utilizar o algoritmo SISSO [54] (regressão linear com regularização de norma ℓ0) para fazer um processo de engenharia de features de forma automatizada. Assumindo que a propriedade de interesse pode ser descrita por uma combinação não-linear das features iniciais, o algoritmo realiza a geração de novas features por meio de um processo combinatório das features inicias, ao realizar operações selecionadas entre elas, tal como soma/subtração, multiplicação/divisão, exponenciais/logaritmo, potências, etc. Associado com um algoritmo baseado em um ensemble de árvores de decisão, gradient boosting, os autores atingiram boa performance na classificação (em torno de 90%) tanto na validação do modelo realizada com validação cruzada, como no teste para dados inéditos, visualizada com a métrica da área sobre a curva ROC, mostrada na Fig. 11a. Uma informação interessante é a importância de cada feature para a capacidade preditiva do modelo (Fig. 11b), podendo ser usada para compreensão do problema. Adicionalmente, para cada uma das classe de estabilidade, os autores treinaram modelos de regressão usando o algoritmo SISSO para obtenção de valores aproximados da energia de formação, necessária para o cálculo da estabilidade em relação às fases rivais para decomposição. Na Figura 11c é mostrado um gráfico de paridade entre os valores previstos e os valores de referência para a classe dos materiais altamente estáveis, onde modelos com melhor performance se aproximam mais da diagonal (R2 = 1). Esse modelo apresentou R2 = 0.9, com um erro RMSE de 0.205 eV/átomo, que é em torno de três vezes inferior ao desvio padrão dos dados em si.
            Tendo o modelo treinado, é então possível realizar a predição e descoberta de novos materiais até então não investigados. Os autores demonstraram essa capacidade ao gerar milhares de novas combinações inéditas em diferentes protótipos estruturais, satisfazendo regras de valência e neutralidade de carga, e então gerar a predição da estabilidade de cada um desses materiais. Para verificar se a predição de fato se mostrava acurada, realizaram cálculos DFT dessa propriedade para alguns materiais selecionados, e verificaram que em todos os casos a predição se mostrou correta. Finalmente, demonstrando a aplicabilidade do modelo de estabilidade, os autores executaram um processo de filtragem e seleção de materiais para geração de hidrogênio a partir da quebra fotoeletrocatalítica de moléculas de água, como prova de conceito. Num processo de seleção de materiais, a estabilidade termodinâmica é o primeiro critério essencial para escolha de um material para qualquer aplicação. Aplicando o modelo treinado, e adicionalmente os filtros de gap de energia eletrônico entre 1.23 e 3 eV e alinhamento de banda de energia adequado para os processos de oxidação e redução da água, encontraram materiais 2D promissores para essa aplicação (Fig. 11d), do qual o material PbTe ainda não havia sido sugerido para essa aplicação na literatura. Adicionalmente, baseado na similaridade estrutural e química dos candidatos promissores, previram a estabilidade e calcularam a viabilidade do novo material Sn2SeTe para essa aplicação [24].
          
        
      
      
        3.2. Explorando o espaço configuracional
        Similarmente ao processo de descoberta de materiais no espaço atômico, composicional e configuracional, há situações em que se é desejado manter uma dessas variáveis fixa, reduzindo assim a complexidade da busca. Por exemplo, pode-se desejar realizar a busca apenas em uma estrutura específica, eliminando assim a variável configuracional, ou buscar apenas materiais formados por determinados elementos, eliminando a variável atômica e realizando uma busca no espaço estrutural e composicional. Vamos apresentar um exemplo desse último caso.
        A predição estrutural é um dos principais sucessos obtidos com métodos quânticos de primeiros princípios, visto que as propriedades dos materiais dependem sensivelmente de sua estrutura. As ferramentas de otimização global têm a capacidade de descobrir materiais para os quais existe pouca ou nenhuma informação empírica, sejam estruturas cristalinas, moleculares, defeitos, superfícies e interfaces [56]. O número possível de estruturas distintas é imenso mesmo para sistemas relativamente simples, da ordem de 10N, onde N é o número de átomos na célula unitária [56]. Nesse contexto, é impossível investigar todas as combinações possíveis, e estratégias para amostrar eficientemente esse espaço de materiais é fundamental. O uso do ML nesse contexto é ideal. Em [55], os autores propõe o treinamento do zero e de forma automatizada de potenciais atomísticos de ML, sem nenhuma informação de quais estruturas são relevantes ou não. Essa forma de aprendizagem ativa converge e permite então a amostragem de grande parte do espaço configuracional de interesse, permitindo a descoberta de materiais de relevância real. A Fig. 12 apresenta a estratégia utilizada pelos autores.
        
          Figura 12
          
            Protocolo automatizado que explora iterativamente o espaço estrutural e treina potenciais interatômicos baseados em ML [55]. De um conjunto aleatório inicial de células unitárias (azul), são selecionadas as geometricamente mais diversas usando o algoritmo CUR. As estruturas selecionadas são calculadas com DFT e usadas para treinar um potencial de ML (GAP) (laranja). Esse potencial é usado para relaxar um novo conjunto de estruturas aleatórias (verde), selecionando novamente os casos mais relevantes e repetindo o ciclo até a convergência, encerrando assim a busca. Adaptado de [55] CC BY 4.0.
          
          
            
            
          
        
        Vamos descrever brevemente cada um dos quatro componentes do processo de machine learning (Fig. 4) para esse exemplo.
        
          
            Definição do problema: o objetivo do estudo é a descoberta de materiais do zero e automatizada, explorando o espaço estrutural de forma iterativa ao treinar potenciais atomísticos baseados em ML. Portanto, nesse caso a tarefa de ML é um problema de apredizado supervisionado, onde é feita a regressão dos parâmetros otimizados de potenciais interatômicos que irão descrever as interações dos materiais.
          
          
            Dados: a proposta é a geração ativa e iterativa dos dados durante o treinamento do modelo de ML, como mostrado na Fig. 12. Os dados são o conjunto de estruturas e energias e forças atômicas associadas à cada uma delas, obtidas com cálculos de DFT. Inicialmente é gerado um conjunto de estruturas aleatórias, e selecionado um subconjunto de acordo com a maior diversidade estrutural para serem calculadas. Com essas informações, um potencial de ML é treinado, e o processo se repete, porém agora as estruturas aleatórias são relaxadas com o potencial obtido antes da seleção do subconjunto a ser calculado. O processo iterativo é executado até obter resultados de energias e forças satisfatórios, no estudo em torno de 2500 cálculos fixos foram necessários [55].
          
          
            Representação: o treinamento de um potencial interatômico de ML busca a descrição da superfície de energia potencial (PES) dos sistemas em função das posições dos átomos. Dessa forma, a representação detalhada dos ambientes atômicos é de extrema importância. Os autores utilizam a representação chamada de sobreposição suave de posições atômicas (SOAP) [57], em que a densidade de vizinhos de um átomo i é expandida em uma base local de funções radiais g_n e harmônicos esféricos Ylm: (11)ρi⁢(R)=∑je⁢x⁢p⁢(-|r-ri⁢j|2/2⁢σa⁢t2) (12)=∑n⁢l⁢mcn⁢l⁢m(i)⁢gn⁢(r)⁢Yl⁢m⁢(r^), 
            onde j são os vizinhos do átomo dentro de um raio de corte especificado.
          
          
            Algoritmos, validação, e aplicação: os autores treinam potenciais de aproximações Gaussianas (GAP) [58], que combinam o descritor SOAP apresentado acima com a regressão kernel ridge, obtendo as contribuições atômicas da energia total: ε⁢(q)=∑k=1Nαk⁢K⁢(q,qk), onde q e qk são o descritor do ambiente local do átomo de referência e de outro átomo, N é o número de diferentes configurações de treinamento, indexadas por k. A tarefa de ML que vai determinar o vetor de coeficientes α, e K é uma função não-linear fixa, chamada de kernel, que tem como objetivo medir a similaridade entre os ambientes atômicos de seus dois argumentos. O kernel SOAP é mostrado na equação (11).
            Os autores aplicam a estratégia descrita para descoberta de alótropos em diferentes sistemas. Um caso desafiador de ser capturado é o boro, um dos elementos estruturalmente mais complexos. O protocolo é capaz de descobrir a estrutura do α−B12 de forma autônoma, como mostrado na Fig. 13a. Percebe-se que o protocolo atinge alta acurácia permitindo a descoberta de materiais sem intervenção do cientista. O método não se limita a um sistema específico, por exemplo, consegue aprender corretamente a estrutura e energias relativas de diferentes alótropos de carbono com alta precisão (Fig. 13b-c).
            Resultados similares são obtidos para diferentes sistemas isolantes, semicondutores e metálicos [55], permitindo a obtenção de importante informação estrutural na descoberta de materiais.
          
        
        
          Figura 13
          
            Resultados do modelo de ML e aplicação [55]. (a) Aprendizagem da estrutura cristalina do boro α-romboédrico. Esquerda: erro do modelo GAP gerado iterativamente, para a estrutura otimizada de menor energia do α−B12, em relação ao DFT. São comparadas a seleção aleatória de pontos (cinza), o procedimento de seleção usando CUR com descritores SOAP (verde), e o mesmo mas usando CUR com kernels SOAP (roxo). Direita: Evolução do icosaedro B12 como o principal fragmento estrutural, para três pontos nos N ciclos, 400 (A), 500 (B) e 2500 (C) cálculos DFT no total. A respectiva estrutura de menor energia da iteração é mostrada. (b) Aprendizagem de diversas estruturas cristalinas de carbono sem conhecimento prévio. Erro entre as energias calculadas por DFT e GAP para as estruturas otimizadas com cada método. (c) Curvas de energia-volume calculadas com o modelo GAP final (linhas sólidas) e a referência DFT (linhas tracejadas). Energias em relação à menor energia obtida com DFT. Adaptado de [55] CC BY 4.0.
       </span>
      </span>
     </span>
     . O primeiro é a obtenção de modelos para fenômenos que possuem relações ou mecanismos desconhecidos. Uma estratégia relacionada é substituir a descrição de uma propriedade muito complexa ou onerosa de ser obtida (mas que é parcialmente conhecida pelo menos para uma pequena classe de materiais) por um modelo de ML mais simples, tornando seu cálculo menos custoso. Se devidamente validado, este modelo pode então prever a propriedade para exemplos desconhecidos, expandindo o conjunto de dados [
     <span class="ref">
      <sup class="xref xrefblue">
       24
      </sup>
      <span class="refCtt closed">
       <span>
        24. G.R. Schleder, C.M. Acosta e A. Fazzio, ACS Applied Materials &amp; Interfaces 12, 20149 (2020).
       </span>
      </span>
     </span>
     ]. No contexto da descoberta e design de materiais, esta estratégia pode ser empregada como uma forma de estender o conjunto de dados antes da seleção e triagem, onde os dados custosos iniciais levam a mais dados por meio do modelo de ML, que podem então ser filtrados para encontrar novos candidatos promissores. Outros problemas usam técnicas de seleção de características para descobrir modelos e descritores aproximados (uma forma de impressão digital do sistema, ver seção
     <span class="ref footnote">
      <sup class="xref">
       2.3
      </sup>
      <span class="refCtt closed">
       <span class="refCttPadding">
        2.3. Como usar?
        De maneira geral, podemos organizar o problema de machine learning em 4 passos fundamentais como ilustrado na Fig. 4 que são detalhados a seguir: i) definição do problema; ii) dados; iii) representação; e iv) algoritmos, validação, e aplicação.
        
          Figura 4
          
            Os quatro componentes básicos do processo de machine learning. Adaptado de [13] CC BY 3.0.
          
          
            
            
          
        
        
          
            Definição do problema: primeiramente vamos discutir quais os tipos de problemas mais comuns a serem tratados com machine learning. Formalmente, o problema de aprendizagem pode ser descrito [25] por: dado um conjunto de dados conhecido X – onde a notação X indica que é um vetor com uma ou várias variáveis –, prever ou aproximar a função de interesse desconhecida y = f(X), em função desses dados conhecidos. O conjunto X é denominado espaço de features de input (também conhecido como atributos ou características) e um elemento x dele é chamado de vetor de features, ou simplesmente uma entrada. Com a função aproximada aprendiday^=f^⁢(X), o modelo pode então prever a saída para exemplos desconhecidos fora dos dados usados para o treinamento, e sua capacidade de fazer isso é chamada de generalização do modelo. Existem algumas categorias de problemas de ML de acordo com os tipos de entradas e saídas tratadas, sendo as duas principais as aprendizagens supervisionada e não supervisionada.
            Na aprendizagem não supervisionada, também conhecida como descritiva, o objetivo é encontrar estruturas nos dados brutos xi ∈ X fornecidos sem rótulos, ou seja, não se usa ou não existem dados de saída y conhecidos. Se f(X) é finito, o aprendizado é denominado agrupamento (clustering), que agrupa dados em um número (conhecido ou desconhecido) de grupos pela similaridade em suas características. Por outro lado, se f(X) está em uma distribuição [0,∞), a aprendizagem é chamada de estimativa de densidade, que aprende a distribuição marginal das características. Outro tipo importante de aprendizagem não supervisionada é a redução de dimensionalidade, que comprime o número de variáveis de entrada para representar os dados, útil quando f(X) tem alta dimensionalidade e, portanto, uma estrutura de dados complexa para ser visualizada e usada na detecção de padrões.
            Por outro lado, na aprendizagem supervisionada ou preditiva, o objetivo é aprender a função que leva as entradas às saídas alvo (target), tendo um conjunto de dados rotulados (xi,yi) ∈ (X,f(X)), conhecido como conjunto de treinamento (ao contrário do conjunto de teste desconhecido), com i = N número de exemplos. Se a saída y_i é um conjunto finito categórico ou nominal (por exemplo, se um material é um metal ou isolante), o problema é chamado de classificação, que prevê o rótulo de classe para amostras desconhecidas. Caso contrário, se as saídas são escalares contínuos de valor real yi ∈ ℝ, o problema é então chamado de regressão, que irá prever os valores de saída para os exemplos desconhecidos. Veremos os algoritmos relacionados na seção iv) adiante.
            Outros tipos de problemas de ML são a aprendizagem semi-supervisionada, em que um grande número de dados não rotulados é combinado com um pequeno número de dados rotulados; a aprendizagem multi-tarefa; a transferência de aprendizagem, onde informações de problemas relacionados são exploradas para melhorar a tarefa de aprendizagem (geralmente uma com poucos dados disponíveis [26]); e o chamado aprendizado por reforço, no qual nenhuma entrada/saída é fornecida, mas sim feedbacks sobre as decisões como um meio de maximizar um sinal de recompensa, levando ao aprendizado de ações desejadas em determinados ambientes.
          
          
            Dados (inputs): a disponibilidade de dados é componente fundamental para qualquer processo de machine learning. Os resultados a serem obtidos no processo serão tão bons quanto a quantidade e qualidade dos dados que serão utilizados. Qualidade nesse contexto se refere que os dados sejam representativos do problema a ser estudado, consistentes, e que possuam informação relacionada à tarefa ser realizada [14]. Portanto, o processo para chegar num conjunto de dados de qualidade leva algumas etapas. Inicialmente, a etapa de coleta e/ou curadoria dos dados para geração e seleção de um subconjunto relevante e útil de dados disponíveis para a resolução dos problemas. Posteriormente, o pré-processamento de dados, que busca uma formatação adequada dos dados, limpeza de dados corrompidos e ausentes, transformação dos dados conforme necessário por operações como normalização, discretização, cálculo da média, suavizar ou diferenciar, conversão uniforme para inteiros, double ou strings e amostragem adequada para otimizar a representatividade do conjunto [6]. Tendo os dados brutos tecnicamente corretos, é possível a próxima etapa de escolha da representação adequada ao problema.
          
          
            Representação: também chamada de impressão digital (fingerprint) ou descritor [27], a representação determinará a capacidade e o desempenho do processo de machine learning. Somente se as variáveis necessárias forem representadas que o algoritmo será capaz de aprender a relação desejada. Essa etapa mapeia em um vetor as diferentes variáveis de entrada (features de input) disponíveis que descrevem e identificam as amostras (no presente contexto, os materiais). Alguns requisitos desejáveis universais são propostos [28, 6, 14], tais como: a representação deve ser a) completa (suficiente para diferenciar os exemplos), b) única (dois exemplos terão a mesma representação apenas se forem de fato iguais), c) discriminativos (sistemas similares ou diferentes serão caracterizados por representações similares ou diferentes), e d) eficiente e simples de ser obtido (o cálculo da representação em si deve ser rápido). Esses requisitos apresentados servem para garantir que os modelos sejam eficientes usando apenas informações essenciais. Para qualquer novo problema de machine learning, o processo de engenharia de features, que engloba a seleção, combinação, e transformação destas, é responsável pela maior parte dos esforços e do tempo usado no projeto [29].
          
          
            Algoritmos, validação, e aplicação: A tarefa de construir e utilizar algoritmos é um estudo caso a caso. Nenhum algoritmo de ML é universalmente superior [30, 31]. Em particular, a escolha do algoritmo de aprendizagem é uma etapa fundamental na construção de um pipeline de ML, e muitas opções estão disponíveis, cada uma adequada para um determinado problema e/ou conjunto de dados. Esse conjunto de dados pode ser de dois tipos: rotulado ou não rotulado. Como vimos, no primeiro caso, a tarefa é encontrar o mapeamento entre os pontos dos dados e os rótulos correspondentes {x(i)}→{y(i)} por meio de um algoritmo de aprendizagem supervisionada. Por outro lado, se não há rótulos no conjunto de dados, a tarefa é encontrar uma estrutura dentro dos dados, utilizando o aprendizado não supervisionado. A seguir apresentamos de maneira breve um exemplo simples e os principais algoritmos para cada um dos tipos de problemas de ML que apresentamos na seção 2.3. i. Esses tipos de problemas e os algoritmos relacionados são resumidos na Figura 5. Figura 5Algoritmos de machine learning e diagrama de uso, divididos nos principais tipos de problemas: aprendizado não supervisionado (redução de dimensionalidade e clustering) e supervisionado (classificação e regressão). Adaptado de [6] CC BY 3.0. 
            Redução de dimensionalidade. Devido à grande abundância de dados, pode-se facilmente obter vetores de features de tamanho incrivelmente grandes, levando ao que é conhecido como “maldição da dimensionalidade”. Por exemplo, imagine um algoritmo de ML que recebe como entrada imagens de n×n pixels em escala de cinza, cada um representado como um valor numérico. Nesse caso, a matriz que contém esses números é achatada em um vetor de comprimento n2, o vetor de características, descrevendo esse ponto (amostra) em um espaço de alta dimensionalidade. Devido à dependência exponencial, um número grande de dimensões é facilmente atingido para imagens de tamanho médio. A memória ou o poder de processamento computacional tornam-se fatores limitantes neste caso. Um ponto chave é que dentro da nuvem de dados de alta dimensão abrangida pelo conjunto de dados, pode-se encontrar uma estrutura de dimensão inferior. O conjunto de pontos pode ser projetado em um hiperplano ou variedade, reduzindo sua dimensionalidade enquanto preserva a maior parte das informações contidas na nuvem de dados original. Uma série de procedimentos com esse objetivo, como análise de componentes principais (PCA) são rotineiramente empregados em algoritmos de ML [32]. Em poucas palavras, a PCA é uma rotação de cada eixo do sistema de coordenadas do espaço onde residem os pontos de dados, levando à maximização da variância ao longo desses eixos. A maneira de descobrir para onde o novo eixo deve apontar é obtendo o autovetor correspondente ao maior autovalor de XTX, onde X é a matriz de dados. Uma vez que o maior autovetor de variância, também conhecido como o componente principal, é encontrado, os pontos são projetados nele, resultando em uma compressão dos dados. Usualmente escolhe-se um número de componentes principais que irão descrever a maior parte da variância do conjunto de dados. A generalização dos algoritmos de redução de dimensionalidade para estruturas não-lineares é chamada de manifold learning, dos quais exemplos conhecidos são o multi-dimensional scaling (MDS), isometric mapping (Isomap) e t-distributed stochastic neighbor embedding (t-SNE).
            Clustering. O clustering hierárquico é um método empregado na aprendizagem não supervisionada, podendo ser de dois tipos, aglomerativo ou divisivo. O primeiro pode ser descrito por um algoritmo simples: começando com n classes, ou clusters, cada um deles contendo um único exemplo x(i) do conjunto de treinamento, e então é medida a dissimilaridade d(A,B) entre pares de clusters rotulados A e B. Os dois clusters com a menor dissimilaridade, ou seja, mais semelhantes, são mesclados em um novo cluster. O processo é então repetido recursivamente até que apenas um cluster, contendo todos os elementos do conjunto de treinamento, permaneça. O processo pode ser melhor visualizado traçando um dendrograma, tal como mostrado na Figura 6. Para agrupar os dados em k clusters, 1 &lt; k &lt; n, o usuário deve cortar a estrutura hierárquica obtida em alguma etapa intermediária do agrupamento. Há certa liberdade na escolha da medida de dissimilaridade d(A,B), e três medidas principais são populares. Primeiro, a ligação única leva em consideração o par mais próximo de membros do cluster, Figura 6(a) Dendrograma demonstrando o clustering hierárquico. O código de cores é um guia para visualizar os clusters, representados pelas linhas verticais. As linhas horizontais indicam a fusão de dois clusters. O número de cruzamentos entre a linha horizontal e as linhas dos clusters corresponde ao número de clusters em uma determinada altura selecionada, no exemplo da linha tracejada cinza, são cinco clusters. (b) Exemplo da função sigmóide e a classificação de exemplos negativos em vermelho e positivos em azul na regressão logística. A seta cinza aponta para os dados classificados incorretamente no conjunto de dados. Adaptado de [6] CC BY 3.0. (c) Exemplo de uma rede neural com N camadas ocultas e um único neurônio na camada de output. (1)dS⁢L⁢(A,B)=mini∈A,j∈B⁡di⁢j 
            onde dij é uma medida de dissimilaridade de membros do par. Em segundo lugar, a ligação completa considera o par mais distante ou mais diferente de cada cluster, (2)dC⁢L⁢(A,B)=maxi∈A,j∈B⁡di⁢j 
            e, finalmente, o agrupamento da média do grupo considera a dissimilaridade média, representando um balanço entre as duas medidas anteriores, (3)dG⁢A⁢(A,B)=1|A|⁢|B|⁢∑i∈A∑j∈Bdi⁢j. 
            A forma particular de dij também pode ser escolhida, geralmente sendo considerada a distância euclidiana para dados numéricos. A menos que os dados disponíveis sejam altamente agrupados, a escolha da medida de dissimilaridade pode resultar em dendrogramas distintos e, portanto, clusters distintos. Como o nome sugere, o clustering divisivo executa a operação oposta, começando com um único cluster contendo todos os exemplos do conjunto de dados e o divide recursivamente de forma que a dissimilaridade do cluster seja maximizada. O processo termina quando cada cluster possuir uma entrada. Da mesma forma, requer que o usuário determine a linha de corte para agrupar os dados. Outros algoritmos de clustering bastante utilizados são o K-médias (K-means) e o DBSCAN.
            Supervisionado: Regressão e Classificação. No caso dos algoritmos supervisionados, a ideia geral é aprender a função que aproxime da melhor forma possível a distribuição dos dados disponíveis para treinamento do modelo. No caso da regressão, o modelo retorna um valor contínuo, e no caso da classificação, um valor (rótulo) discreto. Seja qual for o algoritmo, o objetivo é minimizar o erro entre o valor predito pelo modelo aproximado e os valores de referência usados para o treinamento. Isso é feito ao se definir uma função de custo que será minimizada. Portanto, a infinidade de diferentes modelos possíveis pode ser resumida na escolha desses 2 componentes: qual a forma da função usada para a aproximação, e qual a função de custo para a minimização. Diferentes algoritmos empregam diferentes estratégias na solução desse objetivo. Vamos apresentar os exemplos mais simples pra cada uma dessas tarefas, como forma de exemplificar essa ideia geral.
            No caso da regressão, o algoritmo mais simples e usado é conhecido como regressão Linear. Sua suposição básica é que os dados são normalmente distribuídos em relação a uma expressão ajustada, (4)y^(i)=θT⁢x(i) 
            onde o sobrescrito T denota o vetor transposto, y^(i) é o valor previsto e θ é o vetor de parâmetros (coeficientes) a serem aprendidos. A fim de obter os parâmetros θ, insere-se uma função de custo no modelo, que é dada por uma soma dos termos de erro usando mínimos quadrados, (5)J⁢(θ)=∑i=1nL⁢[y^(i)⁢(x(i),θ),y(i)]=12⁢∑i=1n(θT⁢x(i)-y(i))2+λ⁢∥θ∥p. 
            Ao minimizar a função acima com relação a seus parâmetros, encontra-se o melhor conjunto de θ para o problema em questão, levando assim a um modelo de ML treinado. O último termo inserido na função de custo é opcional, conhecido como parâmetro de regularização λ, sendo diferentes extensões da regressão linear, tal como a regressão ridge ou LASSO. O valor de p denota a métrica, p = 0 é simplesmente o número de coeficientes diferentes de zero (normalmente não considerados uma métrica formalmente) em θ enquanto p = 1 é referido como a métrica de Manhattan ou táxi, e p = 2 é a métrica euclidiana usual. Quando se usa p = 1, o modelo de regressão é LASSO (Least Absolute Shrinkage and Selection Operator), onde devido à restrição imposta ao problema de minimização, nem todas as features presentes nos descritores são consideradas para o ajuste. Por outro lado, a regressão ridge corresponde a p = 2, e o resultado neste caso é apenas a redução dos valores absolutos das features, ou seja, features com valores muito grandes são penalizados, somando à função de custo. Tanto no LASSO quanto na regressão ridge, o parâmetro λ controla a complexidade do modelo, diminuindo e/ou selecionando as features. Assim, em ambos os casos, é recomendável começar com um modelo mais complexo e usar λ para diminuir sua complexidade. O parâmetro λ, entretanto, não pode ser aprendido da mesma maneira que θ, sendo referido como um hiperparâmetro que deve ser ajustado por, por exemplo, uma busca em grid para encontrar aquele que maximiza o poder de previsão sem introduzir muito viés (bias).
            A classificação é usada para prever rótulos discretos. Um algoritmo de classificação muito popular é a regressão logística [20], que pode ser interpretado como um mapeamento das previsões feitas por regressão linear no intervalo [0, 1]. Vamos supor que a tarefa de classificação em questão é decidir se um dado ponto x(i) pertence a uma classe particular (y(i) = 1) ou não (y(i) = 0). A previsão binária desejada pode ser obtida a partir de (6)y^=σ⁢(θT⁢x)=11+e-θT⁢x 
            onde θ é novamente um vetor de parâmetros e σ é referido como a função logística ou sigmóide. Como exemplo, a função sigmóide junto com uma previsão de um conjunto de dados fictício é apresentada na Figura 6. Normalmente considera-se que a amostra x(i) pertence à classe rotulada por y(i) se y^(i)≥0.5 , mesmo que o rótulo previsto possa ser interpretado como uma probabilidade y^=P(y=1|x,θ). No caso da classificação, a função de custo é obtida a partir da log-probabilidade negativa. Assim, a obtenção dos melhores parâmetros θ requer a minimização dessa quantidade, dada por (7)J(θ)=-1n∑i=1n[y(i)log(y^(i))+(1-y(i))log(1-y^(i))] 
            onde y(i) e y^(i)=σ⁢(θT⁢x(i)) são os rótulos binários verdadeiros (de referência) e previstos. Um parâmetro de regularização λ pode ser inserido na equação (7) com a mesma intenção de selecionar as features, como visto na regressão linear anteriormente. Observe que a regressão logística também pode ser usada quando os dados apresentam várias classes. Neste caso, deve-se empregar a estratégia um-contra-todos, que consiste em treinar n modelos de regressão logística, um para cada classe, e prever os rótulos usando o classificador que apresentar maior probabilidade.
            Entre os métodos supervisionados, algoritmos populares de classificação são classificadores usando máquinas de vetores de suporte (support vector machines, SVM) [33] com uma variedade de funções kernel (linear, polinomial, Gaussiana, entre outras); o algoritmo não paramétrico k-nearest neighbors (k-NN); algoritmos probabilísticos como Naive Bayes; árvores de decisão [34, 35] e métodos relacionados de ensemble, como Random Forests [20] e gradient boosting. No caso de tarefas de regressão, regressão linear, Ridge e LASSO, bem como árvores de decisão e regressores de Random Forests são algoritmos simples e populares. Uma revisão recente sobre métodos de ML para ciência de materiais apresenta uma explicação abrangente do funcionamento interno de muitos desses algoritmos [6], e um vasto material também pode ser encontrado na literatura [18, 20, 21].
            Vale destacar separadamente, as redes neurais (neural networks, NN), particularmente profundas (deep learning) [21], que estão se tornando muito populares devido aos seus avanços recentes tal como para reconhecimento de imagens, bem como em tarefas de processamento de linguagem natural. Elas correspondem a uma classe de algoritmos que foram, pelo menos em seu início, inspiradas pela estrutura do cérebro. Uma NN pode ser descrita como um grafo direcionado ponderado, ou seja, uma estrutura composta por camadas contendo unidades de processamento chamadas neurônios, que por sua vez são conectadas a outras camadas, conforme ilustrado na Figura 6. Muitos tipos de NNs são usados para uma variedade de tarefas como regressão e classificação, e algumas das arquiteturas mais populares para tais redes são NNs feed-forward, recorrentes e convolucionais. As principais diferenças entre essas arquiteturas são basicamente os padrões de conexão e as operações que seus neurônios executam nos dados. Normalmente em uma NN, uma camada de entrada recebe os vetores de features do conjunto de treinamento, e uma série de operações não lineares é realizada enquanto os dados propagam através das subsequentes chamadas camadas ocultas. Finalmente, o resultado do processamento é coletado na camada de saída, que pode ser uma classificação binária ou multinária (probabilística), ou mesmo um mapeamento contínuo como em um modelo de regressão linear. Um ponto muito interessante nesse processo, é que a própria rede aprende representações otimizadas do conjunto de dados, normalmente ao custo de cojuntos de dados maiores, visto o número exponencialmente grande de coeficientes a serem determinados. Em uma NN, a entrada zi(k) do i-ésimo neurônio na k-ésima camada é uma função das saídas yj(k-1) da camada anterior
            
              
                (8)
                
                  
                    
                      z
                      i
                      
                        (
                        k
                        )
                      
                    
                    =
                    
                      
                        ω
                        
                          i
                          ⁢
                          0
                        
                        
                          (
                          k
                          )
                        
                      
                      +
                      
                        
                          ∑
                          j
                        
                        
                          
                            y
                            j
                            
                              (
                              
                                k
                                -
                                1
                              
                              )
                            
                          
                          ⁢
                          
                            ω
                            
                              i
                              ⁢
                              j
                            
                            
                              (
                              k
                              )
                            
                          
                        
                      
                    
                  
                
              
            
            onde ωi⁢j(k) é o elemento da matriz que conecta as camadas adjacentes. O elemento wi⁢0(k) é conhecido como viés (bias), porque não faz parte da combinação linear de entradas. A entrada é então transformada por meio de uma função não-linear ou de ativação, tal como a tangente hiperbólica,
            
              
                (9)
                
                  
                    
                      
                        y
                        i
                        
                          (
                          k
                          )
                        
                      
                      =
                      
                        
                          
                            e
                            
                              z
                              i
                              
                                (
                                k
                                )
                              
                            
                          
                          -
                          
                            e
                            
                              -
                              
                                z
                                i
                                
                                  (
                                  k
                                  )
                                
                              
                            
                          
                        
                        
                          
                            e
                            
                              z
                              i
                              
                                (
                                k
                                )
                              
                            
                          
                          +
                          
                            e
                            
                              -
                              
                                z
                                i
                                
                                  (
                                  k
                                  )
                                
                              
                            
                          
                        
                      
                    
                    ,
                  
                
              
            
            que resulta no mapeamento do vetor de entrada da camada anterior em um novo espaço vetorial, permitindo que a rede forneça predições para problemas altamente complexos.
            Por fim, vamos discutir como avaliar a qualidade dos modelos, métricas de desempenho e precauções a serem tomadas para gerar modelos coerentes. Um algoritmo de aprendizado supervisionado de ML é considerado treinado quando seus parâmetros ótimos dados as amostras de treinamento são encontrados, minimizando a função de custo. No entanto, os hiperparâmetros geralmente não podem ser aprendidos dessa maneira, e o estudo do desempenho do modelo em um conjunto separado, denominado conjunto de validação, em função de tais parâmetros é necessário. Este processo é conhecido como validação. A maneira usual de fazer isso é separar o conjunto de dados em 3 conjuntos separados: os conjuntos de treinamento, validação e teste. Espera-se que seus elementos sejam da mesma natureza, ou seja, venham da mesma distribuição estatística. O processo de aprendizagem é então realizado várias vezes para otimizar o modelo. Finalmente, usando o conjunto de teste, pode-se confrontar as previsões com os rótulos de referência e medir o quão bem o modelo está desempenhando. Particularmente em métodos supervisionados, dois problemas principais podem surgir então: (i) se os vetores de descritores apresentam um número insuficiente de features, ou seja, não é geral o suficiente para capturar as tendências nos dados e o modelo de regressão é considerado enviesado, e (ii) se o descritor apresenta muitas informações, o que faz com que o modelo de regressão se ajuste aos dados de treinamento excessivamente bem, mas sofre para generalizar para novos dados, então é dito que o modelo sofre sobre-ajuste (overfitting) ou variância. Esses são dois extremos da complexidade dos modelos, diretamente relacionado ao número de parâmetros, onde o equilíbrio ideal é representado na Figura 7. Normalmente se utiliza o parâmetro de regularização λ a fim de diminuir de forma sistemática a complexidade do modelo e encontrar o ponto ótimo. Figura 7Balanço entre viés (bias) × variância. A complexidade ideal do modelo é avaliada em relação ao erro das predições avaliadas no conjunto de teste. Adaptado de [6] CC BY 3.0. 
            Quando uma quantidade limitada de dados está disponível para treinamento, remover uma fração desse conjunto para criar o conjunto de teste pode impactar negativamente o processo de treinamento, e formas alternativas devem ser empregadas. Um dos métodos mais populares neste cenário é a validação cruzada, que consiste em particionar o conjunto de treinamento em k subconjuntos, treinar o modelo usando k-1 subconjuntos e validar o modelo treinado usando o conjunto que não foi usado para o treinamento. Este processo é executado k vezes e a média de cada etapa de validação é usada para calcular a média do desempenho,
            
              
                (10)
                
                  
                    
                      E
                      
                        c
                        ⁢
                        v
                      
                      K
                    
                    =
                    
                      
                        1
                        K
                      
                      ⁢
                      
                        
                          ∑
                          
                            k
                            =
                            1
                          
                          K
                        
                        
                          
                            ∑
                            
                              i
                              =
                              1
                            
                            
                              n
                              k
                            
                          
                          
                            L
                            ⁢
                            
                              (
                              
                                
                                  y
                                  ^
                                
                                k
                                
                                  (
                                  i
                                  )
                                
                              
                              ,
                              
                                y
                                
                                  (
                                  i
                                  )
                                
                              
                              )
                            
                          
                        
                      
                    
                  
                
              
            
            onde L é a função de perda e y^k(i) é o rótulo previsto do i-ésimo exemplo de treinamento do modelo treinado usando o subconjunto dos dados de treinamento, excluindo o subconjunto k, que tem o tamanho n_k.
            Existem muitas maneiras de avaliar o desempenho, sendo de suma importância particularmente para modelos supervisionados. Em tarefas de classificação binária ou multinária, é muito comum o uso de matrizes de confusão, onde o número de elementos preditos corretamente são apresentados nas entradas diagonais enquanto os elementos que foram preditos incorretamente são contados nas entradas fora da diagonal. Pode-se pensar no índice vertical como os rótulos reais e no índice horizontal como as previsões, e falsos (F) positivos (P) ou negativos (N) são previsões positivas para casos negativos e vice-versa, respectivamente. A curva de característica de operação do receptor (ROC curve) também é usada rotineiramente, sendo o gráfico da taxa de verdadeiros (V) positivos T⁢V⁢P=V⁢PV⁢P+F⁢N versus a taxa de falsos positivos T⁢F⁢P=F⁢PF⁢P+V⁢N variando o limiar inter-classes. Um exemplo é mostrado na Fig. 11a. Figura 11Resultados do modelo de ML e aplicação [24]. (a) Curva ROC e área sob a curva como métrica do modelo de classificação para cada classe: baixa (vermelho), média (laranja) e alta estabilidade (verde). (b) Importância das 20 features mais importantes do modelo de classificação. (c) Gráfico de paridade das energias de formação para a classe de alta estabilidade comparando os valores calculados por DFT com o modelo de regressão obtido via ML. O erro RMSE da validação cruzada é 0.205 eV/átomo. (d) Uso do modelo ML como critério de seleção de materiais para fotoeletrocatálise de água. Alinhamento de banda dos candidatos selecionados em relação ao vácuo. Os potenciais para as reações H+/H2 e O2/H2O estão destacados entre as linhas tracejadas. O candidato Sn2SeTe foi previsto pelo modelo de classificação. Adaptado com permissão de [24]. Copyright 2019 American Chemical Society. 
            No caso de tarefas de regressão, existem várias métricas da performance do ajuste. O erro médio absoluto M⁢A⁢E=1n⁢∑in|yi-y^i|, mede desvios na mesma unidade da variável e também não é sensível a outliers. Existe a versão normalizada expressa em porcentagem M⁢A⁢P⁢E=100%n⁢∑inyi-y^iyi. O erro quadrático médio M⁢S⁢E=1n⁢∑in(yi-y^i)2 combina medições de bias e variância da previsão. Do ponto de vista frequentista, a estimativa θ^m de um parâmetro de distribuição θ está intimamente relacionada com o MSE, através da fórmula M⁢S⁢E=𝔼⁢[(θ^m-θ)2]=B⁢i⁢a⁢s⁢(θ^m)2+V⁢a⁢r⁢(θ^m). O MSE, ou seja, a função de custo dada na equação (5) (quando se introduz ou não um parâmetro de regularização λ), idealmente seria zero para pontos de dados exatamente em cima da função obtida por meio da regressão. O MSE costuma ser utilizado tomando sua raiz (RMSE), que recupera a unidade original, facilitando a interpretação da precisão do modelo. Finalmente, também é utilizado o coeficiente de determinação estatístico R2, definido como R2=1-S⁢Sr⁢e⁢sS⁢St⁢o⁢t, onde a soma total dos quadrados é S⁢St⁢o⁢t=∑i(yi-y¯)2 e a soma residual dos quadrados é S⁢Sr⁢e⁢s=∑i(yi-y^i)2. O R2 é usualmente visualizado em gráficos de paridade, onde compara-se os valores preditos pelo modelo de ML com os valores de referência. Um exemplo é mostrado na Fig. 11c.
          
        
        Na prática, existem diversos softwares e programas computacionais que implementam os diferentes algoritmos de machine learning. Um dos mais acessíveis, completos e utilizados é o scikit-learn [36], implementado como uma biblioteca escrita em python. Uma implementação também acessível e com interface gráfica é o software Weka [37]. Duas das implementações mais utilizadas de deep learning são os códigos tensorflow [38] e pytorch [39]. Um tutorial prático introdutório de uso do machine learning com aplicações para materiais pode ser encontrado em [40].
        Finalmente, vale destacar que existe um balanço entre os diferentes componentes para cada determinado problema de ML. O tamanho do conjunto de dados, a representação usada e o algoritmo a ser empregado estão intimamente relacionados à construção de cada modelo e devem ser balanceados com cuidado, conforme discutido na Fig. 8. Em relação aos dados, na física, química e ciência de materiais, a natureza dos conjuntos de dados envolvidos é muito diferente daqueles com os quais o aprendizado de máquina foi historicamente projetado para trabalhar, que são, tamanhos grandes, espaços com poucas features de dimensionalidade fixa e baixa variância; sendo então caracterizado como “little-data” [46]. Para uma complexidade de descritor fixa, o número de pontos de dados necessários para o treinamento do modelo é uma quantidade chave. Poucos exemplos podem levar ao sobreajuste, isto é, o modelo se ajusta excessivamente bem aos dados, incluindo ruídos indesejáveis. Aumentando o número de pontos de treinamento, tal problema é minimizado ao custo de diminuir ligeiramente a precisão do conjunto de treinamento (curva azul Fig. 8a). Por outro lado, isso leva a uma melhor generalização do modelo, o que pode ser representado pelo aumento da precisão dos dados que não estavam presentes na etapa de treinamento (dados de validação, curva vermelha crescente na Fig. 8a). Para cada modelo, o tamanho do conjunto de dados necessário para convergência será diferente, e não pode ser determinadoa priori , mas avaliado por meio de curvas de aprendizado (Fig. 8a). Podemos pensar em uma escada de crescente complexidade na representação de materiais e moléculas (Fig. 8b), cada degrau fornecendo informações adicionais sobre os sistemas. No nível mais baixo, a informação depende apenas da fórmula química, ou seja, da composição elementar e estequiometria (escalares). No segundo nível, informações estruturais podem ser incluídas, como posições atômicas, conectividade e propriedades da rede. Nos níveis superiores, informações mais complexas, como estrutura eletrônica ou densidade local, podem ser introduzidas (vetores, tensores e outros). Para cada aplicação, é necessário incluir diferentes informações no descritor, de acordo com a natureza do problema. Portanto, para alguns problemas, features simples podem atingir a acurácia adequada, enquanto em outros problemas a acurácia é limitada. A tarefa da representação é otimizar o descritor, maximizando sua precisão ao mesmo tempo que mantém a maior simplicidade possível. Sempre que o grau de complexidade é aumentado, seja pela expansão do espaço de features ou pelo número de parâmetros a serem aprendidos no modelo de ML (Fig. 8c), a quantidade de dados de treinamento disponíveis deve aumentar de acordo. Finalmente, para qualquer algoritmo de ML, seu sucesso preditivo é determinado por um equilíbrio entre o conjunto de features disponíveis, a qualidade dos descritores, a otimização do algoritmo e, mais importante, a precisão dos dados usados para o treinamento [14]. Um primeiro passo para avaliação do sucesso do modelo de ML é verificar se o conjunto de features incluídas com o algoritmo utilizado é adequado para a descrição da propriedade-alvo de interesse. Isso pode ser verificado em relação às características estatísticas do próprio conjunto de dados, como o valor médio e desvio padrão da propriedade avaliada. Por exemplo, num problema de regressão, é possível comparar o erro médio obtido com um simples modelo de regressão linear usando as features iniciais com relação ao desvio padrão da propriedade. Se o resultado não for significativamente superior, pode ser um indicativo que um modelo linear não descreve bem a propriedade e/ou que as features incluídas não são suficientes para descrever o problema.
        
          Figura 8
          
            Detalhes dos componentes de Machine Learning: dados a., Descritores b. e algoritmos c.. a. Curva de aprendizado para um determinado modelo de ML, onde a precisão aumenta com o número de dados de treinamento até atingir o platô da capacidade (linha horizontal pontilhada). Por outro lado, a precisão do treinamento diminui como resultado da redução do overfitting inicial. b. Representações de ML para moléculas e de materiais. Em cada degrau, mais informações são adicionadas ao descritor, tornando o treinamento e a previsão mais custosos. O desafio é maximizar a acurácia ao mesmo tempo usando o descritor mais simples possível. c. Balanço entre de precisão e interpretabilidade dos algoritmos de aprendizado de máquina. Algoritmos complexos como Redes Neurais tendem a ser considerados caixas pretas no sentido que entender a importância de cada feature não é uma tarefa simples. A quantidade de dados de treinamento disponíveis deve ser compatível a complexidade do modelo. Adaptado com permissão de [14]. Copyright 2019 American Chemical Society.
       </span>
      </span>
     </span>
     .
     <i>
      iii
     </i>
     ), que auxiliam na compreensão fenomenológica do problema. O mais abundante são os problemas claramente vantajosos em que cálculos dispendiosos computacionalmente podem ser substituídos por um modelo muito mais eficiente, como a substituição de cálculos
     <i>
      ab initio
     </i>
     por modelos ML, como na obtenção direta de propriedades ou de potenciais atomísticos para simulações de dinâmica molecular, que então prevêem o valor de diferentes propriedades tais como o gap eletrônico, energias livres, de formação, total, de defeitos, condutividades, difusividade, propriedades térmicas, ópticas, magnéticas, entre muitas outras.
    </p>
    <h2>
     2.3. Como usar?
    </h2>
    <p>
     De maneira geral, podemos organizar o problema de machine learning em 4 passos fundamentais como ilustrado na Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F4" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      4
     </a>
     que são detalhados a seguir:
     <i>
      i)
     </i>
     definição do problema;
     <i>
      ii)
     </i>
     dados;
     <i>
      iii)
     </i>
     representação; e
     <i>
      iv)
     </i>
     algoritmos, validação, e aplicação.
    </p>
    <div class="row fig" id="S2_F4">
     <a name="S2_F4">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigS2_F4" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/527bfc2960ca394903e8baec6179d5d54620f4d0.jpg"/>
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <strong>
       Figura 4
      </strong>
      <br/>
      Os quatro componentes básicos do processo de machine learning. Adaptado de [
      <span class="ref">
       <sup class="xref xrefblue">
        13
       </sup>
       <span class="refCtt closed">
        <span>
         13. F. Giustino, M. Bibes, J.H. Lee, F. Trier, R. Valentí, S.M. Winter, Y.W. Son, L. Taillefer, C. Heil, A.I. Figueroa et al., Journal of Physics: Materials, 10.1088/2515-7639/abb74e (2020).
        </span>
        <br/>
        <a href="https://doi.org/10.1088/2515-7639/abb74ehttps://doi.org/10.1088/2515-7639/abb74e" target="_blank">
         https://doi.org/10.1088/2515-7639/abb74e...
        </a>
       </span>
      </span>
      ]
      <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">
       CC BY 3.0
      </a>
      .
      <br/>
     </div>
    </div>
    <ol type="i">
     <li>
      <p>
       Definição do problema: primeiramente vamos discutir quais os tipos de problemas mais comuns a serem tratados com machine learning. Formalmente, o problema de aprendizagem pode ser descrito [
       <span class="ref">
        <sup class="xref xrefblue">
         25
        </sup>
        <span class="refCtt closed">
         <span>
          25. S.W. Knox, Machine Learning (John Wiley &amp; Sons, Hoboken, 2018).
         </span>
        </span>
       </span>
       ] por: dado um conjunto de dados conhecido
       <b>
        X
       </b>
       – onde a notação
       <b>
        X
       </b>
       indica que é um vetor com uma ou várias variáveis –, prever ou aproximar a função de interesse desconhecida
       <i>
        y
       </i>
       =
       <i>
        f
       </i>
       (
       <b>
        X
       </b>
       ), em função desses dados conhecidos. O conjunto
       <b>
        X
       </b>
       é denominado
       <i>
        espaço de features
       </i>
       de input (também conhecido como atributos ou características) e um elemento
       <b>
        x
       </b>
       dele é chamado de
       <i>
        vetor de features
       </i>
       , ou simplesmente uma entrada. Com a função aproximada aprendida
       <math id="INEQ6">
        <mrow>
         <mover accent="true">
          <mi>
           y
          </mi>
          <mo>
           ^
          </mo>
         </mover>
         <mo>
          =
         </mo>
         <mrow>
          <mover accent="true">
           <mi>
            f
           </mi>
           <mo>
            ^
           </mo>
          </mover>
          <mo>
           ⁢
          </mo>
          <mrow>
           <mo stretchy="false">
            (
           </mo>
           <mi mathvariant="bold">
            X
           </mi>
           <mo stretchy="false">
            )
           </mo>
          </mrow>
         </mrow>
        </mrow>
       </math>
       , o modelo pode então prever a saída para exemplos desconhecidos fora dos dados usados para o treinamento, e sua capacidade de fazer isso é chamada de
       <i>
        generalização
       </i>
       do modelo. Existem algumas categorias de problemas de ML de acordo com os tipos de entradas e saídas tratadas, sendo as duas principais as aprendizagens
       <i>
        supervisionada
       </i>
       e
       <i>
        não supervisionada
       </i>
       .
      </p>
      <p>
       Na
       <i>
        aprendizagem não supervisionada
       </i>
       , também conhecida como descritiva, o objetivo é encontrar estruturas nos dados brutos
       <b>
        x
       </b>
       <sub>
        <i>
         i
        </i>
       </sub>
       ∈
       <b>
        X
       </b>
       fornecidos sem rótulos, ou seja, não se usa ou não existem dados de saída
       <i>
        y
       </i>
       conhecidos. Se
       <i>
        f
       </i>
       (
       <b>
        X
       </b>
       ) é finito, o aprendizado é denominado
       <i>
        agrupamento (clustering)
       </i>
       , que agrupa dados em um número (conhecido ou desconhecido) de grupos pela similaridade em suas características. Por outro lado, se
       <i>
        f
       </i>
       (
       <b>
        X
       </b>
       ) está em uma distribuição [0,∞), a aprendizagem é chamada de
       <i>
        estimativa de densidade
       </i>
       , que aprende a distribuição marginal das características. Outro tipo importante de aprendizagem não supervisionada é a
       <i>
        redução de dimensionalidade
       </i>
       , que comprime o número de variáveis de entrada para representar os dados, útil quando
       <i>
        f
       </i>
       (
       <b>
        X
       </b>
       ) tem alta dimensionalidade e, portanto, uma estrutura de dados complexa para ser visualizada e usada na detecção de padrões.
      </p>
      <p>
       Por outro lado, na
       <i>
        aprendizagem supervisionada
       </i>
       ou preditiva, o objetivo é aprender a função que leva as entradas às saídas alvo (
       <i>
        target
       </i>
       ), tendo um conjunto de dados rotulados (
       <i>
        x
       </i>
       <sub>
        <i>
         i
        </i>
       </sub>
       ,
       <i>
        y
       </i>
       <sub>
        <i>
         i
        </i>
       </sub>
       ) ∈ (
       <b>
        X
       </b>
       ,
       <i>
        f
       </i>
       (
       <b>
        X
       </b>
       )), conhecido como
       <i>
        conjunto de treinamento
       </i>
       (ao contrário do
       <i>
        conjunto de teste
       </i>
       desconhecido), com
       <i>
        i = N
       </i>
       número de exemplos. Se a saída
       <i>
        y_i
       </i>
       é um conjunto finito categórico ou nominal (por exemplo, se um material é um metal ou isolante), o problema é chamado de
       <i>
        classificação
       </i>
       , que prevê o rótulo de classe para amostras desconhecidas. Caso contrário, se as saídas são escalares contínuos de valor real
       <i>
        y
       </i>
       <sub>
        <i>
         i
        </i>
       </sub>
       ∈
       <i>
        ℝ
       </i>
       , o problema é então chamado de
       <i>
        regressão
       </i>
       , que irá prever os valores de saída para os exemplos desconhecidos. Veremos os algoritmos relacionados na seção
       <i>
        iv)
       </i>
       adiante.
      </p>
      <p>
       Outros tipos de problemas de ML são a aprendizagem
       <i>
        semi-supervisionada
       </i>
       , em que um grande número de dados não rotulados é combinado com um pequeno número de dados rotulados; a aprendizagem
       <i>
        multi-tarefa
       </i>
       ; a
       <i>
        transferência de aprendizagem
       </i>
       , onde informações de problemas relacionados são exploradas para melhorar a tarefa de aprendizagem (geralmente uma com poucos dados disponíveis [
       <span class="ref">
        <sup class="xref xrefblue">
         26
        </sup>
        <span class="refCtt closed">
         <span>
          26. M.L. Hutchinson, E. Antono, B.M. Gibbons, S. Paradiso, J. Ling e B. Meredig, arXiv:1711.05099 (2017).
         </span>
        </span>
       </span>
       ]); e o chamado
       <i>
        aprendizado por reforço
       </i>
       , no qual nenhuma entrada/saída é fornecida, mas sim feedbacks sobre as decisões como um meio de maximizar um sinal de recompensa, levando ao aprendizado de ações desejadas em determinados ambientes.
      </p>
     </li>
     <li>
      <p>
       Dados (inputs): a disponibilidade de dados é componente fundamental para qualquer processo de machine learning. Os resultados a serem obtidos no processo serão tão bons quanto a quantidade e qualidade dos dados que serão utilizados. Qualidade nesse contexto se refere que os dados sejam representativos do problema a ser estudado, consistentes, e que possuam informação relacionada à tarefa ser realizada [
       <span class="ref">
        <sup class="xref xrefblue">
         14
        </sup>
        <span class="refCtt closed">
         <span>
          14. G.R. Schleder, A.C.M. Padilha, A.R. Rocha, G.M. Dalpian e A. Fazzio, Journal of Chemical Information and Modeling 60, 452 (2020).
         </span>
        </span>
       </span>
       ]. Portanto, o processo para chegar num conjunto de dados de qualidade leva algumas etapas. Inicialmente, a etapa de coleta e/ou curadoria dos dados para geração e seleção de um subconjunto relevante e útil de dados disponíveis para a resolução dos problemas. Posteriormente, o pré-processamento de dados, que busca uma formatação adequada dos dados, limpeza de dados corrompidos e ausentes, transformação dos dados conforme necessário por operações como normalização, discretização, cálculo da média, suavizar ou diferenciar, conversão uniforme para inteiros,
       <i>
        double
       </i>
       ou
       <i>
        strings
       </i>
       e amostragem adequada para otimizar a representatividade do conjunto [
       <span class="ref">
        <sup class="xref xrefblue">
         6
        </sup>
        <span class="refCtt closed">
         <span>
          6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
         </span>
        </span>
       </span>
       ]. Tendo os dados brutos tecnicamente corretos, é possível a próxima etapa de escolha da representação adequada ao problema.
      </p>
     </li>
     <li>
      <p>
       Representação: também chamada de impressão digital (
       <i>
        fingerprint
       </i>
       ) ou descritor [
       <span class="ref">
        <sup class="xref xrefblue">
         27
        </sup>
        <span class="refCtt closed">
         <span>
          27. L.M. Ghiringhelli, J. Vybiral, S.V. Levchenko, C. Draxl e M. Scheffler, Physical Review Letters 114, 105503 (2015).
         </span>
        </span>
       </span>
       ], a representação determinará a capacidade e o desempenho do processo de machine learning. Somente se as variáveis necessárias forem representadas que o algoritmo será capaz de aprender a relação desejada. Essa etapa mapeia em um vetor as diferentes variáveis de entrada (
       <i>
        features
       </i>
       de input) disponíveis que descrevem e identificam as amostras (no presente contexto, os materiais). Alguns requisitos desejáveis universais são propostos [
       <span class="ref">
        <sup class="xref xrefblue">
         28
        </sup>
        <span class="refCtt closed">
         <span>
          28. L. Ward e C. Wolverton, Current Opinion in Solid State and Materials Science 21, 167 (2016).
         </span>
        </span>
       </span>
       ,
       <span class="ref">
        <sup class="xref xrefblue">
         6
        </sup>
        <span class="refCtt closed">
         <span>
          6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
         </span>
        </span>
       </span>
       ,
       <span class="ref">
        <sup class="xref xrefblue">
         14
        </sup>
        <span class="refCtt closed">
         <span>
          14. G.R. Schleder, A.C.M. Padilha, A.R. Rocha, G.M. Dalpian e A. Fazzio, Journal of Chemical Information and Modeling 60, 452 (2020).
         </span>
        </span>
       </span>
       ], tais como: a representação deve ser
       <i>
        a
       </i>
       ) completa (suficiente para diferenciar os exemplos),
       <i>
        b
       </i>
       ) única (dois exemplos terão a mesma representação apenas se forem de fato iguais),
       <i>
        c
       </i>
       ) discriminativos (sistemas similares ou diferentes serão caracterizados por representações similares ou diferentes), e
       <i>
        d
       </i>
       ) eficiente e simples de ser obtido (o cálculo da representação em si deve ser rápido). Esses requisitos apresentados servem para garantir que os modelos sejam eficientes usando apenas informações essenciais. Para qualquer novo problema de machine learning, o processo de engenharia de features, que engloba a seleção, combinação, e transformação destas, é responsável pela maior parte dos esforços e do tempo usado no projeto [
       <span class="ref">
        <sup class="xref xrefblue">
         29
        </sup>
        <span class="refCtt closed">
         <span>
          29. P. Domingos, Commun. ACM 55, 78 (2012).
         </span>
        </span>
       </span>
       ].
      </p>
     </li>
     <li>
      <p>
       Algoritmos, validação, e aplicação: A tarefa de construir e utilizar algoritmos é um estudo caso a caso. Nenhum algoritmo de ML é universalmente superior [
       <span class="ref">
        <sup class="xref xrefblue">
         30
        </sup>
        <span class="refCtt closed">
         <span>
          30. D.H. Wolpert e W.G. Macready, Mach. Learn. 20, 273 (1995).
         </span>
        </span>
       </span>
       ,
       <span class="ref">
        <sup class="xref xrefblue">
         31
        </sup>
        <span class="refCtt closed">
         <span>
          31. D.H. Wolpert, Neural Comput. 8, 1341 (1996).
         </span>
        </span>
       </span>
       ]. Em particular, a escolha do algoritmo de aprendizagem é uma etapa fundamental na construção de um pipeline de ML, e muitas opções estão disponíveis, cada uma adequada para um determinado problema e/ou conjunto de dados. Esse conjunto de dados pode ser de dois tipos: rotulado ou não rotulado. Como vimos, no primeiro caso, a tarefa é encontrar o mapeamento entre os pontos dos dados e os rótulos correspondentes {
       <b>
        x
       </b>
       <sup>
        (
        <i>
         i
        </i>
        )
       </sup>
       }→{
       <i>
        y
       </i>
       <sup>
        (
        <i>
         i
        </i>
        )
       </sup>
       } por meio de um algoritmo de aprendizagem supervisionada. Por outro lado, se não há rótulos no conjunto de dados, a tarefa é encontrar uma estrutura dentro dos dados, utilizando o aprendizado não supervisionado. A seguir apresentamos de maneira breve um exemplo simples e os principais algoritmos para cada um dos tipos de problemas de ML que apresentamos na seção
       <span class="ref footnote">
        <sup class="xref">
         2.3
        </sup>
        <span class="refCtt closed">
         <span class="refCttPadding">
          2.3. Como usar?
        De maneira geral, podemos organizar o problema de machine learning em 4 passos fundamentais como ilustrado na Fig. 4 que são detalhados a seguir: i) definição do problema; ii) dados; iii) representação; e iv) algoritmos, validação, e aplicação.
        
          Figura 4
          
            Os quatro componentes básicos do processo de machine learning. Adaptado de [13] CC BY 3.0.
          
          
            
            
          
        
        
          
            Definição do problema: primeiramente vamos discutir quais os tipos de problemas mais comuns a serem tratados com machine learning. Formalmente, o problema de aprendizagem pode ser descrito [25] por: dado um conjunto de dados conhecido X – onde a notação X indica que é um vetor com uma ou várias variáveis –, prever ou aproximar a função de interesse desconhecida y = f(X), em função desses dados conhecidos. O conjunto X é denominado espaço de features de input (também conhecido como atributos ou características) e um elemento x dele é chamado de vetor de features, ou simplesmente uma entrada. Com a função aproximada aprendiday^=f^⁢(X), o modelo pode então prever a saída para exemplos desconhecidos fora dos dados usados para o treinamento, e sua capacidade de fazer isso é chamada de generalização do modelo. Existem algumas categorias de problemas de ML de acordo com os tipos de entradas e saídas tratadas, sendo as duas principais as aprendizagens supervisionada e não supervisionada.
            Na aprendizagem não supervisionada, também conhecida como descritiva, o objetivo é encontrar estruturas nos dados brutos xi ∈ X fornecidos sem rótulos, ou seja, não se usa ou não existem dados de saída y conhecidos. Se f(X) é finito, o aprendizado é denominado agrupamento (clustering), que agrupa dados em um número (conhecido ou desconhecido) de grupos pela similaridade em suas características. Por outro lado, se f(X) está em uma distribuição [0,∞), a aprendizagem é chamada de estimativa de densidade, que aprende a distribuição marginal das características. Outro tipo importante de aprendizagem não supervisionada é a redução de dimensionalidade, que comprime o número de variáveis de entrada para representar os dados, útil quando f(X) tem alta dimensionalidade e, portanto, uma estrutura de dados complexa para ser visualizada e usada na detecção de padrões.
            Por outro lado, na aprendizagem supervisionada ou preditiva, o objetivo é aprender a função que leva as entradas às saídas alvo (target), tendo um conjunto de dados rotulados (xi,yi) ∈ (X,f(X)), conhecido como conjunto de treinamento (ao contrário do conjunto de teste desconhecido), com i = N número de exemplos. Se a saída y_i é um conjunto finito categórico ou nominal (por exemplo, se um material é um metal ou isolante), o problema é chamado de classificação, que prevê o rótulo de classe para amostras desconhecidas. Caso contrário, se as saídas são escalares contínuos de valor real yi ∈ ℝ, o problema é então chamado de regressão, que irá prever os valores de saída para os exemplos desconhecidos. Veremos os algoritmos relacionados na seção iv) adiante.
            Outros tipos de problemas de ML são a aprendizagem semi-supervisionada, em que um grande número de dados não rotulados é combinado com um pequeno número de dados rotulados; a aprendizagem multi-tarefa; a transferência de aprendizagem, onde informações de problemas relacionados são exploradas para melhorar a tarefa de aprendizagem (geralmente uma com poucos dados disponíveis [26]); e o chamado aprendizado por reforço, no qual nenhuma entrada/saída é fornecida, mas sim feedbacks sobre as decisões como um meio de maximizar um sinal de recompensa, levando ao aprendizado de ações desejadas em determinados ambientes.
          
          
            Dados (inputs): a disponibilidade de dados é componente fundamental para qualquer processo de machine learning. Os resultados a serem obtidos no processo serão tão bons quanto a quantidade e qualidade dos dados que serão utilizados. Qualidade nesse contexto se refere que os dados sejam representativos do problema a ser estudado, consistentes, e que possuam informação relacionada à tarefa ser realizada [14]. Portanto, o processo para chegar num conjunto de dados de qualidade leva algumas etapas. Inicialmente, a etapa de coleta e/ou curadoria dos dados para geração e seleção de um subconjunto relevante e útil de dados disponíveis para a resolução dos problemas. Posteriormente, o pré-processamento de dados, que busca uma formatação adequada dos dados, limpeza de dados corrompidos e ausentes, transformação dos dados conforme necessário por operações como normalização, discretização, cálculo da média, suavizar ou diferenciar, conversão uniforme para inteiros, double ou strings e amostragem adequada para otimizar a representatividade do conjunto [6]. Tendo os dados brutos tecnicamente corretos, é possível a próxima etapa de escolha da representação adequada ao problema.
          
          
            Representação: também chamada de impressão digital (fingerprint) ou descritor [27], a representação determinará a capacidade e o desempenho do processo de machine learning. Somente se as variáveis necessárias forem representadas que o algoritmo será capaz de aprender a relação desejada. Essa etapa mapeia em um vetor as diferentes variáveis de entrada (features de input) disponíveis que descrevem e identificam as amostras (no presente contexto, os materiais). Alguns requisitos desejáveis universais são propostos [28, 6, 14], tais como: a representação deve ser a) completa (suficiente para diferenciar os exemplos), b) única (dois exemplos terão a mesma representação apenas se forem de fato iguais), c) discriminativos (sistemas similares ou diferentes serão caracterizados por representações similares ou diferentes), e d) eficiente e simples de ser obtido (o cálculo da representação em si deve ser rápido). Esses requisitos apresentados servem para garantir que os modelos sejam eficientes usando apenas informações essenciais. Para qualquer novo problema de machine learning, o processo de engenharia de features, que engloba a seleção, combinação, e transformação destas, é responsável pela maior parte dos esforços e do tempo usado no projeto [29].
          
          
            Algoritmos, validação, e aplicação: A tarefa de construir e utilizar algoritmos é um estudo caso a caso. Nenhum algoritmo de ML é universalmente superior [30, 31]. Em particular, a escolha do algoritmo de aprendizagem é uma etapa fundamental na construção de um pipeline de ML, e muitas opções estão disponíveis, cada uma adequada para um determinado problema e/ou conjunto de dados. Esse conjunto de dados pode ser de dois tipos: rotulado ou não rotulado. Como vimos, no primeiro caso, a tarefa é encontrar o mapeamento entre os pontos dos dados e os rótulos correspondentes {x(i)}→{y(i)} por meio de um algoritmo de aprendizagem supervisionada. Por outro lado, se não há rótulos no conjunto de dados, a tarefa é encontrar uma estrutura dentro dos dados, utilizando o aprendizado não supervisionado. A seguir apresentamos de maneira breve um exemplo simples e os principais algoritmos para cada um dos tipos de problemas de ML que apresentamos na seção 2.3. i. Esses tipos de problemas e os algoritmos relacionados são resumidos na Figura 5. Figura 5Algoritmos de machine learning e diagrama de uso, divididos nos principais tipos de problemas: aprendizado não supervisionado (redução de dimensionalidade e clustering) e supervisionado (classificação e regressão). Adaptado de [6] CC BY 3.0. 
            Redução de dimensionalidade. Devido à grande abundância de dados, pode-se facilmente obter vetores de features de tamanho incrivelmente grandes, levando ao que é conhecido como “maldição da dimensionalidade”. Por exemplo, imagine um algoritmo de ML que recebe como entrada imagens de n×n pixels em escala de cinza, cada um representado como um valor numérico. Nesse caso, a matriz que contém esses números é achatada em um vetor de comprimento n2, o vetor de características, descrevendo esse ponto (amostra) em um espaço de alta dimensionalidade. Devido à dependência exponencial, um número grande de dimensões é facilmente atingido para imagens de tamanho médio. A memória ou o poder de processamento computacional tornam-se fatores limitantes neste caso. Um ponto chave é que dentro da nuvem de dados de alta dimensão abrangida pelo conjunto de dados, pode-se encontrar uma estrutura de dimensão inferior. O conjunto de pontos pode ser projetado em um hiperplano ou variedade, reduzindo sua dimensionalidade enquanto preserva a maior parte das informações contidas na nuvem de dados original. Uma série de procedimentos com esse objetivo, como análise de componentes principais (PCA) são rotineiramente empregados em algoritmos de ML [32]. Em poucas palavras, a PCA é uma rotação de cada eixo do sistema de coordenadas do espaço onde residem os pontos de dados, levando à maximização da variância ao longo desses eixos. A maneira de descobrir para onde o novo eixo deve apontar é obtendo o autovetor correspondente ao maior autovalor de XTX, onde X é a matriz de dados. Uma vez que o maior autovetor de variância, também conhecido como o componente principal, é encontrado, os pontos são projetados nele, resultando em uma compressão dos dados. Usualmente escolhe-se um número de componentes principais que irão descrever a maior parte da variância do conjunto de dados. A generalização dos algoritmos de redução de dimensionalidade para estruturas não-lineares é chamada de manifold learning, dos quais exemplos conhecidos são o multi-dimensional scaling (MDS), isometric mapping (Isomap) e t-distributed stochastic neighbor embedding (t-SNE).
            Clustering. O clustering hierárquico é um método empregado na aprendizagem não supervisionada, podendo ser de dois tipos, aglomerativo ou divisivo. O primeiro pode ser descrito por um algoritmo simples: começando com n classes, ou clusters, cada um deles contendo um único exemplo x(i) do conjunto de treinamento, e então é medida a dissimilaridade d(A,B) entre pares de clusters rotulados A e B. Os dois clusters com a menor dissimilaridade, ou seja, mais semelhantes, são mesclados em um novo cluster. O processo é então repetido recursivamente até que apenas um cluster, contendo todos os elementos do conjunto de treinamento, permaneça. O processo pode ser melhor visualizado traçando um dendrograma, tal como mostrado na Figura 6. Para agrupar os dados em k clusters, 1 &lt; k &lt; n, o usuário deve cortar a estrutura hierárquica obtida em alguma etapa intermediária do agrupamento. Há certa liberdade na escolha da medida de dissimilaridade d(A,B), e três medidas principais são populares. Primeiro, a ligação única leva em consideração o par mais próximo de membros do cluster, Figura 6(a) Dendrograma demonstrando o clustering hierárquico. O código de cores é um guia para visualizar os clusters, representados pelas linhas verticais. As linhas horizontais indicam a fusão de dois clusters. O número de cruzamentos entre a linha horizontal e as linhas dos clusters corresponde ao número de clusters em uma determinada altura selecionada, no exemplo da linha tracejada cinza, são cinco clusters. (b) Exemplo da função sigmóide e a classificação de exemplos negativos em vermelho e positivos em azul na regressão logística. A seta cinza aponta para os dados classificados incorretamente no conjunto de dados. Adaptado de [6] CC BY 3.0. (c) Exemplo de uma rede neural com N camadas ocultas e um único neurônio na camada de output. (1)dS⁢L⁢(A,B)=mini∈A,j∈B⁡di⁢j 
            onde dij é uma medida de dissimilaridade de membros do par. Em segundo lugar, a ligação completa considera o par mais distante ou mais diferente de cada cluster, (2)dC⁢L⁢(A,B)=maxi∈A,j∈B⁡di⁢j 
            e, finalmente, o agrupamento da média do grupo considera a dissimilaridade média, representando um balanço entre as duas medidas anteriores, (3)dG⁢A⁢(A,B)=1|A|⁢|B|⁢∑i∈A∑j∈Bdi⁢j. 
            A forma particular de dij também pode ser escolhida, geralmente sendo considerada a distância euclidiana para dados numéricos. A menos que os dados disponíveis sejam altamente agrupados, a escolha da medida de dissimilaridade pode resultar em dendrogramas distintos e, portanto, clusters distintos. Como o nome sugere, o clustering divisivo executa a operação oposta, começando com um único cluster contendo todos os exemplos do conjunto de dados e o divide recursivamente de forma que a dissimilaridade do cluster seja maximizada. O processo termina quando cada cluster possuir uma entrada. Da mesma forma, requer que o usuário determine a linha de corte para agrupar os dados. Outros algoritmos de clustering bastante utilizados são o K-médias (K-means) e o DBSCAN.
            Supervisionado: Regressão e Classificação. No caso dos algoritmos supervisionados, a ideia geral é aprender a função que aproxime da melhor forma possível a distribuição dos dados disponíveis para treinamento do modelo. No caso da regressão, o modelo retorna um valor contínuo, e no caso da classificação, um valor (rótulo) discreto. Seja qual for o algoritmo, o objetivo é minimizar o erro entre o valor predito pelo modelo aproximado e os valores de referência usados para o treinamento. Isso é feito ao se definir uma função de custo que será minimizada. Portanto, a infinidade de diferentes modelos possíveis pode ser resumida na escolha desses 2 componentes: qual a forma da função usada para a aproximação, e qual a função de custo para a minimização. Diferentes algoritmos empregam diferentes estratégias na solução desse objetivo. Vamos apresentar os exemplos mais simples pra cada uma dessas tarefas, como forma de exemplificar essa ideia geral.
            No caso da regressão, o algoritmo mais simples e usado é conhecido como regressão Linear. Sua suposição básica é que os dados são normalmente distribuídos em relação a uma expressão ajustada, (4)y^(i)=θT⁢x(i) 
            onde o sobrescrito T denota o vetor transposto, y^(i) é o valor previsto e θ é o vetor de parâmetros (coeficientes) a serem aprendidos. A fim de obter os parâmetros θ, insere-se uma função de custo no modelo, que é dada por uma soma dos termos de erro usando mínimos quadrados, (5)J⁢(θ)=∑i=1nL⁢[y^(i)⁢(x(i),θ),y(i)]=12⁢∑i=1n(θT⁢x(i)-y(i))2+λ⁢∥θ∥p. 
            Ao minimizar a função acima com relação a seus parâmetros, encontra-se o melhor conjunto de θ para o problema em questão, levando assim a um modelo de ML treinado. O último termo inserido na função de custo é opcional, conhecido como parâmetro de regularização λ, sendo diferentes extensões da regressão linear, tal como a regressão ridge ou LASSO. O valor de p denota a métrica, p = 0 é simplesmente o número de coeficientes diferentes de zero (normalmente não considerados uma métrica formalmente) em θ enquanto p = 1 é referido como a métrica de Manhattan ou táxi, e p = 2 é a métrica euclidiana usual. Quando se usa p = 1, o modelo de regressão é LASSO (Least Absolute Shrinkage and Selection Operator), onde devido à restrição imposta ao problema de minimização, nem todas as features presentes nos descritores são consideradas para o ajuste. Por outro lado, a regressão ridge corresponde a p = 2, e o resultado neste caso é apenas a redução dos valores absolutos das features, ou seja, features com valores muito grandes são penalizados, somando à função de custo. Tanto no LASSO quanto na regressão ridge, o parâmetro λ controla a complexidade do modelo, diminuindo e/ou selecionando as features. Assim, em ambos os casos, é recomendável começar com um modelo mais complexo e usar λ para diminuir sua complexidade. O parâmetro λ, entretanto, não pode ser aprendido da mesma maneira que θ, sendo referido como um hiperparâmetro que deve ser ajustado por, por exemplo, uma busca em grid para encontrar aquele que maximiza o poder de previsão sem introduzir muito viés (bias).
            A classificação é usada para prever rótulos discretos. Um algoritmo de classificação muito popular é a regressão logística [20], que pode ser interpretado como um mapeamento das previsões feitas por regressão linear no intervalo [0, 1]. Vamos supor que a tarefa de classificação em questão é decidir se um dado ponto x(i) pertence a uma classe particular (y(i) = 1) ou não (y(i) = 0). A previsão binária desejada pode ser obtida a partir de (6)y^=σ⁢(θT⁢x)=11+e-θT⁢x 
            onde θ é novamente um vetor de parâmetros e σ é referido como a função logística ou sigmóide. Como exemplo, a função sigmóide junto com uma previsão de um conjunto de dados fictício é apresentada na Figura 6. Normalmente considera-se que a amostra x(i) pertence à classe rotulada por y(i) se y^(i)≥0.5 , mesmo que o rótulo previsto possa ser interpretado como uma probabilidade y^=P(y=1|x,θ). No caso da classificação, a função de custo é obtida a partir da log-probabilidade negativa. Assim, a obtenção dos melhores parâmetros θ requer a minimização dessa quantidade, dada por (7)J(θ)=-1n∑i=1n[y(i)log(y^(i))+(1-y(i))log(1-y^(i))] 
            onde y(i) e y^(i)=σ⁢(θT⁢x(i)) são os rótulos binários verdadeiros (de referência) e previstos. Um parâmetro de regularização λ pode ser inserido na equação (7) com a mesma intenção de selecionar as features, como visto na regressão linear anteriormente. Observe que a regressão logística também pode ser usada quando os dados apresentam várias classes. Neste caso, deve-se empregar a estratégia um-contra-todos, que consiste em treinar n modelos de regressão logística, um para cada classe, e prever os rótulos usando o classificador que apresentar maior probabilidade.
            Entre os métodos supervisionados, algoritmos populares de classificação são classificadores usando máquinas de vetores de suporte (support vector machines, SVM) [33] com uma variedade de funções kernel (linear, polinomial, Gaussiana, entre outras); o algoritmo não paramétrico k-nearest neighbors (k-NN); algoritmos probabilísticos como Naive Bayes; árvores de decisão [34, 35] e métodos relacionados de ensemble, como Random Forests [20] e gradient boosting. No caso de tarefas de regressão, regressão linear, Ridge e LASSO, bem como árvores de decisão e regressores de Random Forests são algoritmos simples e populares. Uma revisão recente sobre métodos de ML para ciência de materiais apresenta uma explicação abrangente do funcionamento interno de muitos desses algoritmos [6], e um vasto material também pode ser encontrado na literatura [18, 20, 21].
            Vale destacar separadamente, as redes neurais (neural networks, NN), particularmente profundas (deep learning) [21], que estão se tornando muito populares devido aos seus avanços recentes tal como para reconhecimento de imagens, bem como em tarefas de processamento de linguagem natural. Elas correspondem a uma classe de algoritmos que foram, pelo menos em seu início, inspiradas pela estrutura do cérebro. Uma NN pode ser descrita como um grafo direcionado ponderado, ou seja, uma estrutura composta por camadas contendo unidades de processamento chamadas neurônios, que por sua vez são conectadas a outras camadas, conforme ilustrado na Figura 6. Muitos tipos de NNs são usados para uma variedade de tarefas como regressão e classificação, e algumas das arquiteturas mais populares para tais redes são NNs feed-forward, recorrentes e convolucionais. As principais diferenças entre essas arquiteturas são basicamente os padrões de conexão e as operações que seus neurônios executam nos dados. Normalmente em uma NN, uma camada de entrada recebe os vetores de features do conjunto de treinamento, e uma série de operações não lineares é realizada enquanto os dados propagam através das subsequentes chamadas camadas ocultas. Finalmente, o resultado do processamento é coletado na camada de saída, que pode ser uma classificação binária ou multinária (probabilística), ou mesmo um mapeamento contínuo como em um modelo de regressão linear. Um ponto muito interessante nesse processo, é que a própria rede aprende representações otimizadas do conjunto de dados, normalmente ao custo de cojuntos de dados maiores, visto o número exponencialmente grande de coeficientes a serem determinados. Em uma NN, a entrada zi(k) do i-ésimo neurônio na k-ésima camada é uma função das saídas yj(k-1) da camada anterior
            
              
                (8)
                
                  
                    
                      z
                      i
                      
                        (
                        k
                        )
                      
                    
                    =
                    
                      
                        ω
                        
                          i
                          ⁢
                          0
                        
                        
                          (
                          k
                          )
                        
                      
                      +
                      
                        
                          ∑
                          j
                        
                        
                          
                            y
                            j
                            
                              (
                              
                                k
                                -
                                1
                              
                              )
                            
                          
                          ⁢
                          
                            ω
                            
                              i
                              ⁢
                              j
                            
                            
                              (
                              k
                              )
                            
                          
                        
                      
                    
                  
                
              
            
            onde ωi⁢j(k) é o elemento da matriz que conecta as camadas adjacentes. O elemento wi⁢0(k) é conhecido como viés (bias), porque não faz parte da combinação linear de entradas. A entrada é então transformada por meio de uma função não-linear ou de ativação, tal como a tangente hiperbólica,
            
              
                (9)
                
                  
                    
                      
                        y
                        i
                        
                          (
                          k
                          )
                        
                      
                      =
                      
                        
                          
                            e
                            
                              z
                              i
                              
                                (
                                k
                                )
                              
                            
                          
                          -
                          
                            e
                            
                              -
                              
                                z
                                i
                                
                                  (
                                  k
                                  )
                                
                              
                            
                          
                        
                        
                          
                            e
                            
                              z
                              i
                              
                                (
                                k
                                )
                              
                            
                          
                          +
                          
                            e
                            
                              -
                              
                                z
                                i
                                
                                  (
                                  k
                                  )
                                
                              
                            
                          
                        
                      
                    
                    ,
                  
                
              
            
            que resulta no mapeamento do vetor de entrada da camada anterior em um novo espaço vetorial, permitindo que a rede forneça predições para problemas altamente complexos.
            Por fim, vamos discutir como avaliar a qualidade dos modelos, métricas de desempenho e precauções a serem tomadas para gerar modelos coerentes. Um algoritmo de aprendizado supervisionado de ML é considerado treinado quando seus parâmetros ótimos dados as amostras de treinamento são encontrados, minimizando a função de custo. No entanto, os hiperparâmetros geralmente não podem ser aprendidos dessa maneira, e o estudo do desempenho do modelo em um conjunto separado, denominado conjunto de validação, em função de tais parâmetros é necessário. Este processo é conhecido como validação. A maneira usual de fazer isso é separar o conjunto de dados em 3 conjuntos separados: os conjuntos de treinamento, validação e teste. Espera-se que seus elementos sejam da mesma natureza, ou seja, venham da mesma distribuição estatística. O processo de aprendizagem é então realizado várias vezes para otimizar o modelo. Finalmente, usando o conjunto de teste, pode-se confrontar as previsões com os rótulos de referência e medir o quão bem o modelo está desempenhando. Particularmente em métodos supervisionados, dois problemas principais podem surgir então: (i) se os vetores de descritores apresentam um número insuficiente de features, ou seja, não é geral o suficiente para capturar as tendências nos dados e o modelo de regressão é considerado enviesado, e (ii) se o descritor apresenta muitas informações, o que faz com que o modelo de regressão se ajuste aos dados de treinamento excessivamente bem, mas sofre para generalizar para novos dados, então é dito que o modelo sofre sobre-ajuste (overfitting) ou variância. Esses são dois extremos da complexidade dos modelos, diretamente relacionado ao número de parâmetros, onde o equilíbrio ideal é representado na Figura 7. Normalmente se utiliza o parâmetro de regularização λ a fim de diminuir de forma sistemática a complexidade do modelo e encontrar o ponto ótimo. Figura 7Balanço entre viés (bias) × variância. A complexidade ideal do modelo é avaliada em relação ao erro das predições avaliadas no conjunto de teste. Adaptado de [6] CC BY 3.0. 
            Quando uma quantidade limitada de dados está disponível para treinamento, remover uma fração desse conjunto para criar o conjunto de teste pode impactar negativamente o processo de treinamento, e formas alternativas devem ser empregadas. Um dos métodos mais populares neste cenário é a validação cruzada, que consiste em particionar o conjunto de treinamento em k subconjuntos, treinar o modelo usando k-1 subconjuntos e validar o modelo treinado usando o conjunto que não foi usado para o treinamento. Este processo é executado k vezes e a média de cada etapa de validação é usada para calcular a média do desempenho,
            
              
                (10)
                
                  
                    
                      E
                      
                        c
                        ⁢
                        v
                      
                      K
                    
                    =
                    
                      
                        1
                        K
                      
                      ⁢
                      
                        
                          ∑
                          
                            k
                            =
                            1
                          
                          K
                        
                        
                          
                            ∑
                            
                              i
                              =
                              1
                            
                            
                              n
                              k
                            
                          
                          
                            L
                            ⁢
                            
                              (
                              
                                
                                  y
                                  ^
                                
                                k
                                
                                  (
                                  i
                                  )
                                
                              
                              ,
                              
                                y
                                
                                  (
                                  i
                                  )
                                
                              
                              )
                            
                          
                        
                      
                    
                  
                
              
            
            onde L é a função de perda e y^k(i) é o rótulo previsto do i-ésimo exemplo de treinamento do modelo treinado usando o subconjunto dos dados de treinamento, excluindo o subconjunto k, que tem o tamanho n_k.
            Existem muitas maneiras de avaliar o desempenho, sendo de suma importância particularmente para modelos supervisionados. Em tarefas de classificação binária ou multinária, é muito comum o uso de matrizes de confusão, onde o número de elementos preditos corretamente são apresentados nas entradas diagonais enquanto os elementos que foram preditos incorretamente são contados nas entradas fora da diagonal. Pode-se pensar no índice vertical como os rótulos reais e no índice horizontal como as previsões, e falsos (F) positivos (P) ou negativos (N) são previsões positivas para casos negativos e vice-versa, respectivamente. A curva de característica de operação do receptor (ROC curve) também é usada rotineiramente, sendo o gráfico da taxa de verdadeiros (V) positivos T⁢V⁢P=V⁢PV⁢P+F⁢N versus a taxa de falsos positivos T⁢F⁢P=F⁢PF⁢P+V⁢N variando o limiar inter-classes. Um exemplo é mostrado na Fig. 11a. Figura 11Resultados do modelo de ML e aplicação [24]. (a) Curva ROC e área sob a curva como métrica do modelo de classificação para cada classe: baixa (vermelho), média (laranja) e alta estabilidade (verde). (b) Importância das 20 features mais importantes do modelo de classificação. (c) Gráfico de paridade das energias de formação para a classe de alta estabilidade comparando os valores calculados por DFT com o modelo de regressão obtido via ML. O erro RMSE da validação cruzada é 0.205 eV/átomo. (d) Uso do modelo ML como critério de seleção de materiais para fotoeletrocatálise de água. Alinhamento de banda dos candidatos selecionados em relação ao vácuo. Os potenciais para as reações H+/H2 e O2/H2O estão destacados entre as linhas tracejadas. O candidato Sn2SeTe foi previsto pelo modelo de classificação. Adaptado com permissão de [24]. Copyright 2019 American Chemical Society. 
            No caso de tarefas de regressão, existem várias métricas da performance do ajuste. O erro médio absoluto M⁢A⁢E=1n⁢∑in|yi-y^i|, mede desvios na mesma unidade da variável e também não é sensível a outliers. Existe a versão normalizada expressa em porcentagem M⁢A⁢P⁢E=100%n⁢∑inyi-y^iyi. O erro quadrático médio M⁢S⁢E=1n⁢∑in(yi-y^i)2 combina medições de bias e variância da previsão. Do ponto de vista frequentista, a estimativa θ^m de um parâmetro de distribuição θ está intimamente relacionada com o MSE, através da fórmula M⁢S⁢E=𝔼⁢[(θ^m-θ)2]=B⁢i⁢a⁢s⁢(θ^m)2+V⁢a⁢r⁢(θ^m). O MSE, ou seja, a função de custo dada na equação (5) (quando se introduz ou não um parâmetro de regularização λ), idealmente seria zero para pontos de dados exatamente em cima da função obtida por meio da regressão. O MSE costuma ser utilizado tomando sua raiz (RMSE), que recupera a unidade original, facilitando a interpretação da precisão do modelo. Finalmente, também é utilizado o coeficiente de determinação estatístico R2, definido como R2=1-S⁢Sr⁢e⁢sS⁢St⁢o⁢t, onde a soma total dos quadrados é S⁢St⁢o⁢t=∑i(yi-y¯)2 e a soma residual dos quadrados é S⁢Sr⁢e⁢s=∑i(yi-y^i)2. O R2 é usualmente visualizado em gráficos de paridade, onde compara-se os valores preditos pelo modelo de ML com os valores de referência. Um exemplo é mostrado na Fig. 11c.
          
        
        Na prática, existem diversos softwares e programas computacionais que implementam os diferentes algoritmos de machine learning. Um dos mais acessíveis, completos e utilizados é o scikit-learn [36], implementado como uma biblioteca escrita em python. Uma implementação também acessível e com interface gráfica é o software Weka [37]. Duas das implementações mais utilizadas de deep learning são os códigos tensorflow [38] e pytorch [39]. Um tutorial prático introdutório de uso do machine learning com aplicações para materiais pode ser encontrado em [40].
        Finalmente, vale destacar que existe um balanço entre os diferentes componentes para cada determinado problema de ML. O tamanho do conjunto de dados, a representação usada e o algoritmo a ser empregado estão intimamente relacionados à construção de cada modelo e devem ser balanceados com cuidado, conforme discutido na Fig. 8. Em relação aos dados, na física, química e ciência de materiais, a natureza dos conjuntos de dados envolvidos é muito diferente daqueles com os quais o aprendizado de máquina foi historicamente projetado para trabalhar, que são, tamanhos grandes, espaços com poucas features de dimensionalidade fixa e baixa variância; sendo então caracterizado como “little-data” [46]. Para uma complexidade de descritor fixa, o número de pontos de dados necessários para o treinamento do modelo é uma quantidade chave. Poucos exemplos podem levar ao sobreajuste, isto é, o modelo se ajusta excessivamente bem aos dados, incluindo ruídos indesejáveis. Aumentando o número de pontos de treinamento, tal problema é minimizado ao custo de diminuir ligeiramente a precisão do conjunto de treinamento (curva azul Fig. 8a). Por outro lado, isso leva a uma melhor generalização do modelo, o que pode ser representado pelo aumento da precisão dos dados que não estavam presentes na etapa de treinamento (dados de validação, curva vermelha crescente na Fig. 8a). Para cada modelo, o tamanho do conjunto de dados necessário para convergência será diferente, e não pode ser determinadoa priori , mas avaliado por meio de curvas de aprendizado (Fig. 8a). Podemos pensar em uma escada de crescente complexidade na representação de materiais e moléculas (Fig. 8b), cada degrau fornecendo informações adicionais sobre os sistemas. No nível mais baixo, a informação depende apenas da fórmula química, ou seja, da composição elementar e estequiometria (escalares). No segundo nível, informações estruturais podem ser incluídas, como posições atômicas, conectividade e propriedades da rede. Nos níveis superiores, informações mais complexas, como estrutura eletrônica ou densidade local, podem ser introduzidas (vetores, tensores e outros). Para cada aplicação, é necessário incluir diferentes informações no descritor, de acordo com a natureza do problema. Portanto, para alguns problemas, features simples podem atingir a acurácia adequada, enquanto em outros problemas a acurácia é limitada. A tarefa da representação é otimizar o descritor, maximizando sua precisão ao mesmo tempo que mantém a maior simplicidade possível. Sempre que o grau de complexidade é aumentado, seja pela expansão do espaço de features ou pelo número de parâmetros a serem aprendidos no modelo de ML (Fig. 8c), a quantidade de dados de treinamento disponíveis deve aumentar de acordo. Finalmente, para qualquer algoritmo de ML, seu sucesso preditivo é determinado por um equilíbrio entre o conjunto de features disponíveis, a qualidade dos descritores, a otimização do algoritmo e, mais importante, a precisão dos dados usados para o treinamento [14]. Um primeiro passo para avaliação do sucesso do modelo de ML é verificar se o conjunto de features incluídas com o algoritmo utilizado é adequado para a descrição da propriedade-alvo de interesse. Isso pode ser verificado em relação às características estatísticas do próprio conjunto de dados, como o valor médio e desvio padrão da propriedade avaliada. Por exemplo, num problema de regressão, é possível comparar o erro médio obtido com um simples modelo de regressão linear usando as features iniciais com relação ao desvio padrão da propriedade. Se o resultado não for significativamente superior, pode ser um indicativo que um modelo linear não descreve bem a propriedade e/ou que as features incluídas não são suficientes para descrever o problema.
        
          Figura 8
          
            Detalhes dos componentes de Machine Learning: dados a., Descritores b. e algoritmos c.. a. Curva de aprendizado para um determinado modelo de ML, onde a precisão aumenta com o número de dados de treinamento até atingir o platô da capacidade (linha horizontal pontilhada). Por outro lado, a precisão do treinamento diminui como resultado da redução do overfitting inicial. b. Representações de ML para moléculas e de materiais. Em cada degrau, mais informações são adicionadas ao descritor, tornando o treinamento e a previsão mais custosos. O desafio é maximizar a acurácia ao mesmo tempo usando o descritor mais simples possível. c. Balanço entre de precisão e interpretabilidade dos algoritmos de aprendizado de máquina. Algoritmos complexos como Redes Neurais tendem a ser considerados caixas pretas no sentido que entender a importância de cada feature não é uma tarefa simples. A quantidade de dados de treinamento disponíveis deve ser compatível a complexidade do modelo. Adaptado com permissão de [14]. Copyright 2019 American Chemical Society.
         </span>
        </span>
       </span>
       .
       <i>
        i
       </i>
       . Esses tipos de problemas e os algoritmos relacionados são resumidos na Figura
       <a class="open-asset-modal" data-target="#ModalFigS2_F5" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        5
       </a>
       .
      </p>
      <div class="row fig" id="S2_F5">
       <a name="S2_F5">
       </a>
       <div class="col-md-4 col-sm-4">
        <a data-target="#ModalFigS2_F5" data-toggle="modal" href="">
         <div class="thumbImg">
          <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/1803eccfdd00da956943c4b8ae8794648003d643.jpg"/>
          <div class="zoom">
           <span class="sci-ico-zoom">
           </span>
          </div>
         </div>
        </a>
       </div>
       <div class="col-md-8 col-sm-8">
        <strong>
         Figura 5
        </strong>
        <br/>
        Algoritmos de machine learning e diagrama de uso, divididos nos principais tipos de problemas: aprendizado não supervisionado (redução de dimensionalidade e clustering) e supervisionado (classificação e regressão). Adaptado de [
        <span class="ref">
         <sup class="xref xrefblue">
          6
         </sup>
         <span class="refCtt closed">
          <span>
           6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
          </span>
         </span>
        </span>
        ]
        <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">
         CC BY 3.0
        </a>
        .
        <br/>
       </div>
      </div>
      <p>
       <i>
        Redução de dimensionalidade
       </i>
       . Devido à grande abundância de dados, pode-se facilmente obter vetores de features de tamanho incrivelmente grandes, levando ao que é conhecido como “maldição da dimensionalidade”. Por exemplo, imagine um algoritmo de ML que recebe como entrada imagens de
       <i>
        n
       </i>
       ×
       <i>
        n
       </i>
       pixels em escala de cinza, cada um representado como um valor numérico. Nesse caso, a matriz que contém esses números é achatada em um vetor de comprimento
       <i>
        n
       </i>
       <sup>
        2
       </sup>
       , o vetor de características, descrevendo esse ponto (amostra) em um espaço de alta dimensionalidade. Devido à dependência exponencial, um número grande de dimensões é facilmente atingido para imagens de tamanho médio. A memória ou o poder de processamento computacional tornam-se fatores limitantes neste caso. Um ponto chave é que dentro da nuvem de dados de alta dimensão abrangida pelo conjunto de dados, pode-se encontrar uma estrutura de dimensão inferior. O conjunto de pontos pode ser projetado em um hiperplano ou variedade, reduzindo sua dimensionalidade enquanto preserva a maior parte das informações contidas na nuvem de dados original. Uma série de procedimentos com esse objetivo, como
       <b>
        análise de componentes principais
       </b>
       (PCA) são rotineiramente empregados em algoritmos de ML [
       <span class="ref">
        <sup class="xref xrefblue">
         32
        </sup>
        <span class="refCtt closed">
         <span>
          32. M. van Heel, R.V. Portugal e M. Schatz, Open J. Stat. 6, 701 (2016).
         </span>
        </span>
       </span>
       ]. Em poucas palavras, a PCA é uma rotação de cada eixo do sistema de coordenadas do espaço onde residem os pontos de dados, levando à maximização da variância ao longo desses eixos. A maneira de descobrir para onde o novo eixo deve apontar é obtendo o autovetor correspondente ao maior autovalor de
       <b>
        X
       </b>
       <sup>
        <i>
         T
        </i>
       </sup>
       <b>
        X
       </b>
       , onde
       <b>
        X
       </b>
       é a matriz de dados. Uma vez que o maior autovetor de variância, também conhecido como o componente principal, é encontrado, os pontos são projetados nele, resultando em uma compressão dos dados. Usualmente escolhe-se um número de componentes principais que irão descrever a maior parte da variância do conjunto de dados. A generalização dos algoritmos de redução de dimensionalidade para estruturas não-lineares é chamada de
       <i>
        manifold learning
       </i>
       , dos quais exemplos conhecidos são o
       <i>
        multi-dimensional scaling
       </i>
       (
       <b>
        MDS
       </b>
       ),
       <i>
        isometric mapping
       </i>
       (
       <b>
        Isomap
       </b>
       ) e
       <i>
        t-distributed stochastic neighbor embedding
       </i>
       (
       <b>
        t-SNE
       </b>
       ).
      </p>
      <p>
       <i>
        Clustering
       </i>
       . O
       <b>
        clustering hierárquico
       </b>
       é um método empregado na aprendizagem não supervisionada, podendo ser de dois tipos, aglomerativo ou divisivo. O primeiro pode ser descrito por um algoritmo simples: começando com
       <i>
        n
       </i>
       classes, ou clusters, cada um deles contendo um único exemplo
       <b>
        x
       </b>
       <sup>
        (
        <i>
         i
        </i>
        )
       </sup>
       do conjunto de treinamento, e então é medida a dissimilaridade
       <i>
        d
       </i>
       (
       <i>
        A
       </i>
       ,
       <i>
        B
       </i>
       ) entre pares de clusters rotulados
       <i>
        A
       </i>
       e
       <i>
        B
       </i>
       . Os dois clusters com a menor dissimilaridade, ou seja, mais semelhantes, são mesclados em um novo cluster. O processo é então repetido recursivamente até que apenas um cluster, contendo todos os elementos do conjunto de treinamento, permaneça. O processo pode ser melhor visualizado traçando um dendrograma, tal como mostrado na Figura
       <a class="open-asset-modal" data-target="#ModalFigS2_F6" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        6
       </a>
       . Para agrupar os dados em
       <i>
        k
       </i>
       clusters, 1 &lt;
       <i>
        k
       </i>
       &lt;
       <i>
        n
       </i>
       , o usuário deve cortar a estrutura hierárquica obtida em alguma etapa intermediária do agrupamento. Há certa liberdade na escolha da medida de dissimilaridade
       <i>
        d
       </i>
       (
       <i>
        A
       </i>
       ,
       <i>
        B
       </i>
       ), e três medidas principais são populares. Primeiro, a ligação única leva em consideração o par mais próximo de membros do cluster,
      </p>
      <div class="row fig" id="S2_F6">
       <a name="S2_F6">
       </a>
       <div class="col-md-4 col-sm-4">
        <a data-target="#ModalFigS2_F6" data-toggle="modal" href="">
         <div class="thumbImg">
          <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/4e176f8dcc2126fcd2d9d6b5556ec329417bebe6.jpg"/>
          <div class="zoom">
           <span class="sci-ico-zoom">
           </span>
          </div>
         </div>
        </a>
       </div>
       <div class="col-md-8 col-sm-8">
        <strong>
         Figura 6
        </strong>
        <br/>
        (a) Dendrograma demonstrando o clustering hierárquico. O código de cores é um guia para visualizar os clusters, representados pelas linhas verticais. As linhas horizontais indicam a fusão de dois clusters. O número de cruzamentos entre a linha horizontal e as linhas dos clusters corresponde ao número de clusters em uma determinada altura selecionada, no exemplo da linha tracejada cinza, são cinco clusters. (b) Exemplo da função sigmóide e a classificação de exemplos negativos em vermelho e positivos em azul na regressão logística. A seta cinza aponta para os dados classificados incorretamente no conjunto de dados. Adaptado de [
        <span class="ref">
         <sup class="xref xrefblue">
          6
         </sup>
         <span class="refCtt closed">
          <span>
           6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
          </span>
         </span>
        </span>
        ]
        <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">
         CC BY 3.0
        </a>
        . (c) Exemplo de uma rede neural com
        <i>
         N
        </i>
        camadas ocultas e um único neurônio na camada de output.
        <br/>
       </div>
      </div>
      <div class="row formula" id="eS2_E1">
       <a name="S2_E1">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (1)
         </span>
         <math alttext="d_{SL}(A,B)=\min_{i\in A,j\in B}d_{ij}" display="block">
          <mrow>
           <mrow>
            <msub>
             <mi>
              d
             </mi>
             <mrow>
              <mi>
               S
              </mi>
              <mo>
               ⁢
              </mo>
              <mi>
               L
              </mi>
             </mrow>
            </msub>
            <mo>
             ⁢
            </mo>
            <mrow>
             <mo stretchy="false">
              (
             </mo>
             <mi>
              A
             </mi>
             <mo>
              ,
             </mo>
             <mi>
              B
             </mi>
             <mo stretchy="false">
              )
             </mo>
            </mrow>
           </mrow>
           <mo>
            =
           </mo>
           <mrow>
            <munder>
             <mi>
              min
             </mi>
             <mrow>
              <mrow>
               <mi>
                i
               </mi>
               <mo>
                ∈
               </mo>
               <mi>
                A
               </mi>
              </mrow>
              <mo>
               ,
              </mo>
              <mrow>
               <mi>
                j
               </mi>
               <mo>
                ∈
               </mo>
               <mi>
                B
               </mi>
              </mrow>
             </mrow>
            </munder>
            <mo>
             ⁡
            </mo>
            <msub>
             <mi>
              d
             </mi>
             <mrow>
              <mi>
               i
              </mi>
              <mo>
               ⁢
              </mo>
              <mi>
               j
              </mi>
             </mrow>
            </msub>
           </mrow>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <p>
       onde
       <i>
        d
       </i>
       <sub>
        <i>
         ij
        </i>
       </sub>
       é uma medida de dissimilaridade de membros do par. Em segundo lugar, a ligação completa considera o par mais distante ou mais diferente de cada cluster,
      </p>
      <div class="row formula" id="eS2_E2">
       <a name="S2_E2">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (2)
         </span>
         <math alttext="d_{CL}(A,B)=\max_{i\in A,j\in B}d_{ij}" display="block">
          <mrow>
           <mrow>
            <msub>
             <mi>
              d
             </mi>
             <mrow>
              <mi>
               C
              </mi>
              <mo>
               ⁢
              </mo>
              <mi>
               L
              </mi>
             </mrow>
            </msub>
            <mo>
             ⁢
            </mo>
            <mrow>
             <mo stretchy="false">
              (
             </mo>
             <mi>
              A
             </mi>
             <mo>
              ,
             </mo>
             <mi>
              B
             </mi>
             <mo stretchy="false">
              )
             </mo>
            </mrow>
           </mrow>
           <mo>
            =
           </mo>
           <mrow>
            <munder>
             <mi>
              max
             </mi>
             <mrow>
              <mrow>
               <mi>
                i
               </mi>
               <mo>
                ∈
               </mo>
               <mi>
                A
               </mi>
              </mrow>
              <mo>
               ,
              </mo>
              <mrow>
               <mi>
                j
               </mi>
               <mo>
                ∈
               </mo>
               <mi>
                B
               </mi>
              </mrow>
             </mrow>
            </munder>
            <mo>
             ⁡
            </mo>
            <msub>
             <mi>
              d
             </mi>
             <mrow>
              <mi>
               i
              </mi>
              <mo>
               ⁢
              </mo>
              <mi>
               j
              </mi>
             </mrow>
            </msub>
           </mrow>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <p>
       e, finalmente, o agrupamento da média do grupo considera a dissimilaridade média, representando um balanço entre as duas medidas anteriores,
      </p>
      <div class="row formula" id="eS2_E3">
       <a name="S2_E3">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (3)
         </span>
         <math alttext="d_{GA}(A,B)=\frac{1}{|A||B|}\sum_{i\in A}\sum_{j\in B}d_{ij}." display="block">
          <mrow>
           <mrow>
            <mrow>
             <msub>
              <mi>
               d
              </mi>
              <mrow>
               <mi>
                G
               </mi>
               <mo>
                ⁢
               </mo>
               <mi>
                A
               </mi>
              </mrow>
             </msub>
             <mo>
              ⁢
             </mo>
             <mrow>
              <mo stretchy="false">
               (
              </mo>
              <mi>
               A
              </mi>
              <mo>
               ,
              </mo>
              <mi>
               B
              </mi>
              <mo stretchy="false">
               )
              </mo>
             </mrow>
            </mrow>
            <mo>
             =
            </mo>
            <mrow>
             <mfrac>
              <mn>
               1
              </mn>
              <mrow>
               <mrow>
                <mo stretchy="false">
                 |
                </mo>
                <mi>
                 A
                </mi>
                <mo stretchy="false">
                 |
                </mo>
               </mrow>
               <mo>
                ⁢
               </mo>
               <mrow>
                <mo stretchy="false">
                 |
                </mo>
                <mi>
                 B
                </mi>
                <mo stretchy="false">
                 |
                </mo>
               </mrow>
              </mrow>
             </mfrac>
             <mo>
              ⁢
             </mo>
             <mrow>
              <munder>
               <mo largeop="true" movablelimits="false" symmetric="true">
                ∑
               </mo>
               <mrow>
                <mi>
                 i
                </mi>
                <mo>
                 ∈
                </mo>
                <mi>
                 A
                </mi>
               </mrow>
              </munder>
              <mrow>
               <munder>
                <mo largeop="true" movablelimits="false" symmetric="true">
                 ∑
                </mo>
                <mrow>
                 <mi>
                  j
                 </mi>
                 <mo>
                  ∈
                 </mo>
                 <mi>
                  B
                 </mi>
                </mrow>
               </munder>
               <msub>
                <mi>
                 d
                </mi>
                <mrow>
                 <mi>
                  i
                 </mi>
                 <mo>
                  ⁢
                 </mo>
                 <mi>
                  j
                 </mi>
                </mrow>
               </msub>
              </mrow>
             </mrow>
            </mrow>
           </mrow>
           <mo>
            .
           </mo>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <p>
       A forma particular de
       <i>
        d
       </i>
       <sub>
        <i>
         ij
        </i>
       </sub>
       também pode ser escolhida, geralmente sendo considerada a distância euclidiana para dados numéricos. A menos que os dados disponíveis sejam altamente agrupados, a escolha da medida de dissimilaridade pode resultar em dendrogramas distintos e, portanto, clusters distintos. Como o nome sugere, o clustering divisivo executa a operação oposta, começando com um único cluster contendo todos os exemplos do conjunto de dados e o divide recursivamente de forma que a dissimilaridade do cluster seja maximizada. O processo termina quando cada cluster possuir uma entrada. Da mesma forma, requer que o usuário determine a linha de corte para agrupar os dados. Outros algoritmos de clustering bastante utilizados são o K-médias (
       <i>
        <b>
         K-means
        </b>
       </i>
       ) e o
       <i>
        <b>
         DBSCAN
        </b>
       </i>
       .
      </p>
      <p>
       <i>
        Supervisionado: Regressão e Classificação
       </i>
       . No caso dos algoritmos supervisionados, a ideia geral é aprender a função que aproxime da melhor forma possível a distribuição dos dados disponíveis para treinamento do modelo. No caso da regressão, o modelo retorna um valor contínuo, e no caso da classificação, um valor (rótulo) discreto. Seja qual for o algoritmo, o objetivo é minimizar o erro entre o valor predito pelo modelo aproximado e os valores de referência usados para o treinamento. Isso é feito ao se definir uma função de custo que será minimizada. Portanto, a infinidade de diferentes modelos possíveis pode ser resumida na escolha desses 2 componentes: qual a forma da função usada para a aproximação, e qual a função de custo para a minimização. Diferentes algoritmos empregam diferentes estratégias na solução desse objetivo. Vamos apresentar os exemplos mais simples pra cada uma dessas tarefas, como forma de exemplificar essa ideia geral.
      </p>
      <p>
       No caso da regressão, o algoritmo mais simples e usado é conhecido como
       <b>
        regressão Linear
       </b>
       . Sua suposição básica é que os dados são normalmente distribuídos em relação a uma expressão ajustada,
      </p>
      <div class="row formula" id="eS2_E4">
       <a name="S2_E4">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (4)
         </span>
         <math alttext="\hat{y}^{(i)}=\mathbf{\theta}^{T}\mathbf{x}^{(i)}" display="block">
          <mrow>
           <msup>
            <mover accent="true">
             <mi>
              y
             </mi>
             <mo stretchy="false">
              ^
             </mo>
            </mover>
            <mrow>
             <mo stretchy="false">
              (
             </mo>
             <mi>
              i
             </mi>
             <mo stretchy="false">
              )
             </mo>
            </mrow>
           </msup>
           <mo>
            =
           </mo>
           <mrow>
            <msup>
             <mi>
              θ
             </mi>
             <mi>
              T
             </mi>
            </msup>
            <mo>
             ⁢
            </mo>
            <msup>
             <mtext mathvariant="bold">
              x
             </mtext>
             <mrow>
              <mo stretchy="false">
               (
              </mo>
              <mi>
               i
              </mi>
              <mo stretchy="false">
               )
              </mo>
             </mrow>
            </msup>
           </mrow>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <p>
       onde o sobrescrito
       <i>
        T
       </i>
       denota o vetor transposto,
       <math id="INEQ23">
        <msup>
         <mover accent="true">
          <mi>
           y
          </mi>
          <mo stretchy="false">
           ^
          </mo>
         </mover>
         <mrow>
          <mo stretchy="false">
           (
          </mo>
          <mi>
           i
          </mi>
          <mo stretchy="false">
           )
          </mo>
         </mrow>
        </msup>
       </math>
       é o valor previsto e θ é o vetor de parâmetros (coeficientes) a serem aprendidos. A fim de obter os parâmetros θ, insere-se uma função de custo no modelo, que é dada por uma soma dos termos de erro usando mínimos quadrados,
      </p>
      <div class="row formula" id="eS2_E5">
       <a name="S2_E5">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (5)
         </span>
         <math alttext="\displaystyle J(\mathbf{\theta})=\sum_{i=1}^{n}L[\hat{y}^{(i)}(\mathbf{x}^{(i)% },\theta),y^{(i)}]" display="block">
          <mrow>
           <mrow>
            <mi>
             J
            </mi>
            <mo>
             ⁢
            </mo>
            <mrow>
             <mo stretchy="false">
              (
             </mo>
             <mi>
              θ
             </mi>
             <mo stretchy="false">
              )
             </mo>
            </mrow>
           </mrow>
           <mo>
            =
           </mo>
           <mrow>
            <munderover>
             <mo largeop="true" movablelimits="false" symmetric="true">
              ∑
             </mo>
             <mrow>
              <mi>
               i
              </mi>
              <mo>
               =
              </mo>
              <mn>
               1
              </mn>
             </mrow>
             <mi>
              n
             </mi>
            </munderover>
            <mrow>
             <mi>
              L
             </mi>
             <mo>
              ⁢
             </mo>
             <mrow>
              <mo stretchy="false">
               [
              </mo>
              <mrow>
               <msup>
                <mover accent="true">
                 <mi>
                  y
                 </mi>
                 <mo stretchy="false">
                  ^
                 </mo>
                </mover>
                <mrow>
                 <mo stretchy="false">
                  (
                 </mo>
                 <mi>
                  i
                 </mi>
                 <mo stretchy="false">
                  )
                 </mo>
                </mrow>
               </msup>
               <mo>
                ⁢
               </mo>
               <mrow>
                <mo stretchy="false">
                 (
                </mo>
                <msup>
                 <mtext mathvariant="bold">
                  x
                 </mtext>
                 <mrow>
                  <mo stretchy="false">
                   (
                  </mo>
                  <mi>
                   i
                  </mi>
                  <mo stretchy="false">
                   )
                  </mo>
                 </mrow>
                </msup>
                <mo>
                 ,
                </mo>
                <mi>
                 θ
                </mi>
                <mo stretchy="false">
                 )
                </mo>
               </mrow>
              </mrow>
              <mo>
               ,
              </mo>
              <msup>
               <mi>
                y
               </mi>
               <mrow>
                <mo stretchy="false">
                 (
                </mo>
                <mi>
                 i
                </mi>
                <mo stretchy="false">
                 )
                </mo>
               </mrow>
              </msup>
              <mo stretchy="false">
               ]
              </mo>
             </mrow>
            </mrow>
           </mrow>
          </mrow>
         </math>
         <math alttext="\displaystyle=\frac{1}{2}\sum_{i=1}^{n}(\theta^{T}\mathbf{x}^{(i)}-y^{(i)})^{2% }+\lambda\|\mathbf{\theta}\|_{p}." display="block">
          <mrow>
           <mrow>
            <mi>
            </mi>
            <mo>
             =
            </mo>
            <mrow>
             <mrow>
              <mfrac>
               <mn>
                1
               </mn>
               <mn>
                2
               </mn>
              </mfrac>
              <mo>
               ⁢
              </mo>
              <mrow>
               <munderover>
                <mo largeop="true" movablelimits="false" symmetric="true">
                 ∑
                </mo>
                <mrow>
                 <mi>
                  i
                 </mi>
                 <mo>
                  =
                 </mo>
                 <mn>
                  1
                 </mn>
                </mrow>
                <mi>
                 n
                </mi>
               </munderover>
               <msup>
                <mrow>
                 <mo stretchy="false">
                  (
                 </mo>
                 <mrow>
                  <mrow>
                   <msup>
                    <mi>
                     θ
                    </mi>
                    <mi>
                     T
                    </mi>
                   </msup>
                   <mo>
                    ⁢
                   </mo>
                   <msup>
                    <mtext mathvariant="bold">
                     x
                    </mtext>
                    <mrow>
                     <mo stretchy="false">
                      (
                     </mo>
                     <mi>
                      i
                     </mi>
                     <mo stretchy="false">
                      )
                     </mo>
                    </mrow>
                   </msup>
                  </mrow>
                  <mo>
                   -
                  </mo>
                  <msup>
                   <mi>
                    y
                   </mi>
                   <mrow>
                    <mo stretchy="false">
                     (
                    </mo>
                    <mi>
                     i
                    </mi>
                    <mo stretchy="false">
                     )
                    </mo>
                   </mrow>
                  </msup>
                 </mrow>
                 <mo stretchy="false">
                  )
                 </mo>
                </mrow>
                <mn>
                 2
                </mn>
               </msup>
              </mrow>
             </mrow>
             <mo>
              +
             </mo>
             <mrow>
              <mi>
               λ
              </mi>
              <mo>
               ⁢
              </mo>
              <msub>
               <mrow>
                <mo>
                 ∥
                </mo>
                <mi>
                 θ
                </mi>
                <mo>
                 ∥
                </mo>
               </mrow>
               <mi>
                p
               </mi>
              </msub>
             </mrow>
            </mrow>
           </mrow>
           <mo>
            .
           </mo>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <p>
       Ao minimizar a função acima com relação a seus parâmetros, encontra-se o melhor conjunto de θ para o problema em questão, levando assim a um modelo de ML treinado. O último termo inserido na função de custo é opcional, conhecido como parâmetro de regularização λ, sendo diferentes extensões da regressão linear, tal como a regressão
       <b>
        ridge
       </b>
       ou
       <b>
        LASSO
       </b>
       . O valor de
       <i>
        p
       </i>
       denota a métrica,
       <i>
        p = 0
       </i>
       é simplesmente o número de coeficientes diferentes de zero (normalmente não considerados uma métrica formalmente) em θ enquanto
       <i>
        p = 1
       </i>
       é referido como a métrica de Manhattan ou táxi, e
       <i>
        p = 2
       </i>
       é a métrica euclidiana usual. Quando se usa
       <i>
        p = 1
       </i>
       , o modelo de regressão é LASSO (Least Absolute Shrinkage and Selection Operator), onde devido à restrição imposta ao problema de minimização, nem todas as features presentes nos descritores são consideradas para o ajuste. Por outro lado, a regressão ridge corresponde a
       <i>
        p = 2
       </i>
       , e o resultado neste caso é apenas a redução dos valores absolutos das features, ou seja, features com valores muito grandes são penalizados, somando à função de custo. Tanto no LASSO quanto na regressão ridge, o parâmetro λ controla a complexidade do modelo, diminuindo e/ou selecionando as features. Assim, em ambos os casos, é recomendável começar com um modelo mais complexo e usar λ para diminuir sua complexidade. O parâmetro λ, entretanto, não pode ser aprendido da mesma maneira que θ, sendo referido como um hiperparâmetro que deve ser ajustado por, por exemplo, uma busca em grid para encontrar aquele que maximiza o poder de previsão sem introduzir muito viés (
       <i>
        bias
       </i>
       ).
      </p>
      <p>
       A classificação é usada para prever rótulos discretos. Um algoritmo de classificação muito popular é a
       <b>
        regressão logística
       </b>
       [
       <span class="ref">
        <sup class="xref xrefblue">
         20
        </sup>
        <span class="refCtt closed">
         <span>
          20. T. Hastie, R. Tibshirani e J. Friedman, The Elements of Statistical Learning (Springer, New York, 2001).
         </span>
        </span>
       </span>
       ], que pode ser interpretado como um mapeamento das previsões feitas por regressão linear no intervalo [0, 1]. Vamos supor que a tarefa de classificação em questão é decidir se um dado ponto
       <b>
        x
       </b>
       <sup>
        (
        <i>
         i
        </i>
        )
       </sup>
       pertence a uma classe particular (
       <i>
        y
       </i>
       <sup>
        (
        <i>
         i
        </i>
        )
       </sup>
       = 1) ou não (
       <i>
        y
       </i>
       <sup>
        (
        <i>
         i
        </i>
        )
       </sup>
       = 0). A previsão binária desejada pode ser obtida a partir de
      </p>
      <div class="row formula" id="eS2_E6">
       <a name="S2_E6">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (6)
         </span>
         <math alttext="\hat{y}=\sigma(\mathbf{\theta}^{T}\mathbf{x})=\frac{1}{1+e^{-\mathbf{\theta}^{% T}\mathbf{x}}}" display="block">
          <mrow>
           <mover accent="true">
            <mi>
             y
            </mi>
            <mo stretchy="false">
             ^
            </mo>
           </mover>
           <mo>
            =
           </mo>
           <mrow>
            <mi>
             σ
            </mi>
            <mo>
             ⁢
            </mo>
            <mrow>
             <mo stretchy="false">
              (
             </mo>
             <mrow>
              <msup>
               <mi>
                θ
               </mi>
               <mi>
                T
               </mi>
              </msup>
              <mo>
               ⁢
              </mo>
              <mtext mathvariant="bold">
               x
              </mtext>
             </mrow>
             <mo stretchy="false">
              )
             </mo>
            </mrow>
           </mrow>
           <mo>
            =
           </mo>
           <mfrac>
            <mn>
             1
            </mn>
            <mrow>
             <mn>
              1
             </mn>
             <mo>
              +
             </mo>
             <msup>
              <mi>
               e
              </mi>
              <mrow>
               <mo>
                -
               </mo>
               <mrow>
                <msup>
                 <mi>
                  θ
                 </mi>
                 <mi>
                  T
                 </mi>
                </msup>
                <mo>
                 ⁢
                </mo>
                <mi mathvariant="bold">
                 x
                </mi>
               </mrow>
              </mrow>
             </msup>
            </mrow>
           </mfrac>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <p>
       onde θ é novamente um vetor de parâmetros e σ é referido como a função logística ou sigmóide. Como exemplo, a função sigmóide junto com uma previsão de um conjunto de dados fictício é apresentada na Figura
       <a class="open-asset-modal" data-target="#ModalFigS2_F6" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        6
       </a>
       . Normalmente considera-se que a amostra
       <b>
        x
       </b>
       <sup>
        (
        <i>
         i
        </i>
        )
       </sup>
       pertence à classe rotulada por
       <i>
        y
       </i>
       <sup>
        (
        <i>
         i
        </i>
        )
       </sup>
       se
       <math id="INEQ29">
        <mrow>
         <msup>
          <mover accent="true">
           <mi>
            y
           </mi>
           <mo stretchy="false">
            ^
           </mo>
          </mover>
          <mrow>
           <mo stretchy="false">
            (
           </mo>
           <mi>
            i
           </mi>
           <mo stretchy="false">
            )
           </mo>
          </mrow>
         </msup>
         <mo>
          ≥
         </mo>
         <mn>
          0.5
         </mn>
        </mrow>
       </math>
       , mesmo que o rótulo previsto possa ser interpretado como uma probabilidade
       <math id="INEQ30">
        <mrow>
         <mover accent="true">
          <mi>
           y
          </mi>
          <mo stretchy="false">
           ^
          </mo>
         </mover>
         <mo>
          =
         </mo>
         <mi>
          P
         </mi>
         <mrow>
          <mo stretchy="false">
           (
          </mo>
          <mi>
           y
          </mi>
          <mo>
           =
          </mo>
          <mn>
           1
          </mn>
          <mo stretchy="false">
           |
          </mo>
          <mtext mathvariant="bold">
           x
          </mtext>
          <mo>
           ,
          </mo>
          <mi>
           θ
          </mi>
          <mo stretchy="false">
           )
          </mo>
         </mrow>
        </mrow>
       </math>
       . No caso da classificação, a função de custo é obtida a partir da log-probabilidade negativa. Assim, a obtenção dos melhores parâmetros θ requer a minimização dessa quantidade, dada por
      </p>
      <div class="row formula" id="eS2_E7">
       <a name="S2_E7">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (7)
         </span>
         <math alttext="\displaystyle J(\mathbf{\theta})=-\frac{1}{n}\sum_{i=1}^{n}\left[y^{(i)}\log(% \hat{y}^{(i)})\right." display="block">
          <mrow>
           <mi>
            J
           </mi>
           <mrow>
            <mo stretchy="false">
             (
            </mo>
            <mi>
             θ
            </mi>
            <mo stretchy="false">
             )
            </mo>
           </mrow>
           <mo>
            =
           </mo>
           <mo>
            -
           </mo>
           <mfrac>
            <mn>
             1
            </mn>
            <mi>
             n
            </mi>
           </mfrac>
           <munderover>
            <mo largeop="true" movablelimits="false" symmetric="true">
             ∑
            </mo>
            <mrow>
             <mi>
              i
             </mi>
             <mo>
              =
             </mo>
             <mn>
              1
             </mn>
            </mrow>
            <mi>
             n
            </mi>
           </munderover>
           <mrow>
            <mo>
             [
            </mo>
            <msup>
             <mi>
              y
             </mi>
             <mrow>
              <mo stretchy="false">
               (
              </mo>
              <mi>
               i
              </mi>
              <mo stretchy="false">
               )
              </mo>
             </mrow>
            </msup>
            <mi>
             log
            </mi>
            <mrow>
             <mo stretchy="false">
              (
             </mo>
             <msup>
              <mover accent="true">
               <mi>
                y
               </mi>
               <mo stretchy="false">
                ^
               </mo>
              </mover>
              <mrow>
               <mo stretchy="false">
                (
               </mo>
               <mi>
                i
               </mi>
               <mo stretchy="false">
                )
               </mo>
              </mrow>
             </msup>
             <mo stretchy="false">
              )
             </mo>
            </mrow>
           </mrow>
          </mrow>
         </math>
         <math alttext="\displaystyle\left.+(1-y^{(i)})\log(1-\hat{y}^{(i)})\right]" display="block">
          <mrow>
           <mo>
            +
           </mo>
           <mrow>
            <mo stretchy="false">
             (
            </mo>
            <mn>
             1
            </mn>
            <mo>
             -
            </mo>
            <msup>
             <mi>
              y
             </mi>
             <mrow>
              <mo stretchy="false">
               (
              </mo>
              <mi>
               i
              </mi>
              <mo stretchy="false">
               )
              </mo>
             </mrow>
            </msup>
            <mo stretchy="false">
             )
            </mo>
           </mrow>
           <mi>
            log
           </mi>
           <mrow>
            <mo stretchy="false">
             (
            </mo>
            <mn>
             1
            </mn>
            <mo>
             -
            </mo>
            <msup>
             <mover accent="true">
              <mi>
               y
              </mi>
              <mo stretchy="false">
               ^
              </mo>
             </mover>
             <mrow>
              <mo stretchy="false">
               (
              </mo>
              <mi>
               i
              </mi>
              <mo stretchy="false">
               )
              </mo>
             </mrow>
            </msup>
            <mo stretchy="false">
             )
            </mo>
           </mrow>
           <mo>
            ]
           </mo>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <p>
       onde
       <i>
        y
       </i>
       <sup>
        (
        <i>
         i
        </i>
        )
       </sup>
       e
       <math id="INEQ32">
        <mrow>
         <msup>
          <mover accent="true">
           <mi>
            y
           </mi>
           <mo stretchy="false">
            ^
           </mo>
          </mover>
          <mrow>
           <mo stretchy="false">
            (
           </mo>
           <mi>
            i
           </mi>
           <mo stretchy="false">
            )
           </mo>
          </mrow>
         </msup>
         <mo>
          =
         </mo>
         <mrow>
          <mi>
           σ
          </mi>
          <mo>
           ⁢
          </mo>
          <mrow>
           <mo stretchy="false">
            (
           </mo>
           <mrow>
            <msup>
             <mi>
              θ
             </mi>
             <mi>
              T
             </mi>
            </msup>
            <mo>
             ⁢
            </mo>
            <msup>
             <mtext mathvariant="bold">
              x
             </mtext>
             <mrow>
              <mo stretchy="false">
               (
              </mo>
              <mi>
               i
              </mi>
              <mo stretchy="false">
               )
              </mo>
             </mrow>
            </msup>
           </mrow>
           <mo stretchy="false">
            )
           </mo>
          </mrow>
         </mrow>
        </mrow>
       </math>
       são os rótulos binários verdadeiros (de referência) e previstos. Um parâmetro de regularização λ pode ser inserido na equação (
       <a class="open-asset-modal" data-target="#ModalSchemeS2_E7" data-toggle="modal" href="">
        <span class="sci-ico-fileFormula">
        </span>
        7
       </a>
       ) com a mesma intenção de selecionar as features, como visto na regressão linear anteriormente. Observe que a regressão logística também pode ser usada quando os dados apresentam várias classes. Neste caso, deve-se empregar a estratégia um-contra-todos, que consiste em treinar
       <i>
        n
       </i>
       modelos de regressão logística, um para cada classe, e prever os rótulos usando o classificador que apresentar maior probabilidade.
      </p>
      <p>
       Entre os métodos supervisionados, algoritmos populares de classificação são classificadores usando máquinas de vetores de suporte (
       <i>
        <b>
         support vector machines
        </b>
        , SVM
       </i>
       ) [
       <span class="ref">
        <sup class="xref xrefblue">
         33
        </sup>
        <span class="refCtt closed">
         <span>
          33. C. Cortes e V. Vapnik, Mach. Learn. 20, 273 (1995).
         </span>
        </span>
       </span>
       ] com uma variedade de funções kernel (linear, polinomial, Gaussiana, entre outras); o algoritmo não paramétrico
       <i>
        k-nearest neighbors
       </i>
       (
       <b>
        <i>
         k
        </i>
        -NN
       </b>
       ); algoritmos probabilísticos como
       <i>
        <b>
         Naive Bayes
        </b>
       </i>
       ;
       <b>
        árvores de decisão
       </b>
       [
       <span class="ref">
        <sup class="xref xrefblue">
         34
        </sup>
        <span class="refCtt closed">
         <span>
          34. R. Kohavi e R. Quinlan, Decision Tree Discovery , disponível em: http://ai.stanford.edu/∼ronnyk/ treesHB.pdf.
         </span>
         <br/>
         <a href="http://ai.stanford.edu/%E2%88%BCronnyk/%20treesHB.pdf" target="_blank">
          http://ai.stanford.edu/∼ronnyk/ treesHB....
         </a>
        </span>
       </span>
       ,
       <span class="ref">
        <sup class="xref xrefblue">
         35
        </sup>
        <span class="refCtt closed">
         <span>
          35. J.R. Quinlan, C4.5: Programs for Machine Learning (Morgan Kaufmann Publishers Inc., San Francisco, 1993).
         </span>
        </span>
       </span>
       ] e métodos relacionados de
       <i>
        ensemble
       </i>
       , como
       <b>
        Random Forests
       </b>
       [
       <span class="ref">
        <sup class="xref xrefblue">
         20
        </sup>
        <span class="refCtt closed">
         <span>
          20. T. Hastie, R. Tibshirani e J. Friedman, The Elements of Statistical Learning (Springer, New York, 2001).
         </span>
        </span>
       </span>
       ] e
       <i>
        <b>
         gradient boosting
        </b>
       </i>
       . No caso de tarefas de regressão, regressão linear, Ridge e LASSO, bem como árvores de decisão e regressores de Random Forests são algoritmos simples e populares. Uma revisão recente sobre métodos de ML para ciência de materiais apresenta uma explicação abrangente do funcionamento interno de muitos desses algoritmos [
       <span class="ref">
        <sup class="xref xrefblue">
         6
        </sup>
        <span class="refCtt closed">
         <span>
          6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
         </span>
        </span>
       </span>
       ], e um vasto material também pode ser encontrado na literatura [
       <span class="ref">
        <sup class="xref xrefblue">
         18
        </sup>
        <span class="refCtt closed">
         <span>
          18. K.P. Murphy, Machine Learning: A Probabilistic Perspective (MIT Press, Cambridge, 2012).
         </span>
        </span>
       </span>
       ,
       <span class="ref">
        <sup class="xref xrefblue">
         20
        </sup>
        <span class="refCtt closed">
         <span>
          20. T. Hastie, R. Tibshirani e J. Friedman, The Elements of Statistical Learning (Springer, New York, 2001).
         </span>
        </span>
       </span>
       ,
       <span class="ref">
        <sup class="xref xrefblue">
         21
        </sup>
        <span class="refCtt closed">
         <span>
          21. I. Goodfellow, Y. Bengio e A. Courville, Deep Learning , disponível em: http://www.deeplearningbook.org.
         </span>
         <br/>
         <a href="http://www.deeplearningbook.org" target="_blank">
          http://www.deeplearningbook.org...
         </a>
        </span>
       </span>
       ].
      </p>
      <p>
       Vale destacar separadamente, as
       <b>
        redes neurais
       </b>
       (
       <i>
        neural networks, NN
       </i>
       ), particularmente profundas (
       <i>
        <b>
         deep learning
        </b>
       </i>
       ) [
       <span class="ref">
        <sup class="xref xrefblue">
         21
        </sup>
        <span class="refCtt closed">
         <span>
          21. I. Goodfellow, Y. Bengio e A. Courville, Deep Learning , disponível em: http://www.deeplearningbook.org.
         </span>
         <br/>
         <a href="http://www.deeplearningbook.org" target="_blank">
          http://www.deeplearningbook.org...
         </a>
        </span>
       </span>
       ], que estão se tornando muito populares devido aos seus avanços recentes tal como para reconhecimento de imagens, bem como em tarefas de processamento de linguagem natural. Elas correspondem a uma classe de algoritmos que foram, pelo menos em seu início, inspiradas pela estrutura do cérebro. Uma NN pode ser descrita como um grafo direcionado ponderado, ou seja, uma estrutura composta por camadas contendo unidades de processamento chamadas neurônios, que por sua vez são conectadas a outras camadas, conforme ilustrado na Figura
       <a class="open-asset-modal" data-target="#ModalFigS2_F6" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        6
       </a>
       . Muitos tipos de NNs são usados para uma variedade de tarefas como regressão e classificação, e algumas das arquiteturas mais populares para tais redes são NNs
       <i>
        feed-forward
       </i>
       , recorrentes e convolucionais. As principais diferenças entre essas arquiteturas são basicamente os padrões de conexão e as operações que seus neurônios executam nos dados. Normalmente em uma NN, uma camada de entrada recebe os vetores de features do conjunto de treinamento, e uma série de operações não lineares é realizada enquanto os dados propagam através das subsequentes chamadas
       <i>
        camadas ocultas
       </i>
       . Finalmente, o resultado do processamento é coletado na camada de saída, que pode ser uma classificação binária ou multinária (probabilística), ou mesmo um mapeamento contínuo como em um modelo de regressão linear. Um ponto muito interessante nesse processo, é que a própria rede aprende representações otimizadas do conjunto de dados, normalmente ao custo de cojuntos de dados maiores, visto o número exponencialmente grande de coeficientes a serem determinados. Em uma NN, a entrada
       <math id="INEQ33">
        <msubsup>
         <mi>
          z
         </mi>
         <mi>
          i
         </mi>
         <mrow>
          <mo stretchy="false">
           (
          </mo>
          <mi>
           k
          </mi>
          <mo stretchy="false">
           )
          </mo>
         </mrow>
        </msubsup>
       </math>
       do
       <i>
        i
       </i>
       -ésimo neurônio na
       <i>
        k
       </i>
       -ésima camada é uma função das saídas
       <math id="INEQ34">
        <msubsup>
         <mi>
          y
         </mi>
         <mi>
          j
         </mi>
         <mrow>
          <mo stretchy="false">
           (
          </mo>
          <mrow>
           <mi>
            k
           </mi>
           <mo>
            -
           </mo>
           <mn>
            1
           </mn>
          </mrow>
          <mo stretchy="false">
           )
          </mo>
         </mrow>
        </msubsup>
       </math>
       da camada anterior
      </p>
      <p>
      </p>
      <div class="row formula" id="eS2_E8">
       <a name="S2_E8">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (8)
         </span>
         <math alttext="z_{i}^{(k)}=\omega_{i0}^{(k)}+\sum_{j}y_{j}^{(k-1)}\omega_{ij}^{(k)}" display="block">
          <mrow>
           <msubsup>
            <mi>
             z
            </mi>
            <mi>
             i
            </mi>
            <mrow>
             <mo stretchy="false">
              (
             </mo>
             <mi>
              k
             </mi>
             <mo stretchy="false">
              )
             </mo>
            </mrow>
           </msubsup>
           <mo>
            =
           </mo>
           <mrow>
            <msubsup>
             <mi>
              ω
             </mi>
             <mrow>
              <mi>
               i
              </mi>
              <mo>
               ⁢
              </mo>
              <mn>
               0
              </mn>
             </mrow>
             <mrow>
              <mo stretchy="false">
               (
              </mo>
              <mi>
               k
              </mi>
              <mo stretchy="false">
               )
              </mo>
             </mrow>
            </msubsup>
            <mo>
             +
            </mo>
            <mrow>
             <munder>
              <mo largeop="true" movablelimits="false" symmetric="true">
               ∑
              </mo>
              <mi>
               j
              </mi>
             </munder>
             <mrow>
              <msubsup>
               <mi>
                y
               </mi>
               <mi>
                j
               </mi>
               <mrow>
                <mo stretchy="false">
                 (
                </mo>
                <mrow>
                 <mi>
                  k
                 </mi>
                 <mo>
                  -
                 </mo>
                 <mn>
                  1
                 </mn>
                </mrow>
                <mo stretchy="false">
                 )
                </mo>
               </mrow>
              </msubsup>
              <mo>
               ⁢
              </mo>
              <msubsup>
               <mi>
                ω
               </mi>
               <mrow>
                <mi>
                 i
                </mi>
                <mo>
                 ⁢
                </mo>
                <mi>
                 j
                </mi>
               </mrow>
               <mrow>
                <mo stretchy="false">
                 (
                </mo>
                <mi>
                 k
                </mi>
                <mo stretchy="false">
                 )
                </mo>
               </mrow>
              </msubsup>
             </mrow>
            </mrow>
           </mrow>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <p>
       onde
       <math id="INEQ35">
        <msubsup>
         <mi>
          ω
         </mi>
         <mrow>
          <mi>
           i
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           j
          </mi>
         </mrow>
         <mrow>
          <mo stretchy="false">
           (
          </mo>
          <mi>
           k
          </mi>
          <mo stretchy="false">
           )
          </mo>
         </mrow>
        </msubsup>
       </math>
       é o elemento da matriz que conecta as camadas adjacentes. O elemento
       <math id="INEQ36">
        <msubsup>
         <mi>
          w
         </mi>
         <mrow>
          <mi>
           i
          </mi>
          <mo>
           ⁢
          </mo>
          <mn>
           0
          </mn>
         </mrow>
         <mrow>
          <mo stretchy="false">
           (
          </mo>
          <mi>
           k
          </mi>
          <mo stretchy="false">
           )
          </mo>
         </mrow>
        </msubsup>
       </math>
       é conhecido como viés (
       <i>
        bias
       </i>
       ), porque não faz parte da combinação linear de entradas. A entrada é então transformada por meio de uma função não-linear ou de ativação, tal como a tangente hiperbólica,
      </p>
      <p>
      </p>
      <div class="row formula" id="eS2_E9">
       <a name="S2_E9">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (9)
         </span>
         <math alttext="y_{i}^{(k)}=\frac{e^{z_{i}^{(k)}}-e^{-z_{i}^{(k)}}}{e^{z_{i}^{(k)}}+e^{-z_{i}^% {(k)}}}," display="block">
          <mrow>
           <mrow>
            <msubsup>
             <mi>
              y
             </mi>
             <mi>
              i
             </mi>
             <mrow>
              <mo stretchy="false">
               (
              </mo>
              <mi>
               k
              </mi>
              <mo stretchy="false">
               )
              </mo>
             </mrow>
            </msubsup>
            <mo>
             =
            </mo>
            <mfrac>
             <mrow>
              <msup>
               <mi>
                e
               </mi>
               <msubsup>
                <mi>
                 z
                </mi>
                <mi>
                 i
                </mi>
                <mrow>
                 <mo stretchy="false">
                  (
                 </mo>
                 <mi>
                  k
                 </mi>
                 <mo stretchy="false">
                  )
                 </mo>
                </mrow>
               </msubsup>
              </msup>
              <mo>
               -
              </mo>
              <msup>
               <mi>
                e
               </mi>
               <mrow>
                <mo>
                 -
                </mo>
                <msubsup>
                 <mi>
                  z
                 </mi>
                 <mi>
                  i
                 </mi>
                 <mrow>
                  <mo stretchy="false">
                   (
                  </mo>
                  <mi>
                   k
                  </mi>
                  <mo stretchy="false">
                   )
                  </mo>
                 </mrow>
                </msubsup>
               </mrow>
              </msup>
             </mrow>
             <mrow>
              <msup>
               <mi>
                e
               </mi>
               <msubsup>
                <mi>
                 z
                </mi>
                <mi>
                 i
                </mi>
                <mrow>
                 <mo stretchy="false">
                  (
                 </mo>
                 <mi>
                  k
                 </mi>
                 <mo stretchy="false">
                  )
                 </mo>
                </mrow>
               </msubsup>
              </msup>
              <mo>
               +
              </mo>
              <msup>
               <mi>
                e
               </mi>
               <mrow>
                <mo>
                 -
                </mo>
                <msubsup>
                 <mi>
                  z
                 </mi>
                 <mi>
                  i
                 </mi>
                 <mrow>
                  <mo stretchy="false">
                   (
                  </mo>
                  <mi>
                   k
                  </mi>
                  <mo stretchy="false">
                   )
                  </mo>
                 </mrow>
                </msubsup>
               </mrow>
              </msup>
             </mrow>
            </mfrac>
           </mrow>
           <mo>
            ,
           </mo>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <p>
       que resulta no mapeamento do vetor de entrada da camada anterior em um novo espaço vetorial, permitindo que a rede forneça predições para problemas altamente complexos.
      </p>
      <p>
       Por fim, vamos discutir como avaliar a qualidade dos modelos, métricas de desempenho e precauções a serem tomadas para gerar modelos coerentes. Um algoritmo de aprendizado supervisionado de ML é considerado treinado quando seus parâmetros ótimos dados as amostras de treinamento são encontrados, minimizando a função de custo. No entanto, os hiperparâmetros geralmente não podem ser aprendidos dessa maneira, e o estudo do desempenho do modelo em um conjunto separado, denominado conjunto de validação, em função de tais parâmetros é necessário. Este processo é conhecido como
       <b>
        validação
       </b>
       . A maneira usual de fazer isso é separar o conjunto de dados em 3 conjuntos separados: os conjuntos de treinamento, validação e teste. Espera-se que seus elementos sejam da mesma natureza, ou seja, venham da mesma distribuição estatística. O processo de aprendizagem é então realizado várias vezes para otimizar o modelo. Finalmente, usando o conjunto de teste, pode-se confrontar as previsões com os rótulos de referência e medir o quão bem o modelo está desempenhando. Particularmente em métodos supervisionados, dois problemas principais podem surgir então:
       <i>
        (i)
       </i>
       se os vetores de descritores apresentam um número insuficiente de features, ou seja, não é geral o suficiente para capturar as tendências nos dados e o modelo de regressão é considerado enviesado, e
       <i>
        (ii)
       </i>
       se o descritor apresenta muitas informações, o que faz com que o modelo de regressão se ajuste aos dados de treinamento excessivamente bem, mas sofre para generalizar para novos dados, então é dito que o modelo sofre sobre-ajuste (
       <i>
        overfitting
       </i>
       ) ou variância. Esses são dois extremos da complexidade dos modelos, diretamente relacionado ao número de parâmetros, onde o equilíbrio ideal é representado na Figura
       <a class="open-asset-modal" data-target="#ModalFigS2_F7" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        7
       </a>
       . Normalmente se utiliza o parâmetro de regularização λ a fim de diminuir de forma sistemática a complexidade do modelo e encontrar o ponto ótimo.
      </p>
      <div class="row fig" id="S2_F7">
       <a name="S2_F7">
       </a>
       <div class="col-md-4 col-sm-4">
        <a data-target="#ModalFigS2_F7" data-toggle="modal" href="">
         <div class="thumbImg">
          <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/228acb3c708065e364c9afcb766ace987abc2c2f.jpg"/>
          <div class="zoom">
           <span class="sci-ico-zoom">
           </span>
          </div>
         </div>
        </a>
       </div>
       <div class="col-md-8 col-sm-8">
        <strong>
         Figura 7
        </strong>
        <br/>
        Balanço entre viés (
        <i>
         bias
        </i>
        ) × variância. A complexidade ideal do modelo é avaliada em relação ao erro das predições avaliadas no conjunto de teste. Adaptado de [
        <span class="ref">
         <sup class="xref xrefblue">
          6
         </sup>
         <span class="refCtt closed">
          <span>
           6. G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials 2, 032001 (2019).
          </span>
         </span>
        </span>
        ]
        <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">
         CC BY 3.0
        </a>
        .
        <br/>
       </div>
      </div>
      <p>
       Quando uma quantidade limitada de dados está disponível para treinamento, remover uma fração desse conjunto para criar o conjunto de teste pode impactar negativamente o processo de treinamento, e formas alternativas devem ser empregadas. Um dos métodos mais populares neste cenário é a
       <b>
        validação cruzada
       </b>
       , que consiste em particionar o conjunto de treinamento em
       <i>
        k
       </i>
       subconjuntos, treinar o modelo usando
       <i>
        k-1
       </i>
       subconjuntos e validar o modelo treinado usando o conjunto que não foi usado para o treinamento. Este processo é executado
       <i>
        k
       </i>
       vezes e a média de cada etapa de validação é usada para calcular a média do desempenho,
      </p>
      <p>
      </p>
      <div class="row formula" id="eS2_E10">
       <a name="S2_E10">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (10)
         </span>
         <math alttext="E_{cv}^{K}=\frac{1}{K}\sum_{k=1}^{K}\sum_{i=1}^{n_{k}}L(\hat{y}_{k}^{(i)},y^{(% i)})" display="block">
          <mrow>
           <msubsup>
            <mi>
             E
            </mi>
            <mrow>
             <mi>
              c
             </mi>
             <mo>
              ⁢
             </mo>
             <mi>
              v
             </mi>
            </mrow>
            <mi>
             K
            </mi>
           </msubsup>
           <mo>
            =
           </mo>
           <mrow>
            <mfrac>
             <mn>
              1
             </mn>
             <mi>
              K
             </mi>
            </mfrac>
            <mo>
             ⁢
            </mo>
            <mrow>
             <munderover>
              <mo largeop="true" movablelimits="false" symmetric="true">
               ∑
              </mo>
              <mrow>
               <mi>
                k
               </mi>
               <mo>
                =
               </mo>
               <mn>
                1
               </mn>
              </mrow>
              <mi>
               K
              </mi>
             </munderover>
             <mrow>
              <munderover>
               <mo largeop="true" movablelimits="false" symmetric="true">
                ∑
               </mo>
               <mrow>
                <mi>
                 i
                </mi>
                <mo>
                 =
                </mo>
                <mn>
                 1
                </mn>
               </mrow>
               <msub>
                <mi>
                 n
                </mi>
                <mi>
                 k
                </mi>
               </msub>
              </munderover>
              <mrow>
               <mi>
                L
               </mi>
               <mo>
                ⁢
               </mo>
               <mrow>
                <mo stretchy="false">
                 (
                </mo>
                <msubsup>
                 <mover accent="true">
                  <mi>
                   y
                  </mi>
                  <mo stretchy="false">
                   ^
                  </mo>
                 </mover>
                 <mi>
                  k
                 </mi>
                 <mrow>
                  <mo stretchy="false">
                   (
                  </mo>
                  <mi>
                   i
                  </mi>
                  <mo stretchy="false">
                   )
                  </mo>
                 </mrow>
                </msubsup>
                <mo>
                 ,
                </mo>
                <msup>
                 <mi>
                  y
                 </mi>
                 <mrow>
                  <mo stretchy="false">
                   (
                  </mo>
                  <mi>
                   i
                  </mi>
                  <mo stretchy="false">
                   )
                  </mo>
                 </mrow>
                </msup>
                <mo stretchy="false">
                 )
                </mo>
               </mrow>
              </mrow>
             </mrow>
            </mrow>
           </mrow>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <p>
       onde
       <i>
        L
       </i>
       é a função de perda e
       <math id="INEQ37">
        <msubsup>
         <mover accent="true">
          <mi>
           y
          </mi>
          <mo stretchy="false">
           ^
          </mo>
         </mover>
         <mi>
          k
         </mi>
         <mrow>
          <mo stretchy="false">
           (
          </mo>
          <mi>
           i
          </mi>
          <mo stretchy="false">
           )
          </mo>
         </mrow>
        </msubsup>
       </math>
       é o rótulo previsto do
       <i>
        i
       </i>
       -ésimo exemplo de treinamento do modelo treinado usando o subconjunto dos dados de treinamento, excluindo o subconjunto
       <i>
        k
       </i>
       , que tem o tamanho
       <i>
        n_k
       </i>
       .
      </p>
      <p>
       Existem muitas maneiras de avaliar o desempenho, sendo de suma importância particularmente para modelos supervisionados. Em tarefas de classificação binária ou multinária, é muito comum o uso de matrizes de confusão, onde o número de elementos preditos corretamente são apresentados nas entradas diagonais enquanto os elementos que foram preditos incorretamente são contados nas entradas fora da diagonal. Pode-se pensar no índice vertical como os rótulos reais e no índice horizontal como as previsões, e falsos (F) positivos (P) ou negativos (N) são previsões positivas para casos negativos e vice-versa, respectivamente. A curva de característica de operação do receptor (
       <i>
        ROC curve
       </i>
       ) também é usada rotineiramente, sendo o gráfico da taxa de verdadeiros (V) positivos
       <math id="INEQ38">
        <mrow>
         <mrow>
          <mi>
           T
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           V
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           P
          </mi>
         </mrow>
         <mo>
          =
         </mo>
         <mfrac>
          <mrow>
           <mi>
            V
           </mi>
           <mo>
            ⁢
           </mo>
           <mi>
            P
           </mi>
          </mrow>
          <mrow>
           <mrow>
            <mi>
             V
            </mi>
            <mo>
             ⁢
            </mo>
            <mi>
             P
            </mi>
           </mrow>
           <mo>
            +
           </mo>
           <mrow>
            <mi>
             F
            </mi>
            <mo>
             ⁢
            </mo>
            <mi>
             N
            </mi>
           </mrow>
          </mrow>
         </mfrac>
        </mrow>
       </math>
       versus a taxa de falsos positivos
       <math id="INEQ39">
        <mrow>
         <mrow>
          <mi>
           T
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           F
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           P
          </mi>
         </mrow>
         <mo>
          =
         </mo>
         <mfrac>
          <mrow>
           <mi>
            F
           </mi>
           <mo>
            ⁢
           </mo>
           <mi>
            P
           </mi>
          </mrow>
          <mrow>
           <mrow>
            <mi>
             F
            </mi>
            <mo>
             ⁢
            </mo>
            <mi>
             P
            </mi>
           </mrow>
           <mo>
            +
           </mo>
           <mrow>
            <mi>
             V
            </mi>
            <mo>
             ⁢
            </mo>
            <mi>
             N
            </mi>
           </mrow>
          </mrow>
         </mfrac>
        </mrow>
       </math>
       variando o limiar inter-classes. Um exemplo é mostrado na Fig.
       <a class="open-asset-modal" data-target="#ModalFigS3_F11" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        11
       </a>
       a.
      </p>
      <div class="row fig" id="S3_F11">
       <a name="S3_F11">
       </a>
       <div class="col-md-4 col-sm-4">
        <a data-target="#ModalFigS3_F11" data-toggle="modal" href="">
         <div class="thumbImg">
          <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/e8b203ad0e01c4dd15eab4f9373f2dbf740976c7.jpg"/>
          <div class="zoom">
           <span class="sci-ico-zoom">
           </span>
          </div>
         </div>
        </a>
       </div>
       <div class="col-md-8 col-sm-8">
        <strong>
         Figura 11
        </strong>
        <br/>
        Resultados do modelo de ML e aplicação [
        <span class="ref">
         <sup class="xref xrefblue">
          24
         </sup>
         <span class="refCtt closed">
          <span>
           24. G.R. Schleder, C.M. Acosta e A. Fazzio, ACS Applied Materials &amp; Interfaces 12, 20149 (2020).
          </span>
         </span>
        </span>
        ]. (a) Curva ROC e área sob a curva como métrica do modelo de classificação para cada classe: baixa (vermelho), média (laranja) e alta estabilidade (verde). (b) Importância das 20 features mais importantes do modelo de classificação. (c) Gráfico de paridade das energias de formação para a classe de alta estabilidade comparando os valores calculados por DFT com o modelo de regressão obtido via ML. O erro RMSE da validação cruzada é 0.205 eV/átomo. (d) Uso do modelo ML como critério de seleção de materiais para fotoeletrocatálise de água. Alinhamento de banda dos candidatos selecionados em relação ao vácuo. Os potenciais para as reações
        <i>
         H
        </i>
        <sup>
         +
        </sup>
        /
        <i>
         H
        </i>
        <sub>
         2
        </sub>
        e
        <i>
         O
        </i>
        <sub>
         2
        </sub>
        /
        <i>
         H
        </i>
        <sub>
         2
        </sub>
        <i>
         O
        </i>
        estão destacados entre as linhas tracejadas. O candidato Sn
        <sub>
         2
        </sub>
        SeTe foi previsto pelo modelo de classificação. Adaptado com permissão de [
        <span class="ref">
         <sup class="xref xrefblue">
          24
         </sup>
         <span class="refCtt closed">
          <span>
           24. G.R. Schleder, C.M. Acosta e A. Fazzio, ACS Applied Materials &amp; Interfaces 12, 20149 (2020).
          </span>
         </span>
        </span>
        ]. Copyright 2019 American Chemical Society.
        <br/>
       </div>
      </div>
      <p>
       No caso de tarefas de regressão, existem várias métricas da performance do ajuste. O erro médio absoluto
       <math id="INEQ40">
        <mrow>
         <mrow>
          <mi>
           M
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           A
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           E
          </mi>
         </mrow>
         <mo>
          =
         </mo>
         <mrow>
          <mfrac>
           <mn>
            1
           </mn>
           <mi>
            n
           </mi>
          </mfrac>
          <mo>
           ⁢
          </mo>
          <mrow>
           <msubsup>
            <mo largeop="true" symmetric="true">
             ∑
            </mo>
            <mi>
             i
            </mi>
            <mi>
             n
            </mi>
           </msubsup>
           <mrow>
            <mo stretchy="false">
             |
            </mo>
            <mrow>
             <msub>
              <mi>
               y
              </mi>
              <mi>
               i
              </mi>
             </msub>
             <mo>
              -
             </mo>
             <msub>
              <mover accent="true">
               <mi>
                y
               </mi>
               <mo stretchy="false">
                ^
               </mo>
              </mover>
              <mi>
               i
              </mi>
             </msub>
            </mrow>
            <mo stretchy="false">
             |
            </mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
       </math>
       , mede desvios na mesma unidade da variável e também não é sensível a
       <i>
        outliers
       </i>
       . Existe a versão normalizada expressa em porcentagem
       <math id="INEQ41">
        <mrow>
         <mrow>
          <mi>
           M
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           A
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           P
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           E
          </mi>
         </mrow>
         <mo>
          =
         </mo>
         <mrow>
          <mfrac>
           <mrow>
            <mn>
             100
            </mn>
            <mo lspace="0pt" rspace="3.5pt">
             %
            </mo>
           </mrow>
           <mi>
            n
           </mi>
          </mfrac>
          <mo>
           ⁢
          </mo>
          <mrow>
           <msubsup>
            <mo largeop="true" symmetric="true">
             ∑
            </mo>
            <mi>
             i
            </mi>
            <mi>
             n
            </mi>
           </msubsup>
           <mfrac>
            <mrow>
             <msub>
              <mi>
               y
              </mi>
              <mi>
               i
              </mi>
             </msub>
             <mo>
              -
             </mo>
             <msub>
              <mover accent="true">
               <mi>
                y
               </mi>
               <mo stretchy="false">
                ^
               </mo>
              </mover>
              <mi>
               i
              </mi>
             </msub>
            </mrow>
            <msub>
             <mi>
              y
             </mi>
             <mi>
              i
             </mi>
            </msub>
           </mfrac>
          </mrow>
         </mrow>
        </mrow>
       </math>
       . O erro quadrático médio
       <math id="INEQ42">
        <mrow>
         <mrow>
          <mi>
           M
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           S
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           E
          </mi>
         </mrow>
         <mo>
          =
         </mo>
         <mrow>
          <mfrac>
           <mn>
            1
           </mn>
           <mi>
            n
           </mi>
          </mfrac>
          <mo>
           ⁢
          </mo>
          <mrow>
           <msubsup>
            <mo largeop="true" symmetric="true">
             ∑
            </mo>
            <mi>
             i
            </mi>
            <mi>
             n
            </mi>
           </msubsup>
           <msup>
            <mrow>
             <mo stretchy="false">
              (
             </mo>
             <mrow>
              <msub>
               <mi>
                y
               </mi>
               <mi>
                i
               </mi>
              </msub>
              <mo>
               -
              </mo>
              <msub>
               <mover accent="true">
                <mi>
                 y
                </mi>
                <mo stretchy="false">
                 ^
                </mo>
               </mover>
               <mi>
                i
               </mi>
              </msub>
             </mrow>
             <mo stretchy="false">
              )
             </mo>
            </mrow>
            <mn>
             2
            </mn>
           </msup>
          </mrow>
         </mrow>
        </mrow>
       </math>
       combina medições de
       <i>
        bias
       </i>
       e variância da previsão. Do ponto de vista frequentista, a estimativa
       <math id="INEQ43">
        <msub>
         <mover accent="true">
          <mi>
           θ
          </mi>
          <mo stretchy="false">
           ^
          </mo>
         </mover>
         <mi>
          m
         </mi>
        </msub>
       </math>
       de um parâmetro de distribuição θ está intimamente relacionada com o MSE, através da fórmula
       <math id="INEQ44">
        <mrow>
         <mrow>
          <mi>
           M
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           S
          </mi>
          <mo>
           ⁢
          </mo>
          <mi>
           E
          </mi>
         </mrow>
         <mo>
          =
         </mo>
         <mrow>
          <mi>
           𝔼
          </mi>
          <mo>
           ⁢
          </mo>
          <mrow>
           <mo stretchy="false">
            [
           </mo>
           <msup>
            <mrow>
             <mo stretchy="false">
              (
             </mo>
             <mrow>
              <msub>
               <mover accent="true">
                <mi>
                 θ
                </mi>
                <mo stretchy="false">
                 ^
                </mo>
               </mover>
               <mi>
                m
               </mi>
              </msub>
              <mo>
               -
              </mo>
              <mi>
               θ
              </mi>
             </mrow>
             <mo stretchy="false">
              )
             </mo>
            </mrow>
            <mn>
             2
            </mn>
           </msup>
           <mo stretchy="false">
            ]
           </mo>
          </mrow>
         </mrow>
         <mo>
          =
         </mo>
         <mrow>
          <mrow>
           <mi>
            B
           </mi>
           <mo>
            ⁢
           </mo>
           <mi>
            i
           </mi>
           <mo>
            ⁢
           </mo>
           <mi>
            a
           </mi>
           <mo>
            ⁢
           </mo>
           <mi>
            s
           </mi>
           <mo>
            ⁢
           </mo>
           <msup>
            <mrow>
             <mo stretchy="false">
              (
             </mo>
             <msub>
              <mover accent="true">
               <mi>
                θ
               </mi>
               <mo stretchy="false">
                ^
               </mo>
              </mover>
              <mi>
               m
              </mi>
             </msub>
             <mo stretchy="false">
              )
             </mo>
            </mrow>
            <mn>
             2
            </mn>
           </msup>
          </mrow>
          <mo>
           +
          </mo>
          <mrow>
           <mi>
            V
           </mi>
           <mo>
            ⁢
           </mo>
           <mi>
            a
           </mi>
           <mo>
            ⁢
           </mo>
           <mi>
            r
           </mi>
           <mo>
            ⁢
           </mo>
           <mrow>
            <mo stretchy="false">
             (
            </mo>
            <msub>
             <mover accent="true">
              <mi>
               θ
              </mi>
              <mo stretchy="false">
               ^
              </mo>
             </mover>
             <mi>
              m
             </mi>
            </msub>
            <mo stretchy="false">
             )
            </mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
       </math>
       . O MSE, ou seja, a função de custo dada na equação (
       <a class="open-asset-modal" data-target="#ModalSchemeS2_E5" data-toggle="modal" href="">
        <span class="sci-ico-fileFormula">
        </span>
        5
       </a>
       ) (quando se introduz ou não um parâmetro de regularização λ), idealmente seria zero para pontos de dados exatamente em cima da função obtida por meio da regressão. O MSE costuma ser utilizado tomando sua raiz (RMSE), que recupera a unidade original, facilitando a interpretação da precisão do modelo. Finalmente, também é utilizado o coeficiente de determinação estatístico
       <i>
        R
       </i>
       <sup>
        2
       </sup>
       , definido como
       <math id="INEQ46">
        <mrow>
         <msup>
          <mi>
           R
          </mi>
          <mn>
           2
          </mn>
         </msup>
         <mo>
          =
         </mo>
         <mrow>
          <mn>
           1
          </mn>
          <mo>
           -
          </mo>
          <mfrac>
           <mrow>
            <mi>
             S
            </mi>
            <mo>
             ⁢
            </mo>
            <msub>
             <mi>
              S
             </mi>
             <mrow>
              <mi>
               r
              </mi>
              <mo>
               ⁢
              </mo>
              <mi>
               e
              </mi>
              <mo>
               ⁢
              </mo>
              <mi>
               s
              </mi>
             </mrow>
            </msub>
           </mrow>
           <mrow>
            <mi>
             S
            </mi>
            <mo>
             ⁢
            </mo>
            <msub>
             <mi>
              S
             </mi>
             <mrow>
              <mi>
               t
              </mi>
              <mo>
               ⁢
              </mo>
              <mi>
               o
              </mi>
              <mo>
               ⁢
              </mo>
              <mi>
               t
              </mi>
             </mrow>
            </msub>
           </mrow>
          </mfrac>
         </mrow>
        </mrow>
       </math>
       , onde a soma total dos quadrados é
       <math id="INEQ47">
        <mrow>
         <mrow>
          <mi>
           S
          </mi>
          <mo>
           ⁢
          </mo>
          <msub>
           <mi>
            S
           </mi>
           <mrow>
            <mi>
             t
            </mi>
            <mo>
             ⁢
            </mo>
            <mi>
             o
            </mi>
            <mo>
             ⁢
            </mo>
            <mi>
             t
            </mi>
           </mrow>
          </msub>
         </mrow>
         <mo>
          =
         </mo>
         <mrow>
          <msub>
           <mo largeop="true" symmetric="true">
            ∑
           </mo>
           <mi>
            i
           </mi>
          </msub>
          <msup>
           <mrow>
            <mo stretchy="false">
             (
            </mo>
            <mrow>
             <msub>
              <mi>
               y
              </mi>
              <mi>
               i
              </mi>
             </msub>
             <mo>
              -
             </mo>
             <mover accent="true">
              <mi>
               y
              </mi>
              <mo stretchy="false">
               ¯
              </mo>
             </mover>
            </mrow>
            <mo stretchy="false">
             )
            </mo>
           </mrow>
           <mn>
            2
           </mn>
          </msup>
         </mrow>
        </mrow>
       </math>
       e a soma residual dos quadrados é
       <math id="INEQ48">
        <mrow>
         <mrow>
          <mi>
           S
          </mi>
          <mo>
           ⁢
          </mo>
          <msub>
           <mi>
            S
           </mi>
           <mrow>
            <mi>
             r
            </mi>
            <mo>
             ⁢
            </mo>
            <mi>
             e
            </mi>
            <mo>
             ⁢
            </mo>
            <mi>
             s
            </mi>
           </mrow>
          </msub>
         </mrow>
         <mo>
          =
         </mo>
         <mrow>
          <msub>
           <mo largeop="true" symmetric="true">
            ∑
           </mo>
           <mi>
            i
           </mi>
          </msub>
          <msup>
           <mrow>
            <mo stretchy="false">
             (
            </mo>
            <mrow>
             <msub>
              <mi>
               y
              </mi>
              <mi>
               i
              </mi>
             </msub>
             <mo>
              -
             </mo>
             <msub>
              <mover accent="true">
               <mi>
                y
               </mi>
               <mo stretchy="false">
                ^
               </mo>
              </mover>
              <mi>
               i
              </mi>
             </msub>
            </mrow>
            <mo stretchy="false">
             )
            </mo>
           </mrow>
           <mn>
            2
           </mn>
          </msup>
         </mrow>
        </mrow>
       </math>
       . O
       <i>
        R
       </i>
       <sup>
        2
       </sup>
       é usualmente visualizado em gráficos de paridade, onde compara-se os valores preditos pelo modelo de ML com os valores de referência. Um exemplo é mostrado na Fig.
       <a class="open-asset-modal" data-target="#ModalFigS3_F11" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        11
       </a>
       c.
      </p>
     </li>
    </ol>
    <p>
     Na prática, existem diversos
     <i>
      softwares
     </i>
     e programas computacionais que implementam os diferentes algoritmos de machine learning. Um dos mais acessíveis, completos e utilizados é o
     <i>
      scikit-learn
     </i>
     [
     <span class="ref">
      <sup class="xref xrefblue">
       36
      </sup>
      <span class="refCtt closed">
       <span>
        36. F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg et al., Journal of Machine Learning Research 12, 2825 (2011).
       </span>
      </span>
     </span>
     ], implementado como uma biblioteca escrita em
     <i>
      python
     </i>
     . Uma implementação também acessível e com interface gráfica é o software
     <i>
      Weka
     </i>
     [
     <span class="ref">
      <sup class="xref xrefblue">
       37
      </sup>
      <span class="refCtt closed">
       <span>
        37. M. Hall, E. Frank, G. Holmes, B. Pfahringer, P. Reutemann e I.H. Witten, ACM SIGKDD explorations newsletter 11, 10 (2009).
       </span>
      </span>
     </span>
     ]. Duas das implementações mais utilizadas de
     <i>
      deep learning
     </i>
     são os códigos
     <i>
      tensorflow
     </i>
     [
     <span class="ref">
      <sup class="xref xrefblue">
       38
      </sup>
      <span class="refCtt closed">
       <span>
        38. tensorflow.org.
       </span>
       <br/>
       <a href="tensorflow.org" target="_blank">
        tensorflow.org...
       </a>
      </span>
     </span>
     ] e
     <i>
      pytorch
     </i>
     [
     <span class="ref">
      <sup class="xref xrefblue">
       39
      </sup>
      <span class="refCtt closed">
       <span>
        39. A. Paszke, S. Gross, F. Massa, A. Lerer, J. Bradbury, G. Chanan, T. Killeen, Z. Lin, N. Gimelshein, L. Antiga et al., arXiv:1912.01703 (2019).
       </span>
      </span>
     </span>
     ]. Um tutorial prático introdutório de uso do machine learning com aplicações para materiais pode ser encontrado em [
     <span class="ref">
      <sup class="xref xrefblue">
       40
      </sup>
      <span class="refCtt closed">
       <span>
        40. G.R. Schleder, gschleder/MLtutorial-v1.0.0.zip (2019), v. 1, disponível em: 10.5281/zenodo.4041648.
       </span>
       <br/>
       <a href="https://doi.org/10.5281/zenodo.4041648https://doi.org/10.5281/zenodo.4041648" target="_blank">
        https://doi.org/10.5281/zenodo.4041648ht...
       </a>
      </span>
     </span>
     ].
    </p>
    <p>
     Finalmente, vale destacar que existe um balanço entre os diferentes componentes para cada determinado problema de ML. O tamanho do conjunto de dados, a representação usada e o algoritmo a ser empregado estão intimamente relacionados à construção de cada modelo e devem ser balanceados com cuidado, conforme discutido na Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F8" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      8
     </a>
     . Em relação aos dados, na física, química e ciência de materiais, a natureza dos conjuntos de dados envolvidos é muito diferente daqueles com os quais o aprendizado de máquina foi historicamente projetado para trabalhar, que são, tamanhos grandes, espaços com poucas features de dimensionalidade fixa e baixa variância; sendo então caracterizado como “
     <i>
      little-data
     </i>
     ” [
     <span class="ref">
      <sup class="xref xrefblue">
       46
      </sup>
      <span class="refCtt closed">
       <span>
        46. A.S. Barnard, B. Motevalli, A.J. Parker, J.M. Fischer, C.A. Feigl e G. Opletal, Nanoscale, 11, 19190 (2019).
       </span>
      </span>
     </span>
     ]. Para uma complexidade de descritor fixa, o número de pontos de dados necessários para o treinamento do modelo é uma quantidade chave. Poucos exemplos podem levar ao sobreajuste, isto é, o modelo se ajusta excessivamente bem aos dados, incluindo ruídos indesejáveis. Aumentando o número de pontos de treinamento, tal problema é minimizado ao custo de diminuir ligeiramente a precisão do conjunto de treinamento (curva azul Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F8" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      8
     </a>
     a). Por outro lado, isso leva a uma melhor generalização do modelo, o que pode ser representado pelo aumento da precisão dos dados que não estavam presentes na etapa de treinamento (dados de validação, curva vermelha crescente na Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F8" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      8
     </a>
     a). Para cada modelo, o tamanho do conjunto de dados necessário para convergência será diferente, e não pode ser determinado
     <i>
      a priori
     </i>
     , mas avaliado por meio de curvas de aprendizado (Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F8" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      8
     </a>
     a). Podemos pensar em uma escada de crescente complexidade na representação de materiais e moléculas (Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F8" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      8
     </a>
     b), cada degrau fornecendo informações adicionais sobre os sistemas. No nível mais baixo, a informação depende apenas da fórmula química, ou seja, da composição elementar e estequiometria (escalares). No segundo nível, informações estruturais podem ser incluídas, como posições atômicas, conectividade e propriedades da rede. Nos níveis superiores, informações mais complexas, como estrutura eletrônica ou densidade local, podem ser introduzidas (vetores, tensores e outros). Para cada aplicação, é necessário incluir diferentes informações no descritor, de acordo com a natureza do problema. Portanto, para alguns problemas, features simples podem atingir a acurácia adequada, enquanto em outros problemas a acurácia é limitada. A tarefa da representação é otimizar o descritor, maximizando sua precisão ao mesmo tempo que mantém a maior simplicidade possível. Sempre que o grau de complexidade é aumentado, seja pela expansão do espaço de features ou pelo número de parâmetros a serem aprendidos no modelo de ML (Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F8" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      8
     </a>
     c), a quantidade de dados de treinamento disponíveis deve aumentar de acordo. Finalmente, para qualquer algoritmo de ML, seu sucesso preditivo é determinado por um equilíbrio entre o conjunto de features disponíveis, a qualidade dos descritores, a otimização do algoritmo e, mais importante, a precisão dos dados usados para o treinamento [
     <span class="ref">
      <sup class="xref xrefblue">
       14
      </sup>
      <span class="refCtt closed">
       <span>
        14. G.R. Schleder, A.C.M. Padilha, A.R. Rocha, G.M. Dalpian e A. Fazzio, Journal of Chemical Information and Modeling 60, 452 (2020).
       </span>
      </span>
     </span>
     ]. Um primeiro passo para avaliação do sucesso do modelo de ML é verificar se o conjunto de features incluídas com o algoritmo utilizado é adequado para a descrição da propriedade-alvo de interesse. Isso pode ser verificado em relação às características estatísticas do próprio conjunto de dados, como o valor médio e desvio padrão da propriedade avaliada. Por exemplo, num problema de regressão, é possível comparar o erro médio obtido com um simples modelo de regressão linear usando as features iniciais com relação ao desvio padrão da propriedade. Se o resultado não for significativamente superior, pode ser um indicativo que um modelo linear não descreve bem a propriedade e/ou que as features incluídas não são suficientes para descrever o problema.
    </p>
    <div class="row fig" id="S2_F8">
     <a name="S2_F8">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigS2_F8" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/e2fe4760d416ce62435419993a5b7053f144c4c1.jpg"/>
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <strong>
       Figura 8
      </strong>
      <br/>
      Detalhes dos componentes de Machine Learning: dados
      <b>
       a.
      </b>
      , Descritores
      <b>
       b.
      </b>
      e algoritmos
      <b>
       c.
      </b>
      .
      <b>
       a.
      </b>
      Curva de aprendizado para um determinado modelo de ML, onde a precisão aumenta com o número de dados de treinamento até atingir o platô da capacidade (linha horizontal pontilhada). Por outro lado, a precisão do treinamento diminui como resultado da redução do overfitting inicial.
      <b>
       b.
      </b>
      Representações de ML para moléculas e de materiais. Em cada degrau, mais informações são adicionadas ao descritor, tornando o treinamento e a previsão mais custosos. O desafio é maximizar a acurácia ao mesmo tempo usando o descritor mais simples possível.
      <b>
       c.
      </b>
      Balanço entre de precisão e interpretabilidade dos algoritmos de aprendizado de máquina. Algoritmos complexos como Redes Neurais tendem a ser considerados
      <i>
       caixas pretas
      </i>
      no sentido que entender a importância de cada feature não é uma tarefa simples. A quantidade de dados de treinamento disponíveis deve ser compatível a complexidade do modelo. Adaptado com permissão de [
      <span class="ref">
       <sup class="xref xrefblue">
        14
       </sup>
       <span class="refCtt closed">
        <span>
         14. G.R. Schleder, A.C.M. Padilha, A.R. Rocha, G.M. Dalpian e A. Fazzio, Journal of Chemical Information and Modeling 60, 452 (2020).
        </span>
       </span>
      </span>
      ]. Copyright 2019 American Chemical Society.
      <br/>
     </div>
    </div>
    <h1 class="articleSectionTitle">
     3. Aplicações em Materiais: Descoberta e Design
    </h1>
    <p>
     Como mostrado na seção anterior, o ML é uma ferramenta matemática e estatística, podendo então ser aplicada aos mais diferentes tipos de problemas. Nesse sentido, não apenas os problemas científicos em si podem ser estudados, como também tarefas que usualmente não são estudadas mas que existem dados disponíveis, tal como estimar o tempo que um processo computacional vai levar, permitindo sua otimização [
     <span class="ref">
      <sup class="xref xrefblue">
       47
      </sup>
      <span class="refCtt closed">
       <span>
        47. S. Heinen, M. Schwilk, G.F. von Rudorff e O. Anatole von Lilienfeld, Machine Learning: Science and Technology 1, 025002, 2020.
       </span>
      </span>
     </span>
     ].
    </p>
    <p>
     No contexto específico de materais, o ML pode ser usado para a descoberta, design e otimização de propriedades tanto partindo de dados experimentais [
     <span class="ref">
      <sup class="xref xrefblue">
       48
      </sup>
      <span class="refCtt closed">
       <span>
        48. G.S. Silva, L.P. Oliveira, G.F. Costa, G.F. Giordano, C.Y.N. Nicoliche, A.A. Silva, L.U. Khan, G.H. Silva, A.L. Gobbi, J.V. Silveira et al., Sensors and Actuators B: Chemical 305, 127482 (2020).
       </span>
      </span>
     </span>
     ,
     <span class="ref">
      <sup class="xref xrefblue">
       49
      </sup>
      <span class="refCtt closed">
       <span>
        49. C.Y.N. Nicoliche, R.A.G. Oliveira, G.S. Silva, L.F. Ferreira, I.L. Rodrigues, R.C. Faria, A. Fazzio, E. Carrilho, L.G. Pontes, G.R. Schleder et al., ACS Sensors 5, 1864 (2020).
       </span>
      </span>
     </span>
     ,
     <span class="ref">
      <sup class="xref xrefblue">
       50
      </sup>
      <span class="refCtt closed">
       <span>
        50. G.F. Giordano, L.C.S. Vieira, A.O. Gomes, R.M. Carvalho, L.T. Kubota, A. Fazzio, G.R. Schleder, A.L. Gobbi e R.S. Lima, Fuel 285, 119072 (2021).
       </span>
      </span>
     </span>
     ] como de simulação, e esta pode ser atomística (clássica) ou
     <i>
      ab initio
     </i>
     (quântica). Diferentes estratégias podem ser utilizadas, podendo ser amplamente classificadas [
     <span class="ref">
      <sup class="xref xrefblue">
       13
      </sup>
      <span class="refCtt closed">
       <span>
        13. F. Giustino, M. Bibes, J.H. Lee, F. Trier, R. Valentí, S.M. Winter, Y.W. Son, L. Taillefer, C. Heil, A.I. Figueroa et al., Journal of Physics: Materials, 10.1088/2515-7639/abb74e (2020).
       </span>
       <br/>
       <a href="https://doi.org/10.1088/2515-7639/abb74ehttps://doi.org/10.1088/2515-7639/abb74e" target="_blank">
        https://doi.org/10.1088/2515-7639/abb74e...
       </a>
      </span>
     </span>
     ] no aprendizado de propriedades (Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F9" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      9
     </a>
     a):
     <i>
      i)
     </i>
     pré-equação de Schrödinger, como aprender a densidade eletrônica [
     <span class="ref">
      <sup class="xref xrefblue">
       41
      </sup>
      <span class="refCtt closed">
       <span>
        41. A. Chandrasekaran, D. Kamal, R. Batra, C. Kim, L. Chen e R. Ramprasad, npj Computational Materials 5, 22 (2019).
       </span>
      </span>
     </span>
     ], para ser então usada como input para cálculos DFT ou próprio ML;
     <i>
      ii)
     </i>
     acelerar ou substituir a resolução da equação de Schrödinger, criando assim aproximações para resolver o problema quântico [
     <span class="ref">
      <sup class="xref xrefblue">
       42
      </sup>
      <span class="refCtt closed">
       <span>
        42. K.T. Schütt, M. Gastegger, A. Tkatchenko, K.R. Müller e R.J. Maurer, Nature Communications 10, 5024 (2019).
       </span>
      </span>
     </span>
     ]; e
     <i>
      iii)
     </i>
     pós-equação de Schrödinger, aprendendo diretamente as saídas do problema, tal como as propriedades observáveis dos materiais. Especificamente na área de simulação de materiais, onde é possível gerar uma grande quantidade de dados consistentes para serem usados em tarefas de ML, atualmente existem três grandes áreas de pesquisas de acordo com o grau de complexidade e aproximações utilizadas (Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F9" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      9
     </a>
     b): ML de hamiltonianos de muitos corpos; ML atomístico, gerando potenciais interatômicos e propriedades relacionadas, e ML de materiais a partir de resultados de simulações de DFT.
    </p>
    <div class="row fig" id="S2_F9">
     <a name="S2_F9">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigS2_F9" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/d8a93336c93ced291d7cd2308c1ce42e108af410.jpg"/>
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <strong>
       Figura 9
      </strong>
      <br/>
      (a) Uso do machine learning em diferentes etapas de simulações de materiais:
      <i>
       i)
      </i>
      pré-equação de Schrödinger, por exemplo, aprendizado da densidade eletrônica obtida por DFT [
      <span class="ref">
       <sup class="xref xrefblue">
        41
       </sup>
       <span class="refCtt closed">
        <span>
         41. A. Chandrasekaran, D. Kamal, R. Batra, C. Kim, L. Chen e R. Ramprasad, npj Computational Materials 5, 22 (2019).
        </span>
       </span>
      </span>
      ];
      <i>
       ii)
      </i>
      substituindo [
      <span class="ref">
       <sup class="xref xrefblue">
        42
       </sup>
       <span class="refCtt closed">
        <span>
         42. K.T. Schütt, M. Gastegger, A. Tkatchenko, K.R. Müller e R.J. Maurer, Nature Communications 10, 5024 (2019).
        </span>
       </span>
      </span>
      ] ou acelerando a equação de Schrödinger, tal como otimização bayesiana para relaxação da geometria, cálculos de barreiras energéticas [
      <span class="ref">
       <sup class="xref xrefblue">
        43
       </sup>
       <span class="refCtt closed">
        <span>
         43. J.A. Garrido Torres, P.C. Jennings, M.H. Hansen, J.R. Boes e T. Bligaard, Physical Review Letters 122, 156001 (2019).
        </span>
       </span>
      </span>
      ] ou otimização global [
      <span class="ref">
       <sup class="xref xrefblue">
        44
       </sup>
       <span class="refCtt closed">
        <span>
         44. M.H. Hansen, J.A.G. Torres, P.C. Jennings, Z. Wang, J.R. Boes, O.G. Mamun e T. Bligaard, arXiv:1904.00904 (2019).
        </span>
       </span>
      </span>
      ]; ou iii) pós-equação de Schrödinger, como o aprendizado direto das propriedades dos materiais [
      <span class="ref">
       <sup class="xref xrefblue">
        24
       </sup>
       <span class="refCtt closed">
        <span>
         24. G.R. Schleder, C.M. Acosta e A. Fazzio, ACS Applied Materials &amp; Interfaces 12, 20149 (2020).
        </span>
       </span>
      </span>
      ]. (b) Áreas atuais de ML para ciência de materiais. O ML atomístico permite a exploração estrutural (otimização global) e propriedades, enquanto desconsidera os efeitos quânticos. O ML de hamiltonianos modelo permite a exploração de efeitos quânticos e de muitos corpos, embora é dificil a aplicação a sistemas de materiais reais. O ML de materiais ou DFT preenche a lacuna entre essas áreas [
      <span class="ref">
       <sup class="xref xrefblue">
        13
       </sup>
       <span class="refCtt closed">
        <span>
         13. F. Giustino, M. Bibes, J.H. Lee, F. Trier, R. Valentí, S.M. Winter, Y.W. Son, L. Taillefer, C. Heil, A.I. Figueroa et al., Journal of Physics: Materials, 10.1088/2515-7639/abb74e (2020).
        </span>
        <br/>
        <a href="https://doi.org/10.1088/2515-7639/abb74ehttps://doi.org/10.1088/2515-7639/abb74e" target="_blank">
         https://doi.org/10.1088/2515-7639/abb74e...
        </a>
       </span>
      </span>
      ], potenciais avanços são por exemplo a extração de hamiltonianos realistas a partir de cálculos DFT [
      <span class="ref">
       <sup class="xref xrefblue">
        45
       </sup>
       <span class="refCtt closed">
        <span>
         45. M. Costa, G.R. Schleder, M.B. Nardelli, C. Lewenkopf e A. Fazzio, Nano Letters 19, 8941 (2019).
        </span>
       </span>
      </span>
      ] e gerar funções de onda por ML de sistemas obtidos por simulações atomísticas [
      <span class="ref">
       <sup class="xref xrefblue">
        42
       </sup>
       <span class="refCtt closed">
        <span>
         42. K.T. Schütt, M. Gastegger, A. Tkatchenko, K.R. Müller e R.J. Maurer, Nature Communications 10, 5024 (2019).
        </span>
       </span>
      </span>
      ]. Adaptado de [
      <span class="ref">
       <sup class="xref xrefblue">
        13
       </sup>
       <span class="refCtt closed">
        <span>
         13. F. Giustino, M. Bibes, J.H. Lee, F. Trier, R. Valentí, S.M. Winter, Y.W. Son, L. Taillefer, C. Heil, A.I. Figueroa et al., Journal of Physics: Materials, 10.1088/2515-7639/abb74e (2020).
        </span>
        <br/>
        <a href="https://doi.org/10.1088/2515-7639/abb74ehttps://doi.org/10.1088/2515-7639/abb74e" target="_blank">
         https://doi.org/10.1088/2515-7639/abb74e...
        </a>
       </span>
      </span>
      ]
      <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">
       CC BY 3.0
      </a>
      .
      <br/>
     </div>
    </div>
    <p>
     Vamos apresentar dois exemplos representativos com diferentes níveis de aprendizado:
     <i>
      1)
     </i>
     exploração do espaço de fase de materiais, tanto atômico como configuracional, na descoberta e design de novos materiais bidimensionais (2D);
     <i>
      2)
     </i>
     descoberta de novas estruturas hipotéticas e/ou desconhecidas por otimização global no espaço configuracional, na busca e predição de estruturas de materiais usando potenciais atomísticos aprendidos por ML.
    </p>
    <h2>
     3.1. Explorando o espaço atômico, composicional e configuracional
    </h2>
    <p>
     Um dos grandes desafios da descoberta de materiais é descobrir o maior número possível de novos materiais, explorando simultaneamente os espaços atômico (elementos), composicional (estequiometrias) e configuracional (geometrias/estruturas) [
     <span class="ref">
      <sup class="xref xrefblue">
       13
      </sup>
      <span class="refCtt closed">
       <span>
        13. F. Giustino, M. Bibes, J.H. Lee, F. Trier, R. Valentí, S.M. Winter, Y.W. Son, L. Taillefer, C. Heil, A.I. Figueroa et al., Journal of Physics: Materials, 10.1088/2515-7639/abb74e (2020).
       </span>
       <br/>
       <a href="https://doi.org/10.1088/2515-7639/abb74ehttps://doi.org/10.1088/2515-7639/abb74e" target="_blank">
        https://doi.org/10.1088/2515-7639/abb74e...
       </a>
      </span>
     </span>
     ]. Portanto, o número de graus de liberdade é imenso, e a estratégia utilizada na busca (amostragem) neste espaço é de extrema importância. Quando se pensa em design inverso (Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F2" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      2
     </a>
     ), ou seja, a busca por materiais que apresentem certas funcionalidades desejadas, a exploração desse grande espaço de materiais é fundamental [
     <span class="ref">
      <sup class="xref xrefblue">
       51
      </sup>
      <span class="refCtt closed">
       <span>
        51. C. Mera Acosta, E. Ogoshi, A. Fazzio, G.M. Dalpian e A. Zunger, Matter 3, 145 (2020).
       </span>
      </span>
     </span>
     ]. Portanto, técnicas de alta eficiência, evolutivas e de machine learning são cada vez mais importantes para amostrar com eficiência o espaço dos materiais, resultando em casos selecionados interessantes para investigação aprofundada.
    </p>
    <p>
     Na referência [
     <span class="ref">
      <sup class="xref xrefblue">
       24
      </sup>
      <span class="refCtt closed">
       <span>
        24. G.R. Schleder, C.M. Acosta e A. Fazzio, ACS Applied Materials &amp; Interfaces 12, 20149 (2020).
       </span>
      </span>
     </span>
     ], os autores demonstraram como essa estratégia pode ser utilizada na descoberta de novos materiais 2D visando um posterior processo de filtragem e seleção de materiais para diversas aplicações. Um ponto fundamental que diferencia a aplicação de ML para a descoberta de materiais é que não há a informação
     <i>
      a priori
     </i>
     de qual será a geometria relaxada da estrutura a ser investigada, pois isso implicaria na necessidade de realização de simulações computacionais, justamente que espera-se que sejam substituídas pelo modelo preditivo. Dessa forma, a Fig.
     <a class="open-asset-modal" data-target="#ModalFigS3_F10" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      10
     </a>
     apresenta a estratégia utilizada pelos autores. Tendo como ponto de partida apenas as propriedades atômicas e estequiométricas dos diferentes materiais, é possível prever em diferentes estruturas a estabilidade termodinâmica dos mesmos, que vai indicar a possibilidade de existência desse material de acordo com esse critério. Essa informação é o primeiro critério essencial num processo de filtragem e seleção de materiais. Tendo essa informação, é possível então investigar as diferentes propriedades dos materiais visando aplicações específicas.
    </p>
    <div class="row fig" id="S3_F10">
     <a name="S3_F10">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigS3_F10" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/7314146b1e25d05cd05f7ab4edb09cbe118219bf.jpg"/>
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <strong>
       Figura 10
      </strong>
      <br/>
      Abordagem baseada em dados para descoberta, design e seleção de materiais. Do grande número de combinações possíveis entre elementos, estequiometrias e simetrias, o espaço de materiais é gerado. Usando dados termodinâmicos disponíveis em bancos de dados, com técnicas de aprendizado de máquina, é possível classificar os materiais quanto à sua estabilidade termodinâmica. Se necessário, um modelo de regressão pode prever as energias de formação em relação à fases rivais. Finalmente, os materiais estáveis podem ser selecionados para potenciais aplicações. Adaptado com permissão de [
      <span class="ref">
       <sup class="xref xrefblue">
        24
       </sup>
       <span class="refCtt closed">
        <span>
         24. G.R. Schleder, C.M. Acosta e A. Fazzio, ACS Applied Materials &amp; Interfaces 12, 20149 (2020).
        </span>
       </span>
      </span>
      ]. Copyright 2019 American Chemical Society.
      <br/>
     </div>
    </div>
    <p>
     Vamos descrever brevemente cada um dos quatro componentes do processo de machine learning (Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F4" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      4
     </a>
     ) para esse exemplo.
    </p>
    <ol type="i">
     <li>
      <p>
       Definição do problema: o objetivo do estudo é a predição e compreensão da estabilidade termodinâmica dos diferentes materiais bidimensionais. Portanto, os autores trataram como um problema de apredizado supervisionado, em dois graus de detalhamento. Um modelo de classificação inicial para determinar se um material tem baixa, média ou alta estabilidade, baseado nos critérios de energia de formação (em relação às fases elementais) e em relação às fases rivais (chamada de
       <i>
        convex hull
       </i>
       ). Posteriormente, um segundo modelo de regressão pode obter os valores numéricos dessas quantidades, se desejado.
      </p>
     </li>
     <li>
      <p>
       Dados: Foi utilizado o banco de dados computacional de materiais 2D
       <i>
        C2DB
       </i>
       [
       <span class="ref">
        <sup class="xref xrefblue">
         52
        </sup>
        <span class="refCtt closed">
         <span>
          52. S. Haastrup, M. Strange, M. Pandey, T. Deilmann, P.S. Schmidt, N.F. Hinsche, M.N. Gjerding, D. Torelli, P.M. Larsen, A.C. Riis-Jensen et al., 2D Materials 5, 042002 (2018).
         </span>
        </span>
       </span>
       ], que possui cálculos baseados na teoria do funcional da densidade (DFT) de materiais 2D distribuídos entre diferentes protótipos comuns. Essas diferentes estruturas prototípicas são decoradas de maneira combinatória com diferentes átomos de toda a tabela periódica, resultando em um total de 3712 materiais 2D na versão utilizada. Para cada um dos materiais calculados, são armazenados os dados da geometria de menor energia após relaxação estrutural, energias total, de formação, em relação à outras fases, e diversas propriedades tal como eletrônicas, mecânicas, magnéticas, entre outras. Os autores utilizaram as energia de formação e de
       <i>
        convex hull
       </i>
       como o alvo dos modelos de machine learning, definindo três classes para a classificação: baixa, para materiais com energia de formação positiva (se decompõe em seus elementos); média, para materiais com energia de formação negativa, porém metaestável em relação à outras fases por uma diferença maior que 0.2 eV/átomo (dificilmente podendo ser estabilizada por diferentes estratégias); e alta estabilidade, para materiais com energia de formação negativa, e estáveis ou metaestáveis em relação à outras fases por uma diferença de até 0.2 eV/átomo (valores de energia compatíveis com materiais já sintetizados em substratos, por exemplo) [
       <span class="ref">
        <sup class="xref xrefblue">
         24
        </sup>
        <span class="refCtt closed">
         <span>
          24. G.R. Schleder, C.M. Acosta e A. Fazzio, ACS Applied Materials &amp; Interfaces 12, 20149 (2020).
         </span>
        </span>
       </span>
       ].
      </p>
     </li>
     <li>
      <p>
       Representação: como dito acima, um ponto crucial é evitar a utilização de dados das posições atômicas, que requereriam a execução de simulações computacionais custosas a serem feitas em larga escala. Dessa forma, para distinguir as estruturas, foi usado um rótulo categórico para denotar cada um dos prótótipos estruturais (por exemplo, estruturas idealizadas “tipo” grafeno, MoS
       <sub>
        2
       </sub>
       , também conhecida como fase 2H, e assim sucessivamente). Adicionalmente, os autores utilizaram como features apenas dados de estequiometria e propriedades atômicas dos elementos que constituem os materiais, como número atômico, eletronegatividade, valência, autovalores de Kohn-Sham, polarizabilidade e raios atômicos. Dessa forma, nenhuma informação adicional é necessária para predição de novos materiais. Para tratar materiais com diferentes estequiometrias e número de espécies atômicas, por exemplo, A, AB
       <sub>
        2
       </sub>
       , ABC
       <sub>
        3
       </sub>
       , etc, em uma representação de mesma dimensionalidade (ou seja, número de colunas de seu vetor de features), os autores utilizaram diferentes valores estatísticos das propriedades atômicas, tal como o valor mínimo, máximo, médio e desvio padrão, como sugerido na referência [
       <span class="ref">
        <sup class="xref xrefblue">
         53
        </sup>
        <span class="refCtt closed">
         <span>
          53. L. Ward, A. Agrawal, A. Choudhary e Christopher Wolverton, npj Computational Materials 2, 16028 (2016).
         </span>
        </span>
       </span>
       ].
      </p>
     </li>
     <li>
      <p>
       Algoritmos, validação, e aplicação: Tal como discutido no final de seção
       <span class="ref footnote">
        <sup class="xref">
         2
        </sup>
        <span class="refCtt closed">
         <span class="refCttPadding">
          2. Machine Learning
      Esta seção é majoritariamente adaptada de [6].
      
        2.1. Contexto: quando e por quê?
        A descoberta de novos materiais e/ou sua funcionalização possibilita a criação de aplicações tecnológicas fundamentais para superar muitos dos desafios da sociedade moderna. O impacto do uso de materiais ao longo da história é difícil de quantificar, desde a idade da pedra, passando pela idade do bronze e ferro [8]. Entretanto, o impacto baseado na tecnologia do silício e a revolução dos plásticos são bem palpáveis [9]. Estima-se que o desenvolvimento de materiais permitiu dois terços dos avanços na área da computação e transformou também outras indústrias como armazenamento de energia [10].
        Dada a demanda crescente por novos materiais e o desenvolvimento relativamente lento deles, ao mesmo tempo em que os recursos computacionais e algoritmos enfrentam grandes avanços, é natural perguntar: como a ciência computacional pode melhorar a eficiência da descoberta de materiais? Outras áreas, como a indústria farmacêutica e de biotecnologia, sugerem caminhos possíveis [11, 12]. No entanto, dentro do quarto paradigma da ciência baseada em dados, a comunidade de materiais está aparentemente atrasada em comparação com esses campos. Essa chegada tardia está relacionada a gargalos na capacidade computacional e de geração e armazenamento de dados, mas desde que as primeiras simulações computacionais de materiais foram realizadas, uma quantidade cada vez maior de estudos faz uso deste paradigma [6].
        A teoria do funcional da densidade (density functional theory, DFT) se estabeleceu como a ferramenta padrão para simulação de materiais após seu sucesso na descrição de muitas propriedades físicas importantes, como geometrias nos estados fundamentais, energias totais e relativas e estruturas eletrônicas. Posteriormente, diversos marcos foram alcançados, como a descrição de propriedades estruturais, eletrônicas, ópticas, magnéticas, catalíticas e quânticas, tanto para materiais bulk quanto na nanoescala [13].
        Conforme os desenvolvimentos computacionais aumentaram seu desempenho, o armazenamento de dados tornou-se mais barato e novos algoritmos foram desenvolvidos, uma mudança gradual na forma usual de trabalho de cientistas de materiais, especialmente computacionais, ocorreu na última década. Surgiu uma nova forma de estudar os materiais: antes, a ideia era escolher um ou alguns candidatos e investigá-los minuciosamente para obter um conhecimento mais profundo sobre suas propriedades e possíveis aplicações. Agora é possível simular facilmente um grande número de compostos – técnica conhecida como high-throughput (HT) – e buscar uma propriedade particular em um catálogo de candidatos [14]. Isso marcou o nascimento dessa nova filosofia na área de materiais, dentro do contexto da ciência baseada em dados e descrita na Figura 2.
        
          Figura 2
          
            Diferenças das abordagens tradicional e baseadas em dados para a descoberta e design de moléculas e materiais. Na abordagem tradicional um candidato é avaliado por estratégias de tentativa e erro (esquerda), já na abordagem de dados, é substituída por estratégias de design inverso (direita), capaz de buscar materiais que maximizam as funcionalidades-alvo por meio de high-throughput, aprendizado de máquina ou técnicas evolutivas. Adaptado com permissão de [14]. Copyright 2019 American Chemical Society.
          
          
            
            
          
        
        A simples geração massiva de dados não é garantia de convertê-los em informação e, posteriormente, em conhecimento. Converter o conhecimento em avanços para a sociedade é um desafio ainda maior. Existem lacunas entre a criação, o armazenamento de dados e a capacidade de obter conhecimento e tecnologias utilizáveis a partir deles. A tendência dessa lacuna é aumentar com o tempo [15]. Portanto, dado esse cenário, o uso de abordagens orientadas a dados é fundamental para reduzir essa lacuna e avançar nas pesquisas. Avanços recentes em técnicas experimentais e computacionais resultaram em um aumento exponencial nas quantidades de dados gerados, apresentando também complexidade crescente, levando ao conceito de big-data. Nesse sentido, as técnicas de machine learning visam extrair conhecimento e insights desses dados, identificando suas correlações e padrões [6].
      
      
        2.2. O que é e quando utilizar?
        Explorando a evolução do quarto paradigma da ciência, um paralelo pode ser feito entre o artigo de Eugene Wigner de 1960 “A eficácia irracional da matemática nas ciências naturais” [16] para o caso atual da “A eficácia irracional dos dados” [17]. O que leva à essa eficácia irracional dos dados recentemente? Principalmente a extração de conhecimento dessa grande quantidade de dados acumulados. Isso é feito por meio de técnicas de aprendizado de máquina que podem identificar padrões e relações nos dados, por mais complexas que sejam, mesmo para espaços de dimensionalidade arbitrariamente altas, inacessíveis à compreensão humana [6].
        O machine learning (ML) pode ser definido como uma classe de métodos para análise automatizada de dados, que são capazes de detectar padrões nos dados. Esses padrões extraídos podem ser usados para prever informações desconhecidas ou para auxiliar nos processos de tomada de decisão sob incerteza [18]. A definição tradicional diz que o aprendizado da máquina melhora progressivamente com a experiência (dados) em tarefas determinadas, de acordo com uma métrica de sucesso definida, mas sem ser explicitamente programada para isso [19, 20]. Este campo de pesquisa evoluiu a partir da área mais geral de inteligência artificial (IA), inspirada pelos avanços na década de 1950 em estatística, ciência e tecnologia da computação e neurociência. A Figura 3b mostra a relação entre a área de IA e o ML. Em contraste, uma definição menos rigorosa de IA é qualquer técnica que permite aos computadores imitar a inteligência humana. Isso pode ser alcançado não apenas por ML, mas também por estratégias programadas “menos inteligentes”, como árvores de decisão, regras “se-então”, bases de conhecimento e lógica computacional. Recentemente, um subcampo do ML que está ganhando cada vez mais atenção devido ao seu sucesso em várias áreas é o aprendizado profundo (deep learning) [21]. É um tipo de aprendizagem de representações vagamente inspirado por redes neurais biológicas, tendo um número grande de camadas entre suas entradas (inputs) e saídas (outputs). Um campo intimamente relacionado e componente muito importante do ML é a fonte de dados que permitirá aos algoritmos aprender. Este é o campo da ciência de dados, apresentado na Figura 3a.
        
          Figura 3
          
            (a) Ciência de dados como disciplina integrativa, pela convergência da matemática e estatística, ciência e tecnologia da computação e conhecimento específico de área [22]. (b) Descrição hierárquica e exemplos de técnicas de inteligência artificial e suas subáreas aprendizado de máquina (machine learning) e aprendizado profundo (deep learning). Adaptado de [6] CC BY 3.0 e [22], com permissão da The Royal Society of Chemistry.
          
          
            
            
          
        
        Finalmente, quando o ML deve ou não ser empregado. De maneira geral, podemos usar o ML para 2 tipos de problemas: (i) para tratar problemas que métodos tradicionais não conseguem, de maneira aproximada; e (ii) para otimizar a solução de problemas já tratáveis, porém ou de maneira melhor e mais robusta, ou mais rápida, ou mais econômica, de preferência os três simultaneamente. O pré-requisito crucial é a disponibilidade de dados, que devem ser consistentes, suficientes, validados e representativos do comportamento de interesse a ser descrito. Além disso, é preciso considerar os pontos fortes dos métodos de aprendizado de máquina, que podem lidar com espaços de alta dimensão na busca de padrões nos dados. Os padrões descobertos são então codificados explicitamente, levando à modelos computacionais que podem ser manipulados. Os métodos de ML são mais adequados para problemas em que as abordagens tradicionais apresentam dificuldades. Embora nem sempre seja claro especificar, se um problema pode ser identificado em um dos tipos gerais de problemas de ML descritos na seção 2.3.i, o ML pode ser uma ferramenta útil.
        Em ordem crescente de valor agregado e dificuldade, os problemas gerais enfrentados são: a substituição da coleta de propriedades/dados difíceis, complexos ou custosos; generalizar um padrão presente em um conjunto de dados para uma classe de dados semelhante; obter uma relação entre variáveis correlacionadas, mas com ligações desconhecidas ou indiretas, que está além da intuição ou do conhecimento de área; obtenção de um modelo geral aproximado para uma propriedade desconhecida complexa, ou fenômenos que não possuem teoria ou equações fundamentais [23]. Historicamente, áreas que apresentam questões com essas características foram bem-sucedidas na aplicação dos métodos de ML, tal como nas áreas de automação, processamento de imagens e linguagem, ciências sociais, químicas e biológicas, e recentemente cada vez mais exemplos estão surgindo.
        Com base nessas características, especificamente aplicados à ciência de materiais, vislumbramos os tipos comuns de problemas que fazem uso de estratégias orientadas a dados, e que são exemplificados na Seção 3. O primeiro é a obtenção de modelos para fenômenos que possuem relações ou mecanismos desconhecidos. Uma estratégia relacionada é substituir a descrição de uma propriedade muito complexa ou onerosa de ser obtida (mas que é parcialmente conhecida pelo menos para uma pequena classe de materiais) por um modelo de ML mais simples, tornando seu cálculo menos custoso. Se devidamente validado, este modelo pode então prever a propriedade para exemplos desconhecidos, expandindo o conjunto de dados [24]. No contexto da descoberta e design de materiais, esta estratégia pode ser empregada como uma forma de estender o conjunto de dados antes da seleção e triagem, onde os dados custosos iniciais levam a mais dados por meio do modelo de ML, que podem então ser filtrados para encontrar novos candidatos promissores. Outros problemas usam técnicas de seleção de características para descobrir modelos e descritores aproximados (uma forma de impressão digital do sistema, ver seção 2.3. iii), que auxiliam na compreensão fenomenológica do problema. O mais abundante são os problemas claramente vantajosos em que cálculos dispendiosos computacionalmente podem ser substituídos por um modelo muito mais eficiente, como a substituição de cálculos ab initio por modelos ML, como na obtenção direta de propriedades ou de potenciais atomísticos para simulações de dinâmica molecular, que então prevêem o valor de diferentes propriedades tais como o gap eletrônico, energias livres, de formação, total, de defeitos, condutividades, difusividade, propriedades térmicas, ópticas, magnéticas, entre muitas outras.
      
      
        2.3. Como usar?
        De maneira geral, podemos organizar o problema de machine learning em 4 passos fundamentais como ilustrado na Fig. 4 que são detalhados a seguir: i) definição do problema; ii) dados; iii) representação; e iv) algoritmos, validação, e aplicação.
        
          Figura 4
          
            Os quatro componentes básicos do processo de machine learning. Adaptado de [13] CC BY 3.0.
          
          
            
            
          
        
        
          
            Definição do problema: primeiramente vamos discutir quais os tipos de problemas mais comuns a serem tratados com machine learning. Formalmente, o problema de aprendizagem pode ser descrito [25] por: dado um conjunto de dados conhecido X – onde a notação X indica que é um vetor com uma ou várias variáveis –, prever ou aproximar a função de interesse desconhecida y = f(X), em função desses dados conhecidos. O conjunto X é denominado espaço de features de input (também conhecido como atributos ou características) e um elemento x dele é chamado de vetor de features, ou simplesmente uma entrada. Com a função aproximada aprendiday^=f^⁢(X), o modelo pode então prever a saída para exemplos desconhecidos fora dos dados usados para o treinamento, e sua capacidade de fazer isso é chamada de generalização do modelo. Existem algumas categorias de problemas de ML de acordo com os tipos de entradas e saídas tratadas, sendo as duas principais as aprendizagens supervisionada e não supervisionada.
            Na aprendizagem não supervisionada, também conhecida como descritiva, o objetivo é encontrar estruturas nos dados brutos xi ∈ X fornecidos sem rótulos, ou seja, não se usa ou não existem dados de saída y conhecidos. Se f(X) é finito, o aprendizado é denominado agrupamento (clustering), que agrupa dados em um número (conhecido ou desconhecido) de grupos pela similaridade em suas características. Por outro lado, se f(X) está em uma distribuição [0,∞), a aprendizagem é chamada de estimativa de densidade, que aprende a distribuição marginal das características. Outro tipo importante de aprendizagem não supervisionada é a redução de dimensionalidade, que comprime o número de variáveis de entrada para representar os dados, útil quando f(X) tem alta dimensionalidade e, portanto, uma estrutura de dados complexa para ser visualizada e usada na detecção de padrões.
            Por outro lado, na aprendizagem supervisionada ou preditiva, o objetivo é aprender a função que leva as entradas às saídas alvo (target), tendo um conjunto de dados rotulados (xi,yi) ∈ (X,f(X)), conhecido como conjunto de treinamento (ao contrário do conjunto de teste desconhecido), com i = N número de exemplos. Se a saída y_i é um conjunto finito categórico ou nominal (por exemplo, se um material é um metal ou isolante), o problema é chamado de classificação, que prevê o rótulo de classe para amostras desconhecidas. Caso contrário, se as saídas são escalares contínuos de valor real yi ∈ ℝ, o problema é então chamado de regressão, que irá prever os valores de saída para os exemplos desconhecidos. Veremos os algoritmos relacionados na seção iv) adiante.
            Outros tipos de problemas de ML são a aprendizagem semi-supervisionada, em que um grande número de dados não rotulados é combinado com um pequeno número de dados rotulados; a aprendizagem multi-tarefa; a transferência de aprendizagem, onde informações de problemas relacionados são exploradas para melhorar a tarefa de aprendizagem (geralmente uma com poucos dados disponíveis [26]); e o chamado aprendizado por reforço, no qual nenhuma entrada/saída é fornecida, mas sim feedbacks sobre as decisões como um meio de maximizar um sinal de recompensa, levando ao aprendizado de ações desejadas em determinados ambientes.
          
          
            Dados (inputs): a disponibilidade de dados é componente fundamental para qualquer processo de machine learning. Os resultados a serem obtidos no processo serão tão bons quanto a quantidade e qualidade dos dados que serão utilizados. Qualidade nesse contexto se refere que os dados sejam representativos do problema a ser estudado, consistentes, e que possuam informação relacionada à tarefa ser realizada [14]. Portanto, o processo para chegar num conjunto de dados de qualidade leva algumas etapas. Inicialmente, a etapa de coleta e/ou curadoria dos dados para geração e seleção de um subconjunto relevante e útil de dados disponíveis para a resolução dos problemas. Posteriormente, o pré-processamento de dados, que busca uma formatação adequada dos dados, limpeza de dados corrompidos e ausentes, transformação dos dados conforme necessário por operações como normalização, discretização, cálculo da média, suavizar ou diferenciar, conversão uniforme para inteiros, double ou strings e amostragem adequada para otimizar a representatividade do conjunto [6]. Tendo os dados brutos tecnicamente corretos, é possível a próxima etapa de escolha da representação adequada ao problema.
          
          
            Representação: também chamada de impressão digital (fingerprint) ou descritor [27], a representação determinará a capacidade e o desempenho do processo de machine learning. Somente se as variáveis necessárias forem representadas que o algoritmo será capaz de aprender a relação desejada. Essa etapa mapeia em um vetor as diferentes variáveis de entrada (features de input) disponíveis que descrevem e identificam as amostras (no presente contexto, os materiais). Alguns requisitos desejáveis universais são propostos [28, 6, 14], tais como: a representação deve ser a) completa (suficiente para diferenciar os exemplos), b) única (dois exemplos terão a mesma representação apenas se forem de fato iguais), c) discriminativos (sistemas similares ou diferentes serão caracterizados por representações similares ou diferentes), e d) eficiente e simples de ser obtido (o cálculo da representação em si deve ser rápido). Esses requisitos apresentados servem para garantir que os modelos sejam eficientes usando apenas informações essenciais. Para qualquer novo problema de machine learning, o processo de engenharia de features, que engloba a seleção, combinação, e transformação destas, é responsável pela maior parte dos esforços e do tempo usado no projeto [29].
          
          
            Algoritmos, validação, e aplicação: A tarefa de construir e utilizar algoritmos é um estudo caso a caso. Nenhum algoritmo de ML é universalmente superior [30, 31]. Em particular, a escolha do algoritmo de aprendizagem é uma etapa fundamental na construção de um pipeline de ML, e muitas opções estão disponíveis, cada uma adequada para um determinado problema e/ou conjunto de dados. Esse conjunto de dados pode ser de dois tipos: rotulado ou não rotulado. Como vimos, no primeiro caso, a tarefa é encontrar o mapeamento entre os pontos dos dados e os rótulos correspondentes {x(i)}→{y(i)} por meio de um algoritmo de aprendizagem supervisionada. Por outro lado, se não há rótulos no conjunto de dados, a tarefa é encontrar uma estrutura dentro dos dados, utilizando o aprendizado não supervisionado. A seguir apresentamos de maneira breve um exemplo simples e os principais algoritmos para cada um dos tipos de problemas de ML que apresentamos na seção 2.3. i. Esses tipos de problemas e os algoritmos relacionados são resumidos na Figura 5. Figura 5Algoritmos de machine learning e diagrama de uso, divididos nos principais tipos de problemas: aprendizado não supervisionado (redução de dimensionalidade e clustering) e supervisionado (classificação e regressão). Adaptado de [6] CC BY 3.0. 
            Redução de dimensionalidade. Devido à grande abundância de dados, pode-se facilmente obter vetores de features de tamanho incrivelmente grandes, levando ao que é conhecido como “maldição da dimensionalidade”. Por exemplo, imagine um algoritmo de ML que recebe como entrada imagens de n×n pixels em escala de cinza, cada um representado como um valor numérico. Nesse caso, a matriz que contém esses números é achatada em um vetor de comprimento n2, o vetor de características, descrevendo esse ponto (amostra) em um espaço de alta dimensionalidade. Devido à dependência exponencial, um número grande de dimensões é facilmente atingido para imagens de tamanho médio. A memória ou o poder de processamento computacional tornam-se fatores limitantes neste caso. Um ponto chave é que dentro da nuvem de dados de alta dimensão abrangida pelo conjunto de dados, pode-se encontrar uma estrutura de dimensão inferior. O conjunto de pontos pode ser projetado em um hiperplano ou variedade, reduzindo sua dimensionalidade enquanto preserva a maior parte das informações contidas na nuvem de dados original. Uma série de procedimentos com esse objetivo, como análise de componentes principais (PCA) são rotineiramente empregados em algoritmos de ML [32]. Em poucas palavras, a PCA é uma rotação de cada eixo do sistema de coordenadas do espaço onde residem os pontos de dados, levando à maximização da variância ao longo desses eixos. A maneira de descobrir para onde o novo eixo deve apontar é obtendo o autovetor correspondente ao maior autovalor de XTX, onde X é a matriz de dados. Uma vez que o maior autovetor de variância, também conhecido como o componente principal, é encontrado, os pontos são projetados nele, resultando em uma compressão dos dados. Usualmente escolhe-se um número de componentes principais que irão descrever a maior parte da variância do conjunto de dados. A generalização dos algoritmos de redução de dimensionalidade para estruturas não-lineares é chamada de manifold learning, dos quais exemplos conhecidos são o multi-dimensional scaling (MDS), isometric mapping (Isomap) e t-distributed stochastic neighbor embedding (t-SNE).
            Clustering. O clustering hierárquico é um método empregado na aprendizagem não supervisionada, podendo ser de dois tipos, aglomerativo ou divisivo. O primeiro pode ser descrito por um algoritmo simples: começando com n classes, ou clusters, cada um deles contendo um único exemplo x(i) do conjunto de treinamento, e então é medida a dissimilaridade d(A,B) entre pares de clusters rotulados A e B. Os dois clusters com a menor dissimilaridade, ou seja, mais semelhantes, são mesclados em um novo cluster. O processo é então repetido recursivamente até que apenas um cluster, contendo todos os elementos do conjunto de treinamento, permaneça. O processo pode ser melhor visualizado traçando um dendrograma, tal como mostrado na Figura 6. Para agrupar os dados em k clusters, 1 &lt; k &lt; n, o usuário deve cortar a estrutura hierárquica obtida em alguma etapa intermediária do agrupamento. Há certa liberdade na escolha da medida de dissimilaridade d(A,B), e três medidas principais são populares. Primeiro, a ligação única leva em consideração o par mais próximo de membros do cluster, Figura 6(a) Dendrograma demonstrando o clustering hierárquico. O código de cores é um guia para visualizar os clusters, representados pelas linhas verticais. As linhas horizontais indicam a fusão de dois clusters. O número de cruzamentos entre a linha horizontal e as linhas dos clusters corresponde ao número de clusters em uma determinada altura selecionada, no exemplo da linha tracejada cinza, são cinco clusters. (b) Exemplo da função sigmóide e a classificação de exemplos negativos em vermelho e positivos em azul na regressão logística. A seta cinza aponta para os dados classificados incorretamente no conjunto de dados. Adaptado de [6] CC BY 3.0. (c) Exemplo de uma rede neural com N camadas ocultas e um único neurônio na camada de output. (1)dS⁢L⁢(A,B)=mini∈A,j∈B⁡di⁢j 
            onde dij é uma medida de dissimilaridade de membros do par. Em segundo lugar, a ligação completa considera o par mais distante ou mais diferente de cada cluster, (2)dC⁢L⁢(A,B)=maxi∈A,j∈B⁡di⁢j 
            e, finalmente, o agrupamento da média do grupo considera a dissimilaridade média, representando um balanço entre as duas medidas anteriores, (3)dG⁢A⁢(A,B)=1|A|⁢|B|⁢∑i∈A∑j∈Bdi⁢j. 
            A forma particular de dij também pode ser escolhida, geralmente sendo considerada a distância euclidiana para dados numéricos. A menos que os dados disponíveis sejam altamente agrupados, a escolha da medida de dissimilaridade pode resultar em dendrogramas distintos e, portanto, clusters distintos. Como o nome sugere, o clustering divisivo executa a operação oposta, começando com um único cluster contendo todos os exemplos do conjunto de dados e o divide recursivamente de forma que a dissimilaridade do cluster seja maximizada. O processo termina quando cada cluster possuir uma entrada. Da mesma forma, requer que o usuário determine a linha de corte para agrupar os dados. Outros algoritmos de clustering bastante utilizados são o K-médias (K-means) e o DBSCAN.
            Supervisionado: Regressão e Classificação. No caso dos algoritmos supervisionados, a ideia geral é aprender a função que aproxime da melhor forma possível a distribuição dos dados disponíveis para treinamento do modelo. No caso da regressão, o modelo retorna um valor contínuo, e no caso da classificação, um valor (rótulo) discreto. Seja qual for o algoritmo, o objetivo é minimizar o erro entre o valor predito pelo modelo aproximado e os valores de referência usados para o treinamento. Isso é feito ao se definir uma função de custo que será minimizada. Portanto, a infinidade de diferentes modelos possíveis pode ser resumida na escolha desses 2 componentes: qual a forma da função usada para a aproximação, e qual a função de custo para a minimização. Diferentes algoritmos empregam diferentes estratégias na solução desse objetivo. Vamos apresentar os exemplos mais simples pra cada uma dessas tarefas, como forma de exemplificar essa ideia geral.
            No caso da regressão, o algoritmo mais simples e usado é conhecido como regressão Linear. Sua suposição básica é que os dados são normalmente distribuídos em relação a uma expressão ajustada, (4)y^(i)=θT⁢x(i) 
            onde o sobrescrito T denota o vetor transposto, y^(i) é o valor previsto e θ é o vetor de parâmetros (coeficientes) a serem aprendidos. A fim de obter os parâmetros θ, insere-se uma função de custo no modelo, que é dada por uma soma dos termos de erro usando mínimos quadrados, (5)J⁢(θ)=∑i=1nL⁢[y^(i)⁢(x(i),θ),y(i)]=12⁢∑i=1n(θT⁢x(i)-y(i))2+λ⁢∥θ∥p. 
            Ao minimizar a função acima com relação a seus parâmetros, encontra-se o melhor conjunto de θ para o problema em questão, levando assim a um modelo de ML treinado. O último termo inserido na função de custo é opcional, conhecido como parâmetro de regularização λ, sendo diferentes extensões da regressão linear, tal como a regressão ridge ou LASSO. O valor de p denota a métrica, p = 0 é simplesmente o número de coeficientes diferentes de zero (normalmente não considerados uma métrica formalmente) em θ enquanto p = 1 é referido como a métrica de Manhattan ou táxi, e p = 2 é a métrica euclidiana usual. Quando se usa p = 1, o modelo de regressão é LASSO (Least Absolute Shrinkage and Selection Operator), onde devido à restrição imposta ao problema de minimização, nem todas as features presentes nos descritores são consideradas para o ajuste. Por outro lado, a regressão ridge corresponde a p = 2, e o resultado neste caso é apenas a redução dos valores absolutos das features, ou seja, features com valores muito grandes são penalizados, somando à função de custo. Tanto no LASSO quanto na regressão ridge, o parâmetro λ controla a complexidade do modelo, diminuindo e/ou selecionando as features. Assim, em ambos os casos, é recomendável começar com um modelo mais complexo e usar λ para diminuir sua complexidade. O parâmetro λ, entretanto, não pode ser aprendido da mesma maneira que θ, sendo referido como um hiperparâmetro que deve ser ajustado por, por exemplo, uma busca em grid para encontrar aquele que maximiza o poder de previsão sem introduzir muito viés (bias).
            A classificação é usada para prever rótulos discretos. Um algoritmo de classificação muito popular é a regressão logística [20], que pode ser interpretado como um mapeamento das previsões feitas por regressão linear no intervalo [0, 1]. Vamos supor que a tarefa de classificação em questão é decidir se um dado ponto x(i) pertence a uma classe particular (y(i) = 1) ou não (y(i) = 0). A previsão binária desejada pode ser obtida a partir de (6)y^=σ⁢(θT⁢x)=11+e-θT⁢x 
            onde θ é novamente um vetor de parâmetros e σ é referido como a função logística ou sigmóide. Como exemplo, a função sigmóide junto com uma previsão de um conjunto de dados fictício é apresentada na Figura 6. Normalmente considera-se que a amostra x(i) pertence à classe rotulada por y(i) se y^(i)≥0.5 , mesmo que o rótulo previsto possa ser interpretado como uma probabilidade y^=P(y=1|x,θ). No caso da classificação, a função de custo é obtida a partir da log-probabilidade negativa. Assim, a obtenção dos melhores parâmetros θ requer a minimização dessa quantidade, dada por (7)J(θ)=-1n∑i=1n[y(i)log(y^(i))+(1-y(i))log(1-y^(i))] 
            onde y(i) e y^(i)=σ⁢(θT⁢x(i)) são os rótulos binários verdadeiros (de referência) e previstos. Um parâmetro de regularização λ pode ser inserido na equação (7) com a mesma intenção de selecionar as features, como visto na regressão linear anteriormente. Observe que a regressão logística também pode ser usada quando os dados apresentam várias classes. Neste caso, deve-se empregar a estratégia um-contra-todos, que consiste em treinar n modelos de regressão logística, um para cada classe, e prever os rótulos usando o classificador que apresentar maior probabilidade.
            Entre os métodos supervisionados, algoritmos populares de classificação são classificadores usando máquinas de vetores de suporte (support vector machines, SVM) [33] com uma variedade de funções kernel (linear, polinomial, Gaussiana, entre outras); o algoritmo não paramétrico k-nearest neighbors (k-NN); algoritmos probabilísticos como Naive Bayes; árvores de decisão [34, 35] e métodos relacionados de ensemble, como Random Forests [20] e gradient boosting. No caso de tarefas de regressão, regressão linear, Ridge e LASSO, bem como árvores de decisão e regressores de Random Forests são algoritmos simples e populares. Uma revisão recente sobre métodos de ML para ciência de materiais apresenta uma explicação abrangente do funcionamento interno de muitos desses algoritmos [6], e um vasto material também pode ser encontrado na literatura [18, 20, 21].
            Vale destacar separadamente, as redes neurais (neural networks, NN), particularmente profundas (deep learning) [21], que estão se tornando muito populares devido aos seus avanços recentes tal como para reconhecimento de imagens, bem como em tarefas de processamento de linguagem natural. Elas correspondem a uma classe de algoritmos que foram, pelo menos em seu início, inspiradas pela estrutura do cérebro. Uma NN pode ser descrita como um grafo direcionado ponderado, ou seja, uma estrutura composta por camadas contendo unidades de processamento chamadas neurônios, que por sua vez são conectadas a outras camadas, conforme ilustrado na Figura 6. Muitos tipos de NNs são usados para uma variedade de tarefas como regressão e classificação, e algumas das arquiteturas mais populares para tais redes são NNs feed-forward, recorrentes e convolucionais. As principais diferenças entre essas arquiteturas são basicamente os padrões de conexão e as operações que seus neurônios executam nos dados. Normalmente em uma NN, uma camada de entrada recebe os vetores de features do conjunto de treinamento, e uma série de operações não lineares é realizada enquanto os dados propagam através das subsequentes chamadas camadas ocultas. Finalmente, o resultado do processamento é coletado na camada de saída, que pode ser uma classificação binária ou multinária (probabilística), ou mesmo um mapeamento contínuo como em um modelo de regressão linear. Um ponto muito interessante nesse processo, é que a própria rede aprende representações otimizadas do conjunto de dados, normalmente ao custo de cojuntos de dados maiores, visto o número exponencialmente grande de coeficientes a serem determinados. Em uma NN, a entrada zi(k) do i-ésimo neurônio na k-ésima camada é uma função das saídas yj(k-1) da camada anterior
            
              
                (8)
                
                  
                    
                      z
                      i
                      
                        (
                        k
                        )
                      
                    
                    =
                    
                      
                        ω
                        
                          i
                          ⁢
                          0
                        
                        
                          (
                          k
                          )
                        
                      
                      +
                      
                        
                          ∑
                          j
                        
                        
                          
                            y
                            j
                            
                              (
                              
                                k
                                -
                                1
                              
                              )
                            
                          
                          ⁢
                          
                            ω
                            
                              i
                              ⁢
                              j
                            
                            
                              (
                              k
                              )
                            
                          
                        
                      
                    
                  
                
              
            
            onde ωi⁢j(k) é o elemento da matriz que conecta as camadas adjacentes. O elemento wi⁢0(k) é conhecido como viés (bias), porque não faz parte da combinação linear de entradas. A entrada é então transformada por meio de uma função não-linear ou de ativação, tal como a tangente hiperbólica,
            
              
                (9)
                
                  
                    
                      
                        y
                        i
                        
                          (
                          k
                          )
                        
                      
                      =
                      
                        
                          
                            e
                            
                              z
                              i
                              
                                (
                                k
                                )
                              
                            
                          
                          -
                          
                            e
                            
                              -
                              
                                z
                                i
                                
                                  (
                                  k
                                  )
                                
                              
                            
                          
                        
                        
                          
                            e
                            
                              z
                              i
                              
                                (
                                k
                                )
                              
                            
                          
                          +
                          
                            e
                            
                              -
                              
                                z
                                i
                                
                                  (
                                  k
                                  )
                                
                              
                            
                          
                        
                      
                    
                    ,
                  
                
              
            
            que resulta no mapeamento do vetor de entrada da camada anterior em um novo espaço vetorial, permitindo que a rede forneça predições para problemas altamente complexos.
            Por fim, vamos discutir como avaliar a qualidade dos modelos, métricas de desempenho e precauções a serem tomadas para gerar modelos coerentes. Um algoritmo de aprendizado supervisionado de ML é considerado treinado quando seus parâmetros ótimos dados as amostras de treinamento são encontrados, minimizando a função de custo. No entanto, os hiperparâmetros geralmente não podem ser aprendidos dessa maneira, e o estudo do desempenho do modelo em um conjunto separado, denominado conjunto de validação, em função de tais parâmetros é necessário. Este processo é conhecido como validação. A maneira usual de fazer isso é separar o conjunto de dados em 3 conjuntos separados: os conjuntos de treinamento, validação e teste. Espera-se que seus elementos sejam da mesma natureza, ou seja, venham da mesma distribuição estatística. O processo de aprendizagem é então realizado várias vezes para otimizar o modelo. Finalmente, usando o conjunto de teste, pode-se confrontar as previsões com os rótulos de referência e medir o quão bem o modelo está desempenhando. Particularmente em métodos supervisionados, dois problemas principais podem surgir então: (i) se os vetores de descritores apresentam um número insuficiente de features, ou seja, não é geral o suficiente para capturar as tendências nos dados e o modelo de regressão é considerado enviesado, e (ii) se o descritor apresenta muitas informações, o que faz com que o modelo de regressão se ajuste aos dados de treinamento excessivamente bem, mas sofre para generalizar para novos dados, então é dito que o modelo sofre sobre-ajuste (overfitting) ou variância. Esses são dois extremos da complexidade dos modelos, diretamente relacionado ao número de parâmetros, onde o equilíbrio ideal é representado na Figura 7. Normalmente se utiliza o parâmetro de regularização λ a fim de diminuir de forma sistemática a complexidade do modelo e encontrar o ponto ótimo. Figura 7Balanço entre viés (bias) × variância. A complexidade ideal do modelo é avaliada em relação ao erro das predições avaliadas no conjunto de teste. Adaptado de [6] CC BY 3.0. 
            Quando uma quantidade limitada de dados está disponível para treinamento, remover uma fração desse conjunto para criar o conjunto de teste pode impactar negativamente o processo de treinamento, e formas alternativas devem ser empregadas. Um dos métodos mais populares neste cenário é a validação cruzada, que consiste em particionar o conjunto de treinamento em k subconjuntos, treinar o modelo usando k-1 subconjuntos e validar o modelo treinado usando o conjunto que não foi usado para o treinamento. Este processo é executado k vezes e a média de cada etapa de validação é usada para calcular a média do desempenho,
            
              
                (10)
                
                  
                    
                      E
                      
                        c
                        ⁢
                        v
                      
                      K
                    
                    =
                    
                      
                        1
                        K
                      
                      ⁢
                      
                        
                          ∑
                          
                            k
                            =
                            1
                          
                          K
                        
                        
                          
                            ∑
                            
                              i
                              =
                              1
                            
                            
                              n
                              k
                            
                          
                          
                            L
                            ⁢
                            
                              (
                              
                                
                                  y
                                  ^
                                
                                k
                                
                                  (
                                  i
                                  )
                                
                              
                              ,
                              
                                y
                                
                                  (
                                  i
                                  )
                                
                              
                              )
                            
                          
                        
                      
                    
                  
                
              
            
            onde L é a função de perda e y^k(i) é o rótulo previsto do i-ésimo exemplo de treinamento do modelo treinado usando o subconjunto dos dados de treinamento, excluindo o subconjunto k, que tem o tamanho n_k.
            Existem muitas maneiras de avaliar o desempenho, sendo de suma importância particularmente para modelos supervisionados. Em tarefas de classificação binária ou multinária, é muito comum o uso de matrizes de confusão, onde o número de elementos preditos corretamente são apresentados nas entradas diagonais enquanto os elementos que foram preditos incorretamente são contados nas entradas fora da diagonal. Pode-se pensar no índice vertical como os rótulos reais e no índice horizontal como as previsões, e falsos (F) positivos (P) ou negativos (N) são previsões positivas para casos negativos e vice-versa, respectivamente. A curva de característica de operação do receptor (ROC curve) também é usada rotineiramente, sendo o gráfico da taxa de verdadeiros (V) positivos T⁢V⁢P=V⁢PV⁢P+F⁢N versus a taxa de falsos positivos T⁢F⁢P=F⁢PF⁢P+V⁢N variando o limiar inter-classes. Um exemplo é mostrado na Fig. 11a. Figura 11Resultados do modelo de ML e aplicação [24]. (a) Curva ROC e área sob a curva como métrica do modelo de classificação para cada classe: baixa (vermelho), média (laranja) e alta estabilidade (verde). (b) Importância das 20 features mais importantes do modelo de classificação. (c) Gráfico de paridade das energias de formação para a classe de alta estabilidade comparando os valores calculados por DFT com o modelo de regressão obtido via ML. O erro RMSE da validação cruzada é 0.205 eV/átomo. (d) Uso do modelo ML como critério de seleção de materiais para fotoeletrocatálise de água. Alinhamento de banda dos candidatos selecionados em relação ao vácuo. Os potenciais para as reações H+/H2 e O2/H2O estão destacados entre as linhas tracejadas. O candidato Sn2SeTe foi previsto pelo modelo de classificação. Adaptado com permissão de [24]. Copyright 2019 American Chemical Society. 
            No caso de tarefas de regressão, existem várias métricas da performance do ajuste. O erro médio absoluto M⁢A⁢E=1n⁢∑in|yi-y^i|, mede desvios na mesma unidade da variável e também não é sensível a outliers. Existe a versão normalizada expressa em porcentagem M⁢A⁢P⁢E=100%n⁢∑inyi-y^iyi. O erro quadrático médio M⁢S⁢E=1n⁢∑in(yi-y^i)2 combina medições de bias e variância da previsão. Do ponto de vista frequentista, a estimativa θ^m de um parâmetro de distribuição θ está intimamente relacionada com o MSE, através da fórmula M⁢S⁢E=𝔼⁢[(θ^m-θ)2]=B⁢i⁢a⁢s⁢(θ^m)2+V⁢a⁢r⁢(θ^m). O MSE, ou seja, a função de custo dada na equação (5) (quando se introduz ou não um parâmetro de regularização λ), idealmente seria zero para pontos de dados exatamente em cima da função obtida por meio da regressão. O MSE costuma ser utilizado tomando sua raiz (RMSE), que recupera a unidade original, facilitando a interpretação da precisão do modelo. Finalmente, também é utilizado o coeficiente de determinação estatístico R2, definido como R2=1-S⁢Sr⁢e⁢sS⁢St⁢o⁢t, onde a soma total dos quadrados é S⁢St⁢o⁢t=∑i(yi-y¯)2 e a soma residual dos quadrados é S⁢Sr⁢e⁢s=∑i(yi-y^i)2. O R2 é usualmente visualizado em gráficos de paridade, onde compara-se os valores preditos pelo modelo de ML com os valores de referência. Um exemplo é mostrado na Fig. 11c.
          
        
        Na prática, existem diversos softwares e programas computacionais que implementam os diferentes algoritmos de machine learning. Um dos mais acessíveis, completos e utilizados é o scikit-learn [36], implementado como uma biblioteca escrita em python. Uma implementação também acessível e com interface gráfica é o software Weka [37]. Duas das implementações mais utilizadas de deep learning são os códigos tensorflow [38] e pytorch [39]. Um tutorial prático introdutório de uso do machine learning com aplicações para materiais pode ser encontrado em [40].
        Finalmente, vale destacar que existe um balanço entre os diferentes componentes para cada determinado problema de ML. O tamanho do conjunto de dados, a representação usada e o algoritmo a ser empregado estão intimamente relacionados à construção de cada modelo e devem ser balanceados com cuidado, conforme discutido na Fig. 8. Em relação aos dados, na física, química e ciência de materiais, a natureza dos conjuntos de dados envolvidos é muito diferente daqueles com os quais o aprendizado de máquina foi historicamente projetado para trabalhar, que são, tamanhos grandes, espaços com poucas features de dimensionalidade fixa e baixa variância; sendo então caracterizado como “little-data” [46]. Para uma complexidade de descritor fixa, o número de pontos de dados necessários para o treinamento do modelo é uma quantidade chave. Poucos exemplos podem levar ao sobreajuste, isto é, o modelo se ajusta excessivamente bem aos dados, incluindo ruídos indesejáveis. Aumentando o número de pontos de treinamento, tal problema é minimizado ao custo de diminuir ligeiramente a precisão do conjunto de treinamento (curva azul Fig. 8a). Por outro lado, isso leva a uma melhor generalização do modelo, o que pode ser representado pelo aumento da precisão dos dados que não estavam presentes na etapa de treinamento (dados de validação, curva vermelha crescente na Fig. 8a). Para cada modelo, o tamanho do conjunto de dados necessário para convergência será diferente, e não pode ser determinadoa priori , mas avaliado por meio de curvas de aprendizado (Fig. 8a). Podemos pensar em uma escada de crescente complexidade na representação de materiais e moléculas (Fig. 8b), cada degrau fornecendo informações adicionais sobre os sistemas. No nível mais baixo, a informação depende apenas da fórmula química, ou seja, da composição elementar e estequiometria (escalares). No segundo nível, informações estruturais podem ser incluídas, como posições atômicas, conectividade e propriedades da rede. Nos níveis superiores, informações mais complexas, como estrutura eletrônica ou densidade local, podem ser introduzidas (vetores, tensores e outros). Para cada aplicação, é necessário incluir diferentes informações no descritor, de acordo com a natureza do problema. Portanto, para alguns problemas, features simples podem atingir a acurácia adequada, enquanto em outros problemas a acurácia é limitada. A tarefa da representação é otimizar o descritor, maximizando sua precisão ao mesmo tempo que mantém a maior simplicidade possível. Sempre que o grau de complexidade é aumentado, seja pela expansão do espaço de features ou pelo número de parâmetros a serem aprendidos no modelo de ML (Fig. 8c), a quantidade de dados de treinamento disponíveis deve aumentar de acordo. Finalmente, para qualquer algoritmo de ML, seu sucesso preditivo é determinado por um equilíbrio entre o conjunto de features disponíveis, a qualidade dos descritores, a otimização do algoritmo e, mais importante, a precisão dos dados usados para o treinamento [14]. Um primeiro passo para avaliação do sucesso do modelo de ML é verificar se o conjunto de features incluídas com o algoritmo utilizado é adequado para a descrição da propriedade-alvo de interesse. Isso pode ser verificado em relação às características estatísticas do próprio conjunto de dados, como o valor médio e desvio padrão da propriedade avaliada. Por exemplo, num problema de regressão, é possível comparar o erro médio obtido com um simples modelo de regressão linear usando as features iniciais com relação ao desvio padrão da propriedade. Se o resultado não for significativamente superior, pode ser um indicativo que um modelo linear não descreve bem a propriedade e/ou que as features incluídas não são suficientes para descrever o problema.
        
          Figura 8
          
            Detalhes dos componentes de Machine Learning: dados a., Descritores b. e algoritmos c.. a. Curva de aprendizado para um determinado modelo de ML, onde a precisão aumenta com o número de dados de treinamento até atingir o platô da capacidade (linha horizontal pontilhada). Por outro lado, a precisão do treinamento diminui como resultado da redução do overfitting inicial. b. Representações de ML para moléculas e de materiais. Em cada degrau, mais informações são adicionadas ao descritor, tornando o treinamento e a previsão mais custosos. O desafio é maximizar a acurácia ao mesmo tempo usando o descritor mais simples possível. c. Balanço entre de precisão e interpretabilidade dos algoritmos de aprendizado de máquina. Algoritmos complexos como Redes Neurais tendem a ser considerados caixas pretas no sentido que entender a importância de cada feature não é uma tarefa simples. A quantidade de dados de treinamento disponíveis deve ser compatível a complexidade do modelo. Adaptado com permissão de [14]. Copyright 2019 American Chemical Society.
         </span>
        </span>
       </span>
       , a combinação de features incluídas com o algoritmo escolhido deve ser capaz de descrever satisfatoriamente a propriedade-alvo de interesse. Para esse exemplo, foi avaliado que o conjunto inicial de features não garante bons resultados independentemente da classe de algoritmo utilizado (linear ou não, paramétrico ou não). Portanto, um primeiro passo foi utilizar o algoritmo SISSO [
       <span class="ref">
        <sup class="xref xrefblue">
         54
        </sup>
        <span class="refCtt closed">
         <span>
          54. R. Ouyang, S. Curtarolo, E. Ahmetcik, M. Scheffler e L.M. Ghiringhelli, Physical Review Materials 2, 083802 (2018).
         </span>
        </span>
       </span>
       ] (regressão linear com regularização de norma ℓ
       <sub>
        0
       </sub>
       ) para fazer um processo de engenharia de features de forma automatizada. Assumindo que a propriedade de interesse pode ser descrita por uma combinação não-linear das features iniciais, o algoritmo realiza a geração de novas features por meio de um processo combinatório das features inicias, ao realizar operações selecionadas entre elas, tal como soma/subtração, multiplicação/divisão, exponenciais/logaritmo, potências, etc. Associado com um algoritmo baseado em um ensemble de árvores de decisão,
       <i>
        gradient boosting
       </i>
       , os autores atingiram boa performance na classificação (em torno de 90%) tanto na validação do modelo realizada com validação cruzada, como no teste para dados inéditos, visualizada com a métrica da área sobre a curva ROC, mostrada na Fig.
       <a class="open-asset-modal" data-target="#ModalFigS3_F11" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        11
       </a>
       a. Uma informação interessante é a importância de cada feature para a capacidade preditiva do modelo (Fig.
       <a class="open-asset-modal" data-target="#ModalFigS3_F11" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        11
       </a>
       b), podendo ser usada para compreensão do problema. Adicionalmente, para cada uma das classe de estabilidade, os autores treinaram modelos de regressão usando o algoritmo SISSO para obtenção de valores aproximados da energia de formação, necessária para o cálculo da estabilidade em relação às fases rivais para decomposição. Na Figura
       <a class="open-asset-modal" data-target="#ModalFigS3_F11" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        11
       </a>
       c é mostrado um gráfico de paridade entre os valores previstos e os valores de referência para a classe dos materiais altamente estáveis, onde modelos com melhor performance se aproximam mais da diagonal (
       <i>
        R
       </i>
       <sup>
        2
       </sup>
       = 1). Esse modelo apresentou
       <i>
        R
       </i>
       <sup>
        2
       </sup>
       = 0.9, com um erro RMSE de 0.205 eV/átomo, que é em torno de três vezes inferior ao desvio padrão dos dados em si.
      </p>
      <p>
       Tendo o modelo treinado, é então possível realizar a predição e descoberta de novos materiais até então não investigados. Os autores demonstraram essa capacidade ao gerar milhares de novas combinações inéditas em diferentes protótipos estruturais, satisfazendo regras de valência e neutralidade de carga, e então gerar a predição da estabilidade de cada um desses materiais. Para verificar se a predição de fato se mostrava acurada, realizaram cálculos DFT dessa propriedade para alguns materiais selecionados, e verificaram que em todos os casos a predição se mostrou correta. Finalmente, demonstrando a aplicabilidade do modelo de estabilidade, os autores executaram um processo de filtragem e seleção de materiais para geração de hidrogênio a partir da quebra fotoeletrocatalítica de moléculas de água, como prova de conceito. Num processo de seleção de materiais, a estabilidade termodinâmica é o primeiro critério essencial para escolha de um material para qualquer aplicação. Aplicando o modelo treinado, e adicionalmente os filtros de gap de energia eletrônico entre 1.23 e 3 eV e alinhamento de banda de energia adequado para os processos de oxidação e redução da água, encontraram materiais 2D promissores para essa aplicação (Fig.
       <a class="open-asset-modal" data-target="#ModalFigS3_F11" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        11
       </a>
       d), do qual o material PbTe ainda não havia sido sugerido para essa aplicação na literatura. Adicionalmente, baseado na similaridade estrutural e química dos candidatos promissores, previram a estabilidade e calcularam a viabilidade do novo material Sn
       <sub>
        2
       </sub>
       SeTe para essa aplicação [
       <span class="ref">
        <sup class="xref xrefblue">
         24
        </sup>
        <span class="refCtt closed">
         <span>
          24. G.R. Schleder, C.M. Acosta e A. Fazzio, ACS Applied Materials &amp; Interfaces 12, 20149 (2020).
         </span>
        </span>
       </span>
       ].
      </p>
     </li>
    </ol>
    <h2>
     3.2. Explorando o espaço configuracional
    </h2>
    <p>
     Similarmente ao processo de descoberta de materiais no espaço atômico, composicional e configuracional, há situações em que se é desejado manter uma dessas variáveis fixa, reduzindo assim a complexidade da busca. Por exemplo, pode-se desejar realizar a busca apenas em uma estrutura específica, eliminando assim a variável configuracional, ou buscar apenas materiais formados por determinados elementos, eliminando a variável atômica e realizando uma busca no espaço estrutural e composicional. Vamos apresentar um exemplo desse último caso.
    </p>
    <p>
     A predição estrutural é um dos principais sucessos obtidos com métodos quânticos de primeiros princípios, visto que as propriedades dos materiais dependem sensivelmente de sua estrutura. As ferramentas de otimização global têm a capacidade de descobrir materiais para os quais existe pouca ou nenhuma informação empírica, sejam estruturas cristalinas, moleculares, defeitos, superfícies e interfaces [
     <span class="ref">
      <sup class="xref xrefblue">
       56
      </sup>
      <span class="refCtt closed">
       <span>
        56. A.R. Oganov, C.J. Pickard, Q. Zhu e R.J. Needs, Nature Reviews Materials 4, 331 (2019).
       </span>
      </span>
     </span>
     ]. O número possível de estruturas distintas é imenso mesmo para sistemas relativamente simples, da ordem de 10
     <sup>
      <i>
       N
      </i>
     </sup>
     , onde
     <i>
      N
     </i>
     é o número de átomos na célula unitária [
     <span class="ref">
      <sup class="xref xrefblue">
       56
      </sup>
      <span class="refCtt closed">
       <span>
        56. A.R. Oganov, C.J. Pickard, Q. Zhu e R.J. Needs, Nature Reviews Materials 4, 331 (2019).
       </span>
      </span>
     </span>
     ]. Nesse contexto, é impossível investigar todas as combinações possíveis, e estratégias para amostrar eficientemente esse espaço de materiais é fundamental. O uso do ML nesse contexto é ideal. Em [
     <span class="ref">
      <sup class="xref xrefblue">
       55
      </sup>
      <span class="refCtt closed">
       <span>
        55. N. Bernstein, G. Csányi e V.L. Deringer, npj Computational Materials 5, 99 (2019).
       </span>
      </span>
     </span>
     ], os autores propõe o treinamento do zero e de forma automatizada de potenciais atomísticos de ML, sem nenhuma informação de quais estruturas são relevantes ou não. Essa forma de aprendizagem ativa converge e permite então a amostragem de grande parte do espaço configuracional de interesse, permitindo a descoberta de materiais de relevância real. A Fig.
     <a class="open-asset-modal" data-target="#ModalFigS3_F12" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      12
     </a>
     apresenta a estratégia utilizada pelos autores.
    </p>
    <div class="row fig" id="S3_F12">
     <a name="S3_F12">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigS3_F12" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/837e3a27e6c3e133ba0051e5c2da95a51cfc3c93.jpg"/>
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <strong>
       Figura 12
      </strong>
      <br/>
      Protocolo automatizado que explora iterativamente o espaço estrutural e treina potenciais interatômicos baseados em ML [
      <span class="ref">
       <sup class="xref xrefblue">
        55
       </sup>
       <span class="refCtt closed">
        <span>
         55. N. Bernstein, G. Csányi e V.L. Deringer, npj Computational Materials 5, 99 (2019).
        </span>
       </span>
      </span>
      ]. De um conjunto aleatório inicial de células unitárias (azul), são selecionadas as geometricamente mais diversas usando o algoritmo CUR. As estruturas selecionadas são calculadas com DFT e usadas para treinar um potencial de ML (GAP) (laranja). Esse potencial é usado para relaxar um novo conjunto de estruturas aleatórias (verde), selecionando novamente os casos mais relevantes e repetindo o ciclo até a convergência, encerrando assim a busca. Adaptado de [
      <span class="ref">
       <sup class="xref xrefblue">
        55
       </sup>
       <span class="refCtt closed">
        <span>
         55. N. Bernstein, G. Csányi e V.L. Deringer, npj Computational Materials 5, 99 (2019).
        </span>
       </span>
      </span>
      ]
      <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">
       CC BY 4.0
      </a>
      .
      <br/>
     </div>
    </div>
    <p>
     Vamos descrever brevemente cada um dos quatro componentes do processo de machine learning (Fig.
     <a class="open-asset-modal" data-target="#ModalFigS2_F4" data-toggle="modal" href="">
      <span class="sci-ico-fileFigure">
      </span>
      4
     </a>
     ) para esse exemplo.
    </p>
    <ol type="i">
     <li>
      <p>
       Definição do problema: o objetivo do estudo é a descoberta de materiais do zero e automatizada, explorando o espaço estrutural de forma iterativa ao treinar potenciais atomísticos baseados em ML. Portanto, nesse caso a tarefa de ML é um problema de apredizado supervisionado, onde é feita a regressão dos parâmetros otimizados de potenciais interatômicos que irão descrever as interações dos materiais.
      </p>
     </li>
     <li>
      <p>
       Dados: a proposta é a geração ativa e iterativa dos dados durante o treinamento do modelo de ML, como mostrado na Fig.
       <a class="open-asset-modal" data-target="#ModalFigS3_F12" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        12
       </a>
       . Os dados são o conjunto de estruturas e energias e forças atômicas associadas à cada uma delas, obtidas com cálculos de DFT. Inicialmente é gerado um conjunto de estruturas aleatórias, e selecionado um subconjunto de acordo com a maior diversidade estrutural para serem calculadas. Com essas informações, um potencial de ML é treinado, e o processo se repete, porém agora as estruturas aleatórias são relaxadas com o potencial obtido antes da seleção do subconjunto a ser calculado. O processo iterativo é executado até obter resultados de energias e forças satisfatórios, no estudo em torno de 2500 cálculos fixos foram necessários [
       <span class="ref">
        <sup class="xref xrefblue">
         55
        </sup>
        <span class="refCtt closed">
         <span>
          55. N. Bernstein, G. Csányi e V.L. Deringer, npj Computational Materials 5, 99 (2019).
         </span>
        </span>
       </span>
       ].
      </p>
     </li>
     <li>
      <p>
       Representação: o treinamento de um potencial interatômico de ML busca a descrição da superfície de energia potencial (PES) dos sistemas em função das posições dos átomos. Dessa forma, a representação detalhada dos ambientes atômicos é de extrema importância. Os autores utilizam a representação chamada de sobreposição suave de posições atômicas (SOAP) [
       <span class="ref">
        <sup class="xref xrefblue">
         57
        </sup>
        <span class="refCtt closed">
         <span>
          57. A.P. Bartók, R. Kondor e G. Csányi, Physical Review B 87, 184115 (2013).
         </span>
        </span>
       </span>
       ], em que a densidade de vizinhos de um átomo
       <i>
        i
       </i>
       é expandida em uma base local de funções radiais
       <i>
        g_n
       </i>
       e harmônicos esféricos
       <i>
        Y
       </i>
       <sub>
        <i>
         lm
        </i>
       </sub>
       :
      </p>
      <div class="row formula" id="eS3_E11">
       <a name="S3_E11">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (11)
         </span>
         <math alttext="\displaystyle\rho_{i}(\mathbf{R})=\sum_{j}exp(-|r-r_{ij}|^{2}/2\sigma^{2}_{at})" display="block">
          <mrow>
           <mrow>
            <msub>
             <mi>
              ρ
             </mi>
             <mi>
              i
             </mi>
            </msub>
            <mo>
             ⁢
            </mo>
            <mrow>
             <mo stretchy="false">
              (
             </mo>
             <mi mathvariant="bold">
              R
             </mi>
             <mo stretchy="false">
              )
             </mo>
            </mrow>
           </mrow>
           <mo>
            =
           </mo>
           <mrow>
            <munder>
             <mo largeop="true" movablelimits="false" symmetric="true">
              ∑
             </mo>
             <mi>
              j
             </mi>
            </munder>
            <mrow>
             <mi>
              e
             </mi>
             <mo>
              ⁢
             </mo>
             <mi>
              x
             </mi>
             <mo>
              ⁢
             </mo>
             <mi>
              p
             </mi>
             <mo>
              ⁢
             </mo>
             <mrow>
              <mo stretchy="false">
               (
              </mo>
              <mrow>
               <mo>
                -
               </mo>
               <mrow>
                <mrow>
                 <msup>
                  <mrow>
                   <mo stretchy="false">
                    |
                   </mo>
                   <mrow>
                    <mi>
                     r
                    </mi>
                    <mo>
                     -
                    </mo>
                    <msub>
                     <mi>
                      r
                     </mi>
                     <mrow>
                      <mi>
                       i
                      </mi>
                      <mo>
                       ⁢
                      </mo>
                      <mi>
                       j
                      </mi>
                     </mrow>
                    </msub>
                   </mrow>
                   <mo stretchy="false">
                    |
                   </mo>
                  </mrow>
                  <mn>
                   2
                  </mn>
                 </msup>
                 <mo>
                  /
                 </mo>
                 <mn>
                  2
                 </mn>
                </mrow>
                <mo>
                 ⁢
                </mo>
                <msubsup>
                 <mi>
                  σ
                 </mi>
                 <mrow>
                  <mi>
                   a
                  </mi>
                  <mo>
                   ⁢
                  </mo>
                  <mi>
                   t
                  </mi>
                 </mrow>
                 <mn>
                  2
                 </mn>
                </msubsup>
               </mrow>
              </mrow>
              <mo stretchy="false">
               )
              </mo>
             </mrow>
            </mrow>
           </mrow>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <div class="row formula" id="eS3_E12">
       <a name="S3_E12">
       </a>
       <div class="col-md-12">
        <div class="formula-container">
         <span class="label">
          (12)
         </span>
         <math alttext="\displaystyle=\sum_{nlm}c_{nlm}^{(i)}g_{n}(r)Y_{lm}(\hat{r})," display="block">
          <mrow>
           <mrow>
            <mi>
            </mi>
            <mo>
             =
            </mo>
            <mrow>
             <munder>
              <mo largeop="true" movablelimits="false" symmetric="true">
               ∑
              </mo>
              <mrow>
               <mi>
                n
               </mi>
               <mo>
                ⁢
               </mo>
               <mi>
                l
               </mi>
               <mo>
                ⁢
               </mo>
               <mi>
                m
               </mi>
              </mrow>
             </munder>
             <mrow>
              <msubsup>
               <mi>
                c
               </mi>
               <mrow>
                <mi>
                 n
                </mi>
                <mo>
                 ⁢
                </mo>
                <mi>
                 l
                </mi>
                <mo>
                 ⁢
                </mo>
                <mi>
                 m
                </mi>
               </mrow>
               <mrow>
                <mo stretchy="false">
                 (
                </mo>
                <mi>
                 i
                </mi>
                <mo stretchy="false">
                 )
                </mo>
               </mrow>
              </msubsup>
              <mo>
               ⁢
              </mo>
              <msub>
               <mi>
                g
               </mi>
               <mi>
                n
               </mi>
              </msub>
              <mo>
               ⁢
              </mo>
              <mrow>
               <mo stretchy="false">
                (
               </mo>
               <mi>
                r
               </mi>
               <mo stretchy="false">
                )
               </mo>
              </mrow>
              <mo>
               ⁢
              </mo>
              <msub>
               <mi>
                Y
               </mi>
               <mrow>
                <mi>
                 l
                </mi>
                <mo>
                 ⁢
                </mo>
                <mi>
                 m
                </mi>
               </mrow>
              </msub>
              <mo>
               ⁢
              </mo>
              <mrow>
               <mo stretchy="false">
                (
               </mo>
               <mover accent="true">
                <mi>
                 r
                </mi>
                <mo stretchy="false">
                 ^
                </mo>
               </mover>
               <mo stretchy="false">
                )
               </mo>
              </mrow>
             </mrow>
            </mrow>
           </mrow>
           <mo>
            ,
           </mo>
          </mrow>
         </math>
        </div>
       </div>
      </div>
      <p>
       onde
       <i>
        j
       </i>
       são os vizinhos do átomo dentro de um raio de corte especificado.
      </p>
     </li>
     <li>
      <p>
       Algoritmos, validação, e aplicação: os autores treinam potenciais de aproximações Gaussianas (GAP) [
       <span class="ref">
        <sup class="xref xrefblue">
         58
        </sup>
        <span class="refCtt closed">
         <span>
          58. A.P. Bartók, M.C. Payne, R. Kondor e G. Csányi, Physical Review Letters 104, 136403 (2010).
         </span>
        </span>
       </span>
       ], que combinam o descritor SOAP apresentado acima com a regressão kernel ridge, obtendo as contribuições atômicas da energia total:
       <math id="INEQ62">
        <mrow>
         <mrow>
          <mi>
           ε
          </mi>
          <mo>
           ⁢
          </mo>
          <mrow>
           <mo stretchy="false">
            (
           </mo>
           <mi mathvariant="bold">
            q
           </mi>
           <mo stretchy="false">
            )
           </mo>
          </mrow>
         </mrow>
         <mo>
          =
         </mo>
         <mrow>
          <msubsup>
           <mo largeop="true" symmetric="true">
            ∑
           </mo>
           <mrow>
            <mi>
             k
            </mi>
            <mo>
             =
            </mo>
            <mn>
             1
            </mn>
           </mrow>
           <mi>
            N
           </mi>
          </msubsup>
          <mrow>
           <msub>
            <mi>
             α
            </mi>
            <mi>
             k
            </mi>
           </msub>
           <mo>
            ⁢
           </mo>
           <mi>
            K
           </mi>
           <mo>
            ⁢
           </mo>
           <mrow>
            <mo stretchy="false">
             (
            </mo>
            <mi mathvariant="bold">
             q
            </mi>
            <mo>
             ,
            </mo>
            <msup>
             <mtext mathvariant="bold">
              q
             </mtext>
             <mi>
              k
             </mi>
            </msup>
            <mo stretchy="false">
             )
            </mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
       </math>
       , onde
       <b>
        q
       </b>
       e
       <b>
        q
       </b>
       <sup>
        <i>
         k
        </i>
       </sup>
       são o descritor do ambiente local do átomo de referência e de outro átomo,
       <i>
        N
       </i>
       é o número de diferentes configurações de treinamento, indexadas por
       <i>
        k
       </i>
       . A tarefa de ML que vai determinar o vetor de coeficientes α, e K é uma função não-linear fixa, chamada de
       <i>
        kernel
       </i>
       , que tem como objetivo medir a similaridade entre os ambientes atômicos de seus dois argumentos. O kernel SOAP é mostrado na equação (
       <a class="open-asset-modal" data-target="#ModalSchemeS3_E11" data-toggle="modal" href="">
        <span class="sci-ico-fileFormula">
        </span>
        11
       </a>
       ).
      </p>
      <p>
       Os autores aplicam a estratégia descrita para descoberta de alótropos em diferentes sistemas. Um caso desafiador de ser capturado é o boro, um dos elementos estruturalmente mais complexos. O protocolo é capaz de descobrir a estrutura do
       <i>
        α
       </i>
       −
       <i>
        B
       </i>
       <sub>
        12
       </sub>
       de forma autônoma, como mostrado na Fig.
       <a class="open-asset-modal" data-target="#ModalFigS3_F13" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        13
       </a>
       a. Percebe-se que o protocolo atinge alta acurácia permitindo a descoberta de materiais sem intervenção do cientista. O método não se limita a um sistema específico, por exemplo, consegue aprender corretamente a estrutura e energias relativas de diferentes alótropos de carbono com alta precisão (Fig.
       <a class="open-asset-modal" data-target="#ModalFigS3_F13" data-toggle="modal" href="">
        <span class="sci-ico-fileFigure">
        </span>
        13
       </a>
       b-c).
      </p>
      <p>
       Resultados similares são obtidos para diferentes sistemas isolantes, semicondutores e metálicos [
       <span class="ref">
        <sup class="xref xrefblue">
         55
        </sup>
        <span class="refCtt closed">
         <span>
          55. N. Bernstein, G. Csányi e V.L. Deringer, npj Computational Materials 5, 99 (2019).
         </span>
        </span>
       </span>
       ], permitindo a obtenção de importante informação estrutural na descoberta de materiais.
      </p>
     </li>
    </ol>
    <div class="row fig" id="S3_F13">
     <a name="S3_F13">
     </a>
     <div class="col-md-4 col-sm-4">
      <a data-target="#ModalFigS3_F13" data-toggle="modal" href="">
       <div class="thumbImg">
        <img src="https://minio.scielo.br/documentstore/1806-9126/qzcfSKw4nzBK5Mddr8ZXy4v/2ceff0c0f3a14bcc8cb32ac884c5be3b5b372724.jpg"/>
        <div class="zoom">
         <span class="sci-ico-zoom">
         </span>
        </div>
       </div>
      </a>
     </div>
     <div class="col-md-8 col-sm-8">
      <strong>
       Figura 13
      </strong>
      <br/>
      Resultados do modelo de ML e aplicação [
      <span class="ref">
       <sup class="xref xrefblue">
        55
       </sup>
       <span class="refCtt closed">
        <span>
         55. N. Bernstein, G. Csányi e V.L. Deringer, npj Computational Materials 5, 99 (2019).
        </span>
       </span>
      </span>
      ]. (a) Aprendizagem da estrutura cristalina do boro α-romboédrico. Esquerda: erro do modelo GAP gerado iterativamente, para a estrutura otimizada de menor energia do
      <i>
       α
      </i>
      −
      <i>
       B
      </i>
      <sub>
       12
      </sub>
      , em relação ao DFT. São comparadas a seleção aleatória de pontos (cinza), o procedimento de seleção usando CUR com descritores SOAP (verde), e o mesmo mas usando CUR com kernels SOAP (roxo). Direita: Evolução do icosaedro
      <i>
       B
      </i>
      <sub>
       <i>
        12
       </i>
      </sub>
      como o principal fragmento estrutural, para três pontos nos
      <i>
       N
      </i>
      ciclos, 400 (A), 500 (B) e 2500 (C) cálculos DFT no total. A respectiva estrutura de menor energia da iteração é mostrada. (b) Aprendizagem de diversas estruturas cristalinas de carbono sem conhecimento prévio. Erro entre as energias calculadas por DFT e GAP para as estruturas otimizadas com cada método. (c) Curvas de energia-volume calculadas com o modelo GAP final (linhas sólidas) e a referência DFT (linhas tracejadas). Energias em relação à menor energia obtida com DFT. Adaptado de [
      <span class="ref">
       <sup class="xref xrefblue">
        55
       </sup>
       <span class="refCtt closed">
        <span>
         55. N. Bernstein, G. Csányi e V.L. Deringer, npj Computational Materials 5, 99 (2019).
        </span>
       </span>
      </span>
      ]
      <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">
       CC BY 4.0
      </a>
      .
      <br/>
     </div>
    </div>
    <h1 class="articleSectionTitle">
     4. Conclusão: Futuro e Perspectivas
    </h1>
    <p>
     O uso de estratégias baseadas em dados na ciência de materiais e áreas correlatas ainda é muito recente, porém nesse curto período já demonstrou ser capaz de solucionar grandes desafios. Cada vez mais as técnicas de machine learning serão utilizadas. Vislumbramos que estas farão parte do cotidiano das novas gerações de pesquisadores. Como assinalado por Meredig [
     <span class="ref">
      <sup class="xref xrefblue">
       59
      </sup>
      <span class="refCtt closed">
       <span>
        59. B. Meredig, Chemistry of Materials 31, 9579 (2019).
       </span>
      </span>
     </span>
     ], “
     <i>
      o machine learning não vai substituir os cientistas, mas os cientistas que usam machine learning vão substituir os que não usam
     </i>
     ”. Sendo ferramentas estatísticas, a compreensão das condições necessárias e favoráveis para sua aplicação são fundamentais, assim como as limitações técnicas que prejudicam e eventualmente impedem seu uso. O crescente potencial e resultados obtidos nessa área favorecem cada vez mais o compartilhamento e disseminação dos dados e sua procedência, em direção à uma ciência mais verificável, reprodutível e robusta. Os desafios e possibilidades que estão por vir serão determinados pela criatividade dos cientistas, que ao contrário do que possa parecer, não serão substituídos pelas máquinas. É um período animador para usar, desenvolver e compartilhar as ferramentas da ciência de dados e inteligência artificial na interseção com os conhecimentos específicos das á reas como física, química e ciência de materiais.
    </p>
   </div>
   <div class="articleSection" data-anchor="Agradecimentos">
    <h1 class="articleSectionTitle">
     Agradecimentos
    </h1>
    <p>
     Os autores têm apoio da Fundação de Amparo à Pesquisa do Estado de São Paulo (FAPESP), projetos 17/18139-6 e 17/02317-2.
    </p>
   </div>
   <div class="articleSection" data-anchor="Referências bibliográficas">
    <h1 class="articleSectionTitle">
     Referências
    </h1>
    <div class="ref-list">
     <ul class="refList">
      <li>
       <sup class="xref big">
        1.
       </sup>
       <div>
        T. Kuhn,
        <i>
         The Structure of Scientific Revolutions
        </i>
        (University of Chicago Press, Chicago, 1962).
       </div>
      </li>
      <li>
       <sup class="xref big">
        2.
       </sup>
       <div>
        F.J. Dyson, Science
        <b>
         338
        </b>
        , 1426 (2012).
       </div>
      </li>
      <li>
       <sup class="xref big">
        3.
       </sup>
       <div>
        P. Galison,
        <i>
         Image and logic: A material culture of microphysics
        </i>
        (University of Chicago Press, Chicago, 1997).
       </div>
      </li>
      <li>
       <sup class="xref big">
        4.
       </sup>
       <div>
        F.J. Dyson,
        <i>
         Imagined worlds
        </i>
        (Harvard University Press, Massachusetts, 1997).
       </div>
      </li>
      <li>
       <sup class="xref big">
        5.
       </sup>
       <div>
        T. Hey, S. Tansley e K. Tolle, em:
        <i>
         The Fourth Paradigm: Data-Intensive Scientific Discovery
        </i>
        , editado por T. Hey (Microsoft Research, Redmond, 2009).
       </div>
      </li>
      <li>
       <sup class="xref big">
        6.
       </sup>
       <div>
        G.R. Schleder, A.C.M. Padilha, C.M. Acosta, M. Costa e A. Fazzio, Journal of Physics: Materials
        <b>
         2
        </b>
        , 032001 (2019).
       </div>
      </li>
      <li>
       <sup class="xref big">
        7.
       </sup>
       <div>
        A. Agrawal e A. Choudhary, APL Materials
        <b>
         4
        </b>
        , 053208 (2016).
       </div>
      </li>
      <li>
       <sup class="xref big">
        8.
       </sup>
       <div>
        S. Curtarolo, G.L.W. Hart, M.B. Nardelli, N. Mingo, S. Sanvito e O. Levy, Nature Materials
        <b>
         12
        </b>
        , 191 (2013).
       </div>
      </li>
      <li>
       <sup class="xref big">
        9.
       </sup>
       <div>
        A. Jain, K.A. Persson e G. Ceder, APL Materials
        <b>
         4
        </b>
        , 053102 (2016).
       </div>
      </li>
      <li>
       <sup class="xref big">
        10.
       </sup>
       <div>
        C.L. Magee, Complexity
        <b>
         18
        </b>
        , 10 (2012).
       </div>
      </li>
      <li>
       <sup class="xref big">
        11.
       </sup>
       <div>
        P. Gribbon e S. Andreas, Drug Discovery Today
        <b>
         10
        </b>
        , 17 (2005).
       </div>
      </li>
      <li>
       <sup class="xref big">
        12.
       </sup>
       <div>
        D.A. Pereira e J.A. Williams, British Journal of Pharmacology
        <b>
         152
        </b>
        , 53 (2009).
       </div>
      </li>
      <li>
       <sup class="xref big">
        13.
       </sup>
       <div>
        F. Giustino, M. Bibes, J.H. Lee, F. Trier, R. Valentí, S.M. Winter, Y.W. Son, L. Taillefer, C. Heil, A.I. Figueroa et al., Journal of Physics: Materials,
        <a href="https://doi.org/10.1088/2515-7639/abb74e" target="_blank">
         https://doi.org/10.1088/2515-7639/abb74e
        </a>
        (2020).
        <br/>
        <a href="https://doi.org/10.1088/2515-7639/abb74e" target="_blank">
         » https://doi.org/10.1088/2515-7639/abb74e
        </a>
       </div>
      </li>
      <li>
       <sup class="xref big">
        14.
       </sup>
       <div>
        G.R. Schleder, A.C.M. Padilha, A.R. Rocha, G.M. Dalpian e A. Fazzio, Journal of Chemical Information and Modeling
        <b>
         60
        </b>
        , 452 (2020).
       </div>
      </li>
      <li>
       <sup class="xref big">
        15.
       </sup>
       <div>
        J. Glick, em:
        <i>
         Ontologies and Databases—Knowledge Engineering for Materials Informatics
        </i>
        , editado por K. Rajan (Elsevier, Amsterdã, 2013).
       </div>
      </li>
      <li>
       <sup class="xref big">
        16.
       </sup>
       <div>
        E.P. Wigner, Communications on Pure and Applied Mathematics
        <b>
         13
        </b>
        , 1 (1960).
       </div>
      </li>
      <li>
       <sup class="xref big">
        17.
       </sup>
       <div>
        A. Halevy, P. Norvig e F. Pereira, IEEE Intelligent Systems
        <b>
         24
        </b>
        , 8 (2009).
       </div>
      </li>
      <li>
       <sup class="xref big">
        18.
       </sup>
       <div>
        K.P. Murphy,
        <i>
         Machine Learning: A Probabilistic Perspective
        </i>
        (MIT Press, Cambridge, 2012).
       </div>
      </li>
      <li>
       <sup class="xref big">
        19.
       </sup>
       <div>
        A.L. Samuel, IBM Journal of Research and Development
        <b>
         3
        </b>
        , 210 (1959).
       </div>
      </li>
      <li>
       <sup class="xref big">
        20.
       </sup>
       <div>
        T. Hastie, R. Tibshirani e J. Friedman,
        <i>
         The Elements of Statistical Learning
        </i>
        (Springer, New York, 2001).
       </div>
      </li>
      <li>
       <sup class="xref big">
        21.
       </sup>
       <div>
        I. Goodfellow, Y. Bengio e A. Courville,
        <i>
         Deep Learning
        </i>
        , disponível em: http://www.deeplearningbook.org
        <br/>
        <a href="http://www.deeplearningbook.org" target="_blank">
         » http://www.deeplearningbook.org
        </a>
       </div>
      </li>
      <li>
       <sup class="xref big">
        22.
       </sup>
       <div>
        B. Sun, M. Fernandez e A.S. Barnard, Nanoscale Horizons
        <b>
         1
        </b>
        , 89 (2016).
       </div>
      </li>
      <li>
       <sup class="xref big">
        23.
       </sup>
       <div>
        R. Ramprasad, R. Batra, G. Pilania, A. Mannodi-Kanakkithodi e C. Kim, npj Computational Materials
        <b>
         3
        </b>
        , 54 (2017).
       </div>
      </li>
      <li>
       <sup class="xref big">
        24.
       </sup>
       <div>
        G.R. Schleder, C.M. Acosta e A. Fazzio, ACS Applied Materials &amp; Interfaces
        <b>
         12
        </b>
        , 20149 (2020).
       </div>
      </li>
      <li>
       <sup class="xref big">
        25.
       </sup>
       <div>
        S.W. Knox,
        <i>
         Machine Learning
        </i>
        (John Wiley &amp; Sons, Hoboken, 2018).
       </div>
      </li>
      <li>
       <sup class="xref big">
        26.
       </sup>
       <div>
        M.L. Hutchinson, E. Antono, B.M. Gibbons, S. Paradiso, J. Ling e B. Meredig, arXiv:1711.05099 (2017).
       </div>
      </li>
      <li>
       <sup class="xref big">
        27.
       </sup>
       <div>
        L.M. Ghiringhelli, J. Vybiral, S.V. Levchenko, C. Draxl e M. Scheffler, Physical Review Letters
        <b>
         114
        </b>
        , 105503 (2015).
       </div>
      </li>
      <li>
       <sup class="xref big">
        28.
       </sup>
       <div>
        L. Ward e C. Wolverton, Current Opinion in Solid State and Materials Science
        <b>
         21
        </b>
        , 167 (2016).
       </div>
      </li>
      <li>
       <sup class="xref big">
        29.
       </sup>
       <div>
        P. Domingos, Commun. ACM
        <b>
         55
        </b>
        , 78 (2012).
       </div>
      </li>
      <li>
       <sup class="xref big">
        30.
       </sup>
       <div>
        D.H. Wolpert e W.G. Macready, Mach. Learn.
        <b>
         20
        </b>
        , 273 (1995).
       </div>
      </li>
      <li>
       <sup class="xref big">
        31.
       </sup>
       <div>
        D.H. Wolpert, Neural Comput.
        <b>
         8
        </b>
        , 1341 (1996).
       </div>
      </li>
      <li>
       <sup class="xref big">
        32.
       </sup>
       <div>
        M. van Heel, R.V. Portugal e M. Schatz, Open J. Stat.
        <b>
         6
        </b>
        , 701 (2016).
       </div>
      </li>
      <li>
       <sup class="xref big">
        33.
       </sup>
       <div>
        C. Cortes e V. Vapnik, Mach. Learn.
        <b>
         20
        </b>
        , 273 (1995).
       </div>
      </li>
      <li>
       <sup class="xref big">
        34.
       </sup>
       <div>
        R. Kohavi e R. Quinlan,
        <i>
         Decision Tree Discovery
        </i>
        , disponível em: http://ai.stanford.edu/∼ronnyk/ treesHB.pdf
        <br/>
        <a href="http://ai.stanford.edu/ronnyk/treesHB.pdf" target="_blank">
         » http://ai.stanford.edu/∼ronnyk/treesHB.pdf
        </a>
       </div>
      </li>
      <li>
       <sup class="xref big">
        35.
       </sup>
       <div>
        J.R. Quinlan,
        <i>
         C4.5: Programs for Machine Learning
        </i>
        (Morgan Kaufmann Publishers Inc., San Francisco, 1993).
       </div>
      </li>
      <li>
       <sup class="xref big">
        36.
       </sup>
       <div>
        F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg et al.,
        <i>
         Journal of Machine Learning Research
        </i>
        <b>
         12
        </b>
        , 2825 (2011).
       </div>
      </li>
      <li>
       <sup class="xref big">
        37.
       </sup>
       <div>
        M. Hall, E. Frank, G. Holmes, B. Pfahringer, P. Reutemann e I.H. Witten, ACM SIGKDD explorations newsletter
        <b>
         11
        </b>
        , 10 (2009).
       </div>
      </li>
      <li>
       <sup class="xref big">
        38.
       </sup>
       <div>
        tensorflow.org
        <br/>
        <a href="https://www.tensorflow.org" target="_blank">
         » tensorflow.org
        </a>
       </div>
      </li>
      <li>
       <sup class="xref big">
        39.
       </sup>
       <div>
        A. Paszke, S. Gross, F. Massa, A. Lerer, J. Bradbury, G. Chanan, T. Killeen, Z. Lin, N. Gimelshein, L. Antiga et al., arXiv:1912.01703 (2019).
       </div>
      </li>
      <li>
       <sup class="xref big">
        40.
       </sup>
       <div>
        G.R. Schleder, gschleder/MLtutorial-v1.0.0.zip (2019), v. 1, disponível em:
        <a href="https://doi.org/10.5281/zenodo.4041648" target="_blank">
         https://doi.org/10.5281/zenodo.4041648
        </a>
        <br/>
        <a href="https://doi.org/10.5281/zenodo.4041648" target="_blank">
         » https://doi.org/10.5281/zenodo.4041648
        </a>
       </div>
      </li>
      <li>
       <sup class="xref big">
        41.
       </sup>
       <div>
        A. Chandrasekaran, D. Kamal, R. Batra, C. Kim, L. Chen e R. Ramprasad, npj Computational Materials
        <b>
         5
        </b>
        , 22 (2019).
       </div>
      </li>
      <li>
       <sup class="xref big">
        42.
       </sup>
       <div>
        K.T. Schütt, M. Gastegger, A. Tkatchenko, K.R. Müller e R.J. Maurer, Nature Communications
        <b>
         10
        </b>
        , 5024 (2019).
       </div>
      </li>
      <li>
       <sup class="xref big">
        43.
       </sup>
       <div>
        J.A. Garrido Torres, P.C. Jennings, M.H. Hansen, J.R. Boes e T. Bligaard, Physical Review Letters
        <b>
         122
        </b>
        , 156001 (2019).
       </div>
      </li>
      <li>
       <sup class="xref big">
        44.
       </sup>
       <div>
        M.H. Hansen, J.A.G. Torres, P.C. Jennings, Z. Wang, J.R. Boes, O.G. Mamun e T. Bligaard, arXiv:1904.00904 (2019).
       </div>
      </li>
      <li>
       <sup class="xref big">
        45.
       </sup>
       <div>
        M. Costa, G.R. Schleder, M.B. Nardelli, C. Lewenkopf e A. Fazzio, Nano Letters
        <b>
         19
        </b>
        , 8941 (2019).
       </div>
      </li>
      <li>
       <sup class="xref big">
        46.
       </sup>
       <div>
        A.S. Barnard, B. Motevalli, A.J. Parker, J.M. Fischer, C.A. Feigl e G. Opletal, Nanoscale,
        <b>
         11
        </b>
        , 19190 (2019).
       </div>
      </li>
      <li>
       <sup class="xref big">
        47.
       </sup>
       <div>
        S. Heinen, M. Schwilk, G.F. von Rudorff e O. Anatole von Lilienfeld, Machine Learning: Science and Technology
        <b>
         1
        </b>
        , 025002, 2020.
       </div>
      </li>
      <li>
       <sup class="xref big">
        48.
       </sup>
       <div>
        G.S. Silva, L.P. Oliveira, G.F. Costa, G.F. Giordano, C.Y.N. Nicoliche, A.A. Silva, L.U. Khan, G.H. Silva, A.L. Gobbi, J.V. Silveira et al., Sensors and Actuators B: Chemical
        <b>
         305
        </b>
        , 127482 (2020).
       </div>
      </li>
      <li>
       <sup class="xref big">
        49.
       </sup>
       <div>
        C.Y.N. Nicoliche, R.A.G. Oliveira, G.S. Silva, L.F. Ferreira, I.L. Rodrigues, R.C. Faria, A. Fazzio, E. Carrilho, L.G. Pontes, G.R. Schleder et al., ACS Sensors
        <b>
         5
        </b>
        , 1864 (2020).
       </div>
      </li>
      <li>
       <sup class="xref big">
        50.
       </sup>
       <div>
        G.F. Giordano, L.C.S. Vieira, A.O. Gomes, R.M. Carvalho, L.T. Kubota, A. Fazzio, G.R. Schleder, A.L. Gobbi e R.S. Lima, Fuel
        <b>
         285
        </b>
        , 119072 (2021).
       </div>
      </li>
      <li>
       <sup class="xref big">
        51.
       </sup>
       <div>
        C. Mera Acosta, E. Ogoshi, A. Fazzio, G.M. Dalpian e A. Zunger, Matter
        <b>
         3
        </b>
        , 145 (2020).
       </div>
      </li>
      <li>
       <sup class="xref big">
        52.
       </sup>
       <div>
        S. Haastrup, M. Strange, M. Pandey, T. Deilmann, P.S. Schmidt, N.F. Hinsche, M.N. Gjerding, D. Torelli, P.M. Larsen, A.C. Riis-Jensen et al., 2D Materials
        <b>
         5
        </b>
        , 042002 (2018).
       </div>
      </li>
      <li>
       <sup class="xref big">
        53.
       </sup>
       <div>
        L. Ward, A. Agrawal, A. Choudhary e Christopher Wolverton, npj Computational Materials
        <b>
         2
        </b>
        , 16028 (2016).
       </div>
      </li>
      <li>
       <sup class="xref big">
        54.
       </sup>
       <div>
        R. Ouyang, S. Curtarolo, E. Ahmetcik, M. Scheffler e L.M. Ghiringhelli, Physical Review Materials
        <b>
         2
        </b>
        , 083802 (2018).
       </div>
      </li>
      <li>
       <sup class="xref big">
        55.
       </sup>
       <div>
        N. Bernstein, G. Csányi e V.L. Deringer, npj Computational Materials
        <b>
         5
        </b>
        , 99 (2019).
       </div>
      </li>
      <li>
       <sup class="xref big">
        56.
       </sup>
       <div>
        A.R. Oganov, C.J. Pickard, Q. Zhu e R.J. Needs, Nature Reviews Materials
        <b>
         4
        </b>
        , 331 (2019).
       </div>
      </li>
      <li>
       <sup class="xref big">
        57.
       </sup>
       <div>
        A.P. Bartók, R. Kondor e G. Csányi, Physical Review B
        <b>
         87
        </b>
        , 184115 (2013).
       </div>
      </li>
      <li>
       <sup class="xref big">
        58.
       </sup>
       <div>
        A.P. Bartók, M.C. Payne, R. Kondor e G. Csányi, Physical Review Letters
        <b>
         104
        </b>
        , 136403 (2010).
       </div>
      </li>
      <li>
       <sup class="xref big">
        59.
       </sup>
       <div>
        B. Meredig, Chemistry of Materials
        <b>
         31
        </b>
        , 9579 (2019).
       </div>
      </li>
     </ul>
    </div>
   </div>
   <div class="articleSection">
    <div class="ref-list">
     <ul class="refList footnote">
      <li>
       <span class="xref big">
        1
       </span>
       <div>
        Tradução livre do original:
        <i>
         “New directions in science are launched by new tools much more often than by new concepts. The effect of a concept-driven revolution is to explain old things in new ways. The effect of a tool-driven revolution is to discover new things that have to be explained.”
        </i>
        [
        <span class="ref">
         <sup class="xref xrefblue">
          4
         </sup>
         <span class="refCtt closed">
          <span>
           4. F.J. Dyson, Imagined worlds (Harvard University Press, Massachusetts, 1997).
          </span>
         </span>
        </span>
        ].
       </div>
      </li>
     </ul>
    </div>
   </div>
   <div class="articleSection" data-anchor="Datas de Publicação ">
    <h1 class="articleSectionTitle">
     Datas de Publicação
    </h1>
    <div class="row">
     <div class="col-md-12 col-sm-12">
      <ul class="articleTimeline">
       <li>
        <strong>
         Publicação nesta coleção
        </strong>
        <br/>
        05 Mar 2021
       </li>
       <li>
        <strong>
         Data do Fascículo
        </strong>
        <br/>
        2021
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="articleSection" data-anchor="Histórico">
    <h1 class="articleSectionTitle">
     Histórico
    </h1>
    <div class="row">
     <div class="col-md-12 col-sm-12">
      <ul class="articleTimeline">
       <li>
        <strong>
         Recebido
        </strong>
        <br/>
        23 Set 2020
       </li>
       <li>
        <strong>
         Aceito
        </strong>
        <br/>
        19 Out 2020
       </li>
      </ul>
     </div>
    </div>
   </div>
   <section class="documentLicense">
    <div class="container-license">
     <div class="row">
      <div class="col-sm-3 col-md-2">
       <a href="https://creativecommons.org/licenses/by/4.0/deed.en" target="_blank" title="">
        <img alt="Creative Common - by 4.0 deed.en" src="https://licensebuttons.net/l/by/4.0/deed.en/88x31.png"/>
       </a>
      </div>
      <div class="col-sm-9 col-md-10">
       <a href="https://creativecommons.org/licenses/by/4.0/deed.en" target="_blank" title="">
        This is an open-access article distributed under the terms of the Creative Commons Attribution License (CC BY). The use, distribution or reproduction in other forums is permitted, provided the original author(s) and the copyright owner(s) are credited and that the original publication in this journal is cited, in accordance with accepted academic practice. No use, distribution or reproduction is permitted which does not comply with these terms.
       </a>
      </div>
     </div>
    </div>
   </section>
  </article>
 </div>
</div>